<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon_io/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon_io/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon_io/favicon-16x16.png">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://google-fonts.mirrors.sjtug.sjtu.edu.cn/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Roboto Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.cameudis.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="在这学期计网的PJ中，我被迫实现了GBN协议、基于连接的全双工可信传输协议，并在此基础上改造了SR协议版本，并为其添加了基础的拥塞控制机制（AIMD）。这是Github项目仓库。 主体是gbn.py以及sr.py，API接口模仿socket设计，均能连续通过200轮测试。下面是使用例（这就是全部API了）： 1234567891011121314151617181920212223# sr_ser">
<meta property="og:type" content="article">
<meta property="og:title" content="【Network#0x01】RDT协议实现（GBN和SR）">
<meta property="og:url" content="https://www.cameudis.com/Tech/Network/b81b909d9b2a.html">
<meta property="og:site_name" content="Cameudis&#39;s Homepage">
<meta property="og:description" content="在这学期计网的PJ中，我被迫实现了GBN协议、基于连接的全双工可信传输协议，并在此基础上改造了SR协议版本，并为其添加了基础的拥塞控制机制（AIMD）。这是Github项目仓库。 主体是gbn.py以及sr.py，API接口模仿socket设计，均能连续通过200轮测试。下面是使用例（这就是全部API了）： 1234567891011121314151617181920212223# sr_ser">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-06-05T06:33:29.000Z">
<meta property="article:modified_time" content="2024-01-11T08:34:36.652Z">
<meta property="article:author" content="Cameudis">
<meta property="article:tag" content="blog">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://www.cameudis.com/Tech/Network/b81b909d9b2a.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>【Network#0x01】RDT协议实现（GBN和SR） | Cameudis's Homepage</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Cameudis's Homepage</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Exp10re the W0r1d</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-notes">

    <a href="/notes/" rel="section"><i class="fa fa-sticky-note fa-fw"></i>notes</a>

  </li>
        <li class="menu-item menu-item-links">

    <a href="/link/" rel="section"><i class="fa fa-link fa-fw"></i>links</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://www.cameudis.com/Tech/Network/b81b909d9b2a.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ava1.jpg">
      <meta itemprop="name" content="Cameudis">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cameudis's Homepage">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          【Network#0x01】RDT协议实现（GBN和SR）
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-06-05 14:33:29" itemprop="dateCreated datePublished" datetime="2023-06-05T14:33:29+08:00">2023-06-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-01-11 16:34:36" itemprop="dateModified" datetime="2024-01-11T16:34:36+08:00">2024-01-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tech/" itemprop="url" rel="index"><span itemprop="name">Tech</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tech/Network/" itemprop="url" rel="index"><span itemprop="name">Network</span></a>
                </span>
            </span>

          
            <span id="/Tech/Network/b81b909d9b2a.html" class="post-meta-item leancloud_visitors" data-flag-title="【Network#0x01】RDT协议实现（GBN和SR）" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/Tech/Network/b81b909d9b2a.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/Tech/Network/b81b909d9b2a.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>在这学期计网的PJ中，我<del>被迫</del>实现了GBN协议、基于连接的全双工可信传输协议，并在此基础上改造了SR协议版本，并为其添加了基础的拥塞控制机制（AIMD）。<br>这是<a target="_blank" rel="noopener" href="https://github.com/Cameudis/RDT-protocol">Github项目仓库</a>。</p>
<p>主体是gbn.py以及sr.py，API接口模仿socket设计，均能连续通过200轮测试。下面是使用例（这就是全部API了）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sr_server.py</span></span><br><span class="line"><span class="keyword">from</span> sr <span class="keyword">import</span> SRSocket</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">&#x27;localhost&#x27;</span></span><br><span class="line">PORT = <span class="number">8000</span></span><br><span class="line"></span><br><span class="line">s = SRSocket()</span><br><span class="line">s.bind((HOST, PORT))</span><br><span class="line"></span><br><span class="line">s.listen()</span><br><span class="line">s.accept()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Connected by&#x27;</span>, s.address)</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;server/recv.jpg&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    data = s.recv()</span><br><span class="line">    <span class="keyword">if</span> data == <span class="string">b&quot;&quot;</span>: <span class="comment"># 空的数据包标识文件结束</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    f.write(data)</span><br><span class="line"></span><br><span class="line">f.close()</span><br><span class="line">s.send(<span class="string">b&quot;Thank you for your data!&quot;</span>)</span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sn_client.py</span></span><br><span class="line"><span class="keyword">from</span> sr <span class="keyword">import</span> SRSocket</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">&#x27;localhost&#x27;</span></span><br><span class="line">PORT = <span class="number">8000</span></span><br><span class="line"></span><br><span class="line">s = SRSocket()</span><br><span class="line">s.connect((HOST, PORT))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Connect to&#x27;</span>, s.address)</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;client/data.jpg&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">data = f.read()</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">s.send(data)  <span class="comment"># 阻塞的</span></span><br><span class="line">s.send(<span class="string">b&quot;&quot;</span>)   <span class="comment"># 用空的payload表示文件发送结束</span></span><br><span class="line"><span class="built_in">print</span>(s.recv().decode())</span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure>

<p>客户端将会把图片 <code>client/data.jpg</code> 传输至服务器端，服务器保存图片至文件 <code>server/recv.jpg</code> 后，将会给客户端发送一条信息，客户端接收并将其打印出来。</p>
<p>由于是全双工的，所以客户端可以给服务器发送消息，服务器也可以给客户端发送消息。</p>
<h2 id="1-GBN"><a href="#1-GBN" class="headerlink" title="1 GBN"></a>1 GBN</h2><h3 id="1-1-准备"><a href="#1-1-准备" class="headerlink" title="1.1 准备"></a>1.1 准备</h3><p>为了保证全双工的一致性，从一开始就准备将服务器端协议实现和客户端协议实现放在一个类中，命名为GBNSocket。为了方便起见，我直接模仿socket的api，主要是如下这些函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 客户端</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">address</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务端</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bind</span>(<span class="params">address</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">listen</span>()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">accept</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通用</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send</span>(<span class="params">data</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">recv</span>(<span class="params">[size]</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">close</span>()</span><br></pre></td></tr></table></figure>

<p>真实的accpet函数会返回一个新的套接字，我将其简化为自身就变成与之通信的套接字。</p>
<p>我设计的数据包结构为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">packet</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> seqNum;</span><br><span class="line">    <span class="type">uint8_t</span> ackNum; </span><br><span class="line">    <span class="type">uint8_t</span> flag;</span><br><span class="line">    <span class="type">uint8_t</span> checkSum;</span><br><span class="line">    <span class="type">uint8_t</span> data[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中flag字段有三个有效bit，定义为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SYN = <span class="number">1</span></span><br><span class="line">FIN = <span class="number">2</span></span><br><span class="line">ACK = <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>而checkSum计算方法非常简单粗暴，就是把所有字节加起来（模加法），如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getChecksum</span>(<span class="params">data</span>):</span><br><span class="line">    length = <span class="built_in">len</span>(<span class="built_in">str</span>(data))</span><br><span class="line">    checksum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, length):</span><br><span class="line">        checksum += <span class="built_in">int</span>.from_bytes(<span class="built_in">bytes</span>(<span class="built_in">str</span>(data)[i], encoding=<span class="string">&#x27;utf-8&#x27;</span>), byteorder=<span class="string">&#x27;little&#x27;</span>, signed=<span class="literal">False</span>)</span><br><span class="line">        checksum &amp;= <span class="number">0xFF</span></span><br><span class="line">    <span class="keyword">return</span> checksum</span><br></pre></td></tr></table></figure>

<h3 id="1-2-滑动窗口"><a href="#1-2-滑动窗口" class="headerlink" title="1.2 滑动窗口"></a>1.2 滑动窗口</h3><p>我为每个socket维护了两个buffer数组，分别用于发送和接收数据（<code>sdata</code> 以及 <code>rdata</code>）。<br>相关的一些指针（其实是index）定义和用途如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># send</span></span><br><span class="line">self.sdata = [<span class="literal">None</span>] * <span class="number">256</span>   <span class="comment"># send data buffer</span></span><br><span class="line">self.spos = <span class="number">0</span>               <span class="comment"># send position (last available sdata + 1)</span></span><br><span class="line">self.sbase = <span class="number">0</span>              <span class="comment"># send base</span></span><br><span class="line">self.snext = <span class="number">0</span>              <span class="comment"># next seq to be sent</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># receive</span></span><br><span class="line">self.rdata = [<span class="literal">None</span>] * <span class="number">256</span>   <span class="comment"># receive data buffer</span></span><br><span class="line">self.rbase = <span class="number">0</span>              <span class="comment"># receive base (not return to app yet)</span></span><br><span class="line">self.rexpect = <span class="number">0</span>            <span class="comment"># expected next seq</span></span><br></pre></td></tr></table></figure>

<p>这些数据在计算时全都模256进行，所以有些运算会很烦，这是我在实现协议时遇到的主要困难之一。</p>
<p>在发送包时，由于是GBN协议，因此seqNum和ackNum两个字段分别用于表示“本条消息对应的序列号”以及“我希望收到的下一个包的序列号”。这里ackNum是一种累计确认，表示自己之前的所有数据包已经接收完毕。</p>
<h3 id="1-3-雏形"><a href="#1-3-雏形" class="headerlink" title="1.3 雏形"></a>1.3 雏形</h3><p>最重要的函数显然是send和recv。<br>我将send、recv、以及一个辅助函数_wait的职能总结如下：</p>
<ul>
<li>send：将新的数据安排到 <code>self.sdata</code> 数组中（更新 <code>self.spos</code>），并在循环中根据窗口大小，发送之前没有发送过的新包（拓展 <code>self.snext</code>）。通过调用 <code>self.wait</code> 来更新 <code>self.sbase</code> ，直到所有将要发送的数据都发送完毕（<code>self.sbase == self.spos</code>）。</li>
<li>recv：<code>self.rbase</code> 表示当前没有被返回至上层的最后一个包，<code>self.rexpect</code> 表示当前已经可以返回的最后一个包。如果它俩相等，说明现在没有可以返回的包，那么recv会调用 <code>self.wait</code> 来更新 <code>self.rexpect</code>；否则recv会返回一个包的数据。</li>
<li>wait：核心函数（不属于API的一部分），负责处理收到的所有包、根据其类型来进行各种操作如发送ACK、存储数据等。其本质是更新 <code>self.sbase</code> 和 <code>self.rexpect</code>。它有recv模式，在该模式下一次超时就会返回调用者（用于recv）；除此以外，它会在结束或遇到错误（如超时次数过多）时返回false，在 <code>self.sbase == self.snext</code> 时（即所有包都确认完毕）返回true。</li>
</ul>
<p>由于是Go-Back-N协议，因此在wait中，如果发生超时，那么从 <code>self.sbase</code> 到 <code>self.snext</code> 的所有包都会被重传。</p>
<p>注意：wait是客户端和服务器端都会使用的函数，因此实现了全双工的统一性。</p>
<h3 id="1-4-连接"><a href="#1-4-连接" class="headerlink" title="1.4 连接"></a>1.4 连接</h3><p>为了标识通信开始、标识通信结束、维护随机化的sbase和rbase，需要实现连接状态。<br>为了实现连接状态，需要设计连接的开始机制和结束机制。</p>
<h4 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h4><p>在建立连接时，由客户端向进入listen阶段的服务器端口发送 <code>flag |= SYN</code> 的请求建立连接的报文。同时，客户端将会随机化其 <code>sbase</code>（初始序列号），并把 <code>sbase-1</code> 发送给服务器来让服务器的 <code>rbase</code> 与其同步。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">self, address</span>):</span><br><span class="line">    <span class="keyword">if</span> (self.connected):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[error] You have connected to addr <span class="subst">&#123;self.address&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># randomize init seq</span></span><br><span class="line">    self.sbase = random.randint(<span class="number">0</span>, <span class="number">255</span>)</span><br><span class="line">    self.snext = self.sbase</span><br><span class="line">    self.spos  = self.sbase</span><br><span class="line"></span><br><span class="line">    self.address = address</span><br><span class="line">    syn_pack = make_pkt((self.sbase-<span class="number">1</span>)%<span class="number">256</span>, <span class="number">0</span>, <span class="string">b&quot;&quot;</span>, start=<span class="literal">True</span>)</span><br><span class="line">    self.udp_send(syn_pack)</span><br></pre></td></tr></table></figure>

<p>服务器端socket首先需要调用bind来绑定某一端口监听，然后调用listen进入服务器状态。服务器状态下才可以调用 <code>accept</code>。（这个设计比较愚蠢，就是为了给listen一个用途而已）</p>
<p>服务器在 <code>accpet</code> 中接收到SYN报文后，将会将其 <code>self.address</code> 更新为客户端地址，其 <code>rbase</code> 更新为 <code>seqNum + 1</code>，随机化它自己的 <code>sbase</code>，然后向客户端发送 <code>SYN | ACK</code> 报文来确认连接。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">accept</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">not</span> self.is_server):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[error] not server&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    self.udp_socket.settimeout(<span class="literal">None</span>)</span><br><span class="line">    rcvpkt, address = self.udp_socket.recvfrom(HEADER_SIZE+BUFFER_SIZE)</span><br><span class="line">    seqNum, ackNum, flag, checksum, data = analyse_pkt(rcvpkt)</span><br><span class="line">    <span class="keyword">if</span> flag &amp; SYN:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[info] SYN from&quot;</span>, address)</span><br><span class="line">        self.connected = <span class="literal">True</span></span><br><span class="line">        self.address = address</span><br><span class="line">        </span><br><span class="line">        self.rbase = (seqNum + <span class="number">1</span>) % <span class="number">256</span></span><br><span class="line">        self.rexpect = self.rbase</span><br><span class="line">        </span><br><span class="line">        self.sbase = random.randint(<span class="number">0</span>, <span class="number">255</span>)</span><br><span class="line">        self.snext = self.sbase</span><br><span class="line">        self.spos  = self.sbase</span><br><span class="line"></span><br><span class="line">        synack_pack = make_pkt(self.sbase, self.rexpect, <span class="string">b&quot;&quot;</span>, start=<span class="literal">True</span>, ack=<span class="literal">True</span>)</span><br><span class="line">        self.udp_send(synack_pack)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[error] not SYN&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>当然，这两条特殊的报文同样要考虑丢包的问题。</p>
<p>在客户端的 <code>connect</code> 函数中，如果收不到SYN ACK，就会一直重传SYN包，直到收到 SYN ACK，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">self.udp_socket.settimeout(self.timeout)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        rcvpkt = self.udp_socket.recv(HEADER_SIZE+BUFFER_SIZE)</span><br><span class="line">        seqNum, ackNum, flag, checksum, data = analyse_pkt(rcvpkt)</span><br><span class="line">        <span class="keyword">if</span> (flag &amp; SYN) <span class="keyword">and</span> (flag &amp; ACK) <span class="keyword">and</span> (ackNum == self.sbase):</span><br><span class="line">            self.connected = <span class="literal">True</span></span><br><span class="line">            self.rbase = (seqNum + <span class="number">1</span>) % <span class="number">256</span></span><br><span class="line">            self.rexpect = self.rbase</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> socket.timeout:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[timeout] SYN ACK&quot;</span>)</span><br><span class="line">        self.udp_send(syn_pack)</span><br></pre></td></tr></table></figure>

<p>而在服务端的 <code>accpet</code> 函数中，我没有设置重传，而是将其放在 <code>wait</code> 函数中。假设SYN ACK包丢包了，客户端会继续向其发送SYN包，而服务器此时会进入 <code>wait</code> 函数进行处理。所以在 <code>wait</code> 中，如果收到了SYN包，那么它会重新发送SYN ACK包，在这里实现重传。</p>
<h4 id="断开连接"><a href="#断开连接" class="headerlink" title="断开连接"></a>断开连接</h4><p>我设计了两种正常断开连接的方法——主动断开和被动断开。不论是服务器还是客户端，都可以主动断开或被动断开。</p>
<p>主动断开即在连接中调用 <code>close</code> 函数。<code>close</code> 会向对方发送一个FIN包（通过设置flag中的FIN bit），然后等待对方发来的FIN ACK。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">close</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">not</span> self.connected):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[info] FIN...&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># send FIN</span></span><br><span class="line">    fin_pack = make_pkt(self.snext, self.rexpect, <span class="string">b&quot;&quot;</span>, stop=<span class="literal">True</span>)</span><br><span class="line">    self.udp_send(fin_pack)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># wait for FIN ACK</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>在另一方处理接收到的包的 <code>wait</code> 函数中，如果收到了FIN包，那么它会立即进入断开状态，并向其发送一个FIN ACK包。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># handle FIN</span></span><br><span class="line"><span class="keyword">elif</span> (flag &amp; FIN):</span><br><span class="line">    ack_pkt = make_pkt((self.snext-<span class="number">1</span>)%<span class="number">256</span>, self.rexpect, <span class="string">b&quot;&quot;</span>, ack=<span class="literal">True</span>, stop=<span class="literal">True</span>)</span><br><span class="line">    self.udp_send(ack_pkt)</span><br><span class="line">    self.udp_socket.settimeout(<span class="literal">None</span>)</span><br><span class="line">    self.connected = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>当然，上面两种情景也需要考虑丢包问题。<br>如果主动发送的FIN包发生丢包，也就是收不到FIN ACK，那么它就会一直重传FIN包。<br>在我的实现中，FIN ACK包只会发送一次，如果它丢包了就说明主动断开的那一方永远收不到FIN ACK了。因此，我在 <code>close</code> 函数中加入了如果超时次数超过 <code>MAX_TIMEOUT</code>，就假装自己收到了FIN ACK。从而也断开连接。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># wait for FIN ACK (close函数，接上文)</span></span><br><span class="line">self.udp_socket.settimeout(self.timeout)</span><br><span class="line">timeout_count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">if</span> timeout_count &gt;= MAX_TIMEOUT:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[info] FIN...&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        rcvpkt = self.udp_socket.recv(HEADER_SIZE+BUFFER_SIZE)</span><br><span class="line">        seqNum, ackNum, flag, checksum, data = analyse_pkt(rcvpkt)</span><br><span class="line">        <span class="keyword">if</span> flag &amp; FIN <span class="keyword">and</span> flag &amp; ACK <span class="keyword">and</span> ackNum == self.snext:</span><br><span class="line">            self.connected = <span class="literal">False</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[info] FIN...&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> socket.timeout:</span><br><span class="line">        timeout_count += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[timeout] FIN ACK&quot;</span>)</span><br><span class="line">        self.udp_send(fin_pack)</span><br></pre></td></tr></table></figure>

<h2 id="2-SR"><a href="#2-SR" class="headerlink" title="2 SR"></a>2 SR</h2><p>在SR中，不再使用GBN的累积确认机制，接收方会分别确认每一个收到的包，即使包提前到了也会保存并发送其ACK。此外，对于每一个已发送未确认的包，发送方都会分别维护一个时钟，当某个包的时钟超时了，发送方会单独发送那一个包（所以叫选择重传）。</p>
<p>因此，一个重点是实现（至少逻辑上）分离的时钟，另一个重点就是区分已收到和未收到的包。</p>
<h3 id="2-1-时钟"><a href="#2-1-时钟" class="headerlink" title="2.1 时钟"></a>2.1 时钟</h3><p>为了实现时钟的逻辑分离，我采用了尽量模拟的方法。我将超时间隔减小，作为类似“普朗克时间”或原子时间的概念。每次超时时，检测每个还在计时的时钟，如果他们超时了就进行重传，然后更新时钟。</p>
<p>我为我的socket添加了一个列表域 <code>self.sclkq</code>，全称为send clock queue。它将作为一个队列来使用，其每个元素都是一个 seq：timestamp 的元组。</p>
<p>当一个包（对应一个序列号）在send中被第一次发送时，它的序列号与这时的时间戳组成的元组将会被加入 <code>sclkq</code> 的队尾。如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># send packets</span></span><br><span class="line"><span class="keyword">while</span> self.sbase != self.spos:</span><br><span class="line">    <span class="keyword">if</span> (self.snext - self.sbase) % <span class="number">256</span> &lt; self.window_size <span class="keyword">and</span> self.snext != self.spos:</span><br><span class="line">        pkt = make_pkt(self.snext, self.rexpect, self.sdata[self.snext])</span><br><span class="line">        self.udp_send(pkt)</span><br><span class="line">        self.sclkq.append((self.snext, time.time()))    <span class="comment"># add to clock queue</span></span><br><span class="line">        self.snext = (self.snext + <span class="number">1</span>) % <span class="number">256</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self._wait():</span><br><span class="line">            <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>当在wait函数中发生了基础超时，程序将会重复检查 <code>sclkq</code> 的队首，若当前时间戳与其记录的时间戳差值（也就是距离上次发送过去的时间）超过了设置的超时时间，那么程序将会重传这个序列号的包，并把该元组出列，将其序列号与当前的新时间戳构成的元组重新加入队尾。如下代码所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">except</span> socket.timeout:</span><br><span class="line">    <span class="keyword">if</span> (recv):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># check clock queue</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(self.sclkq) &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> time.time() - self.sclkq[<span class="number">0</span>][<span class="number">1</span>] &gt;= self.timeout:</span><br><span class="line">            pkt = make_pkt(self.sclkq[<span class="number">0</span>][<span class="number">0</span>], self.rexpect, self.sdata[self.sclkq[<span class="number">0</span>][<span class="number">0</span>]])</span><br><span class="line">            self.udp_send(pkt)</span><br><span class="line">            self.sclkq.append((self.sclkq[<span class="number">0</span>][<span class="number">0</span>], time.time()))</span><br><span class="line">            <span class="keyword">del</span> self.sclkq[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<p>这样一来，就实现了发送方对每个包的单独时钟的选择重传。</p>
<h3 id="2-2-确认"><a href="#2-2-确认" class="headerlink" title="2.2 确认"></a>2.2 确认</h3><p>在SR协议中，ACK表示收到了该序列号的包，而不是累积确认，因此接收方可以提前保存并确认包。如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># save data</span></span><br><span class="line"><span class="keyword">if</span> getChecksum(data) == checksum:</span><br><span class="line">    <span class="keyword">if</span> self.rdata[seqNum] <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        self.rdata[seqNum] = data</span><br><span class="line"></span><br><span class="line">    <span class="comment"># send ACK</span></span><br><span class="line">    ack_pkt = make_pkt((self.snext-<span class="number">1</span>)%<span class="number">256</span>, seqNum, <span class="string">b&quot;&quot;</span>, ack=<span class="literal">True</span>)</span><br><span class="line">    self.udp_send(ack_pkt)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># update rexpect</span></span><br><span class="line">    i = self.rexpect</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> self.rdata[i] <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        self.rexpect = (self.rexpect + <span class="number">1</span>) % <span class="number">256</span></span><br><span class="line">        i = self.rexpect</span><br></pre></td></tr></table></figure>

<p>注意上段代码中，更新rexpect的方式并不再是简单地加一，而是一直推进到没有收到的地方。区间 $[rbase, rexpect]$ 表示<strong>连续的</strong>可以返回给上层的数据，而rexpect之后可能存在离散的收到的数据，这些数据还不能返回给上层（否则就是乱序了）。</p>
<p>而对于发送方，当接收到ACK时，采用删除其在 <code>sclkq</code> 中的元组的方式，来取消其发送。在遍历 <code>sclkq</code> 时，同时记录最早的仍在队列中的包 <code>crt_min_unacked</code>。如果 <code>crt_min_unacked</code> 和 <code>sbase</code> 不相等，则说明 <code>sbase</code> 可以更新，于是会更新后返回。代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># handle ACK</span></span><br><span class="line"><span class="keyword">if</span> (flag &amp; ACK):</span><br><span class="line">    <span class="comment"># update clock queue</span></span><br><span class="line">    crt_min_unacked = self.snext</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(self.sclkq):</span><br><span class="line">        crt = self.sclkq[i][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> ackNum == crt:</span><br><span class="line">            self.sclkq.pop(i)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> (crt - self.sbase) % <span class="number">256</span> &lt; (self.snext - self.sbase) % <span class="number">256</span>:  <span class="comment"># in window</span></span><br><span class="line">                <span class="keyword">if</span> crt &lt; WINDOW_SIZE:</span><br><span class="line">                    crt += <span class="number">256</span></span><br><span class="line">                <span class="keyword">if</span> crt &lt; crt_min_unacked:</span><br><span class="line">                    crt_min_unacked = crt</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">    crt_min_unacked %= <span class="number">256</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> self.sbase != crt_min_unacked:</span><br><span class="line">        self.sbase = crt_min_unacked</span><br><span class="line">        self.udp_socket.settimeout(<span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-拥塞控制"><a href="#2-3-拥塞控制" class="headerlink" title="2.3 拥塞控制"></a>2.3 拥塞控制</h3><p>至此，SR协议已经完成了。不过我再加入了一些最基础的拥塞控制机制，也就是AIMD。</p>
<p>我通过修改 <code>self.window_size</code> 来完成拥塞控制，<code>send</code> 会根据这个变量来决定发不发送新的包。具体的修改位于 <code>wait</code> 函数中，Additive Increase位于收到ACK且更新 <code>sbase</code> 时，确认数量达到当前的 <code>self.window_size</code> 时就会将其加一，代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># update window size (congestion control)</span></span><br><span class="line">self.ackcount += (crt_min_unacked - self.sbase) % <span class="number">256</span></span><br><span class="line"><span class="keyword">if</span> self.ackcount &gt;= self.window_size:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[CNG_CTRL] add window size from&#x27;</span>, self.window_size, <span class="string">&#x27;to&#x27;</span>, self.window_size+<span class="number">1</span>)</span><br><span class="line">    self.window_size += <span class="number">1</span></span><br><span class="line">    self.ackcount = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>而Multiplicative Decrease位于处理一个包超时时，每有一个包超时就会触发这个机制，代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># update window size (congestion control)</span></span><br><span class="line">new_window_size = <span class="built_in">max</span>(<span class="number">2</span>, self.window_size // <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[CNG_CTRL] reduce window size from&#x27;</span>, self.window_size, <span class="string">&#x27;to&#x27;</span>, new_window_size)</span><br><span class="line">self.window_size = new_window_size</span><br></pre></td></tr></table></figure>

<h2 id="3-测试"><a href="#3-测试" class="headerlink" title="3 测试"></a>3 测试</h2><p>我编写了测试脚本用于测试客户端和服务端间连接是否可以准确传输整个图片文件，主要逻辑如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ((i=<span class="number">1</span>; i&lt;=<span class="variable">$num_runs</span>; i++)); <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">rm</span> ./server_log</span><br><span class="line">    <span class="built_in">rm</span> ./client_log</span><br><span class="line">    python ./sr_server.py 1&gt; ./server_log &amp;</span><br><span class="line">    server_pid=$!</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span> 1</span><br><span class="line"></span><br><span class="line">    python ./sr_client.py 1&gt; ./client_log</span><br><span class="line"></span><br><span class="line">    <span class="built_in">wait</span> <span class="variable">$server_pid</span></span><br><span class="line"></span><br><span class="line">    cmp -s ./server/recv.jpg ./client/data.jpg</span><br><span class="line">    <span class="keyword">if</span> [ $? -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Test <span class="variable">$i</span>: Files match&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Test <span class="variable">$i</span>: Files do not match&quot;</span></span><br><span class="line">        <span class="built_in">break</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span> 4</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>不论是sr客户端与服务器，还是gbn客户端与服务器，都使用该脚本，在丢包率非0的条件下（gbn使用20%测试，sr由于赶ddl原因使用5%测试，高丢包率环境下也测试过没问题）跑过了超过200轮的测试连续正确。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一开始尝试在助教提供的实例代码上修改来做实验，但越改越复杂。由于sender和receiver是两个不同的类，因此一些函数复用起来非常烦，有的函数必须要写两遍。</p>
<p>因此我全都推倒重来，除了一些基础的函数以及思路的借鉴外，别的东西全都重新写。尤其是wait函数的复用，自认为比较简洁地实现了我的socket的全双工。</p>
<p>写完后，我对于rdt（以及TCP）的理解确实变得更深了，收获不错。虽然期末季很忙，不过还是抽了时间完成了这个PJ，幸苦自己了hhhh。</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/Tech/Pwn/b0d805e48d9f.html" rel="prev" title="【Pwn#0x12】pwnable.tw seethefile writeup">
      <i class="fa fa-chevron-left"></i> 【Pwn#0x12】pwnable.tw seethefile writeup
    </a></div>
      <div class="post-nav-item">
    <a href="/Tech/Tool/47d132dae007.html" rel="next" title="【Tool#0x01】Linux(Kali) 环境配置">
      【Tool#0x01】Linux(Kali) 环境配置 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-GBN"><span class="nav-number">1.</span> <span class="nav-text">1 GBN</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E5%87%86%E5%A4%87"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 准备</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 滑动窗口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E9%9B%8F%E5%BD%A2"><span class="nav-number">1.3.</span> <span class="nav-text">1.3 雏形</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-%E8%BF%9E%E6%8E%A5"><span class="nav-number">1.4.</span> <span class="nav-text">1.4 连接</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5"><span class="nav-number">1.4.1.</span> <span class="nav-text">建立连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5"><span class="nav-number">1.4.2.</span> <span class="nav-text">断开连接</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-SR"><span class="nav-number">2.</span> <span class="nav-text">2 SR</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E6%97%B6%E9%92%9F"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 时钟</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E7%A1%AE%E8%AE%A4"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 确认</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 拥塞控制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%B5%8B%E8%AF%95"><span class="nav-number">3.</span> <span class="nav-text">3 测试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">4.</span> <span class="nav-text">总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Cameudis"
      src="/images/ava1.jpg">
  <p class="site-author-name" itemprop="name">Cameudis</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">66</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/cameudis" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;cameudis" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:cameudis@gmail.com" title="E-Mail → mailto:cameudis@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://x.com/cameudis" title="Twitter → https:&#x2F;&#x2F;x.com&#x2F;cameudis" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-dove"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Cameudis</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  















    <div id="pjax">
  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'Ji5y9HTOlb2QGDO0XFlWXNRy-gzGzoHsz',
      appKey     : '6VqGye1352LX381YQDTOaiXs',
      placeholder: "El Psy Congroo",
      avatar     : 'retro',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

    </div>
</body>
</html>
